From 6420a299de9faa3bdc8617b8b25a238d70db2fc3 Mon Sep 17 00:00:00 2001
From: Valentine Barshak <valentine.barshak@cogentembedded.com>
Date: Wed, 6 Mar 2019 00:19:06 +0300
Subject: [PATCH 4/7] Add display_poll function

---
 clients/toytoolkit.h |  3 +++
 clients/window.c     | 52 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 55 insertions(+)

diff --git a/clients/toytoolkit.h b/clients/toytoolkit.h
index 2bcecc1..a77eda3 100644
--- a/clients/toytoolkit.h
+++ b/clients/toytoolkit.h
@@ -163,6 +163,9 @@ display_unwatch_fd(struct display *display, int fd);
 void
 display_run(struct display *d);
 
+int
+display_poll(struct display *display, int timeout);
+
 void
 display_exit(struct display *d);
 
diff --git a/clients/window.c b/clients/window.c
index 3a7467d..162d765 100644
--- a/clients/window.c
+++ b/clients/window.c
@@ -6473,6 +6473,58 @@ display_run(struct display *display)
 	}
 }
 
+int
+display_poll(struct display *display, int timeout)
+{
+	struct task *task;
+	struct epoll_event ep[16];
+	int i, count, ret;
+
+	display->running = 1;
+	while (!wl_list_empty(&display->deferred_list)) {
+		task = container_of(display->deferred_list.prev,
+		                    struct task, link);
+		wl_list_remove(&task->link);
+		task->run(task, 0);
+	}
+
+    /* ...prepare for a reading */
+    while (wl_display_prepare_read(display->display) != 0)
+    {
+        /* ...dispatch all pending events and repeat attempt */
+        wl_display_dispatch_pending(display->display);
+    }
+
+    /* ...flush all outstanding commands to a display */
+    if (wl_display_flush(display->display) < 0) {
+        return -1;
+    }
+
+    if (!display->running)
+	    return -1;
+
+    count = epoll_wait(display->epoll_fd, ep, ARRAY_LENGTH(ep), timeout);
+    if (!count) {
+        wl_display_cancel_read(display->display);
+        return 0;
+    }
+
+    if (count > 0) {
+        /* ...read display events (if any) before we do any drawing */
+        if (wl_display_read_events(display->display) < 0) {
+            return -1;
+        }
+
+        /* ...process pending display events (if any) */
+        if (wl_display_dispatch_pending(display->display) < 0) {
+            return -1;
+        }
+    } else if (count < 0) {
+        wl_display_cancel_read(display->display);
+        return count;
+    }
+}
+
 void
 display_exit(struct display *display)
 {
-- 
2.7.4

