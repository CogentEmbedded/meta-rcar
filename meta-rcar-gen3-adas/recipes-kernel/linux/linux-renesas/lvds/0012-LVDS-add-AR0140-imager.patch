From 11238cfb50296a491d4eab6bdf128d3a1a46cab9 Mon Sep 17 00:00:00 2001
From: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
Date: Tue, 30 Oct 2018 01:04:27 +0300
Subject: [PATCH] LVDS: add AR0140 imager

This adds AR0140 on TI serializer

Signed-off-by: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
---
 drivers/media/i2c/soc_camera/ar0140.c  | 648 +++++++++++++++++++++++++++++++++
 drivers/media/i2c/soc_camera/ar0140.h  | 475 ++++++++++++++++++++++++
 drivers/media/i2c/soc_camera/ov106xx.c |  13 +-
 3 files changed, 1135 insertions(+), 1 deletion(-)
 create mode 100644 drivers/media/i2c/soc_camera/ar0140.c
 create mode 100644 drivers/media/i2c/soc_camera/ar0140.h

diff --git a/drivers/media/i2c/soc_camera/ar0140.c b/drivers/media/i2c/soc_camera/ar0140.c
new file mode 100644
index 0000000..7fd34ac
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/ar0140.c
@@ -0,0 +1,648 @@
+/*
+ * ON Semiconductor AR0140 sensor camera driver
+ *
+ * Copyright (C) 2018 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/videodev2.h>
+
+#include <media/soc_camera.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-of.h>
+
+#include "ar0140.h"
+
+#define AR0140_I2C_ADDR		0x10
+
+#define AR0140_PID		0x3000
+#define AR0140_VERSION_REG	0x0051
+
+#define AR0140_MEDIA_BUS_FMT	MEDIA_BUS_FMT_SGRBG12_1X12
+
+struct ar0140_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				init_complete;
+	u8				id[6];
+	/* serializers */
+	int				max9286_addr;
+	int				max9271_addr;
+	int				ti9x4_addr;
+	int				ti9x3_addr;
+	int				port;
+	int				gpio_resetb;
+	int				gpio_fsin;
+	int				hts;
+	int				vts;
+	int				frame_preamble;
+};
+
+static inline struct ar0140_priv *to_ar0140(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ar0140_priv, sd);
+}
+
+static void ar0140_s_port(struct i2c_client *client, int fwd_en)
+{
+	struct ar0140_priv *priv = to_ar0140(client);
+	int tmp_addr;
+
+	if (priv->max9286_addr) {
+		tmp_addr = client->addr;
+		client->addr = priv->max9286_addr;				/* Deserializer I2C address */
+		reg8_write(client, 0x0a, fwd_en ? 0x11 << priv->port : 0);	/* Enable/disable reverse/forward control for this port */
+		usleep_range(5000, 5500);					/* wait 5ms */
+		client->addr = tmp_addr;
+	};
+}
+
+static int ar0140_set_regs(struct i2c_client *client,
+			  const struct ar0140_reg *regs, int nr_regs)
+{
+	struct ar0140_priv *priv = to_ar0140(client);
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == AR0140_DELAY) {
+			mdelay(regs[i].val);
+			continue;
+		}
+		/* cache timings */
+		if (regs[i].reg == 0x300a)
+			priv->vts = regs[i].val;
+		if (regs[i].reg == 0x300c)
+			priv->hts = regs[i].val;
+		if (regs[i].reg == 0x31b0)
+			priv->frame_preamble = regs[i].val - 1;
+
+		reg16_write16(client, regs[i].reg, regs[i].val);
+	}
+
+	return 0;
+}
+
+static int ar0140_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ar0140_set_window(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0140_priv *priv = to_ar0140(client);
+
+	dev_dbg(&client->dev, "L=%d T=%d %dx%d\n", priv->rect.left, priv->rect.top, priv->rect.width, priv->rect.height);
+
+	/* horiz crop start */
+	reg16_write16(client, 0x3004, priv->rect.left);
+	/* horiz crop end */
+	reg16_write16(client, 0x3008, priv->rect.left + priv->rect.width - 1);
+	/* vert crop start */
+	reg16_write16(client, 0x3002, priv->rect.top);
+	/* vert crop end */
+	reg16_write16(client, 0x3006, priv->rect.top + priv->rect.height + 1);
+
+	return 0;
+};
+
+static int ar0140_get_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0140_priv *priv = to_ar0140(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = AR0140_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ar0140_set_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = AR0140_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ar0140_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = AR0140_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ar0140_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0140_priv *priv = to_ar0140(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = AR0140_VERSION_REG >> 8;
+	edid->edid[9] = AR0140_VERSION_REG & 0xff;
+
+	return 0;
+}
+
+static int ar0140_set_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0140_priv *priv = to_ar0140(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > AR0140_MAX_WIDTH) ||
+	    (rect->top + rect->height > AR0140_MAX_HEIGHT))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	ar0140_set_window(sd);
+
+	return 0;
+}
+
+static int ar0140_get_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0140_priv *priv = to_ar0140(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = AR0140_MAX_WIDTH;
+		sel->r.height = AR0140_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = AR0140_MAX_WIDTH;
+		sel->r.height = AR0140_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ar0140_g_mbus_config(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ar0140_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val = 0;
+
+	ret = reg16_read16(client, (u16)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int ar0140_s_register(struct v4l2_subdev *sd,
+			    const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return reg16_write16(client, (u16)reg->reg, (u16)reg->val);
+}
+#endif
+
+static struct v4l2_subdev_core_ops ar0140_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ar0140_g_register,
+	.s_register = ar0140_s_register,
+#endif
+};
+
+static int ar0140_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0140_priv *priv = to_ar0140(client);
+	int ret = -EINVAL;
+	u16 val = 0;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_AUTOGAIN:
+		break;
+	case V4L2_CID_GAIN:
+		/* Digital gain */
+		ret = reg16_write16(client, 0x305e, ctrl->val);
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		/* Analog gain */
+		ret = reg16_write16(client, 0x3060, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE:
+		/* T1 exposure */
+		ret = reg16_write16(client, 0x3012, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		ret = reg16_read16(client, 0x3040, &val);
+		if (ctrl->val)
+			val |= 0x4000;
+		else
+			val &= ~0x4000;
+		ret |= reg16_write16(client, 0x3040, val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = reg16_read16(client, 0x3040, &val);
+		if (ctrl->val)
+			val |= 0x8000;
+		else
+			val &= ~0x8000;
+		ret |= reg16_write16(client, 0x3040, val);
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ar0140_ctrl_ops = {
+	.s_ctrl = ar0140_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ar0140_video_ops = {
+	.s_stream	= ar0140_s_stream,
+	.g_mbus_config	= ar0140_g_mbus_config,
+};
+
+static const struct v4l2_subdev_pad_ops ar0140_subdev_pad_ops = {
+	.get_edid	= ar0140_get_edid,
+	.enum_mbus_code	= ar0140_enum_mbus_code,
+	.get_selection	= ar0140_get_selection,
+	.set_selection	= ar0140_set_selection,
+	.get_fmt	= ar0140_get_fmt,
+	.set_fmt	= ar0140_set_fmt,
+};
+
+static struct v4l2_subdev_ops ar0140_subdev_ops = {
+	.core	= &ar0140_core_ops,
+	.video	= &ar0140_video_ops,
+	.pad	= &ar0140_subdev_pad_ops,
+};
+
+static void ar0140_otp_id_read(struct i2c_client *client)
+{
+	struct ar0140_priv *priv = to_ar0140(client);
+	int i;
+	u16 val = 0;
+
+	/* read camera id from ar014x OTP memory */
+	reg16_write16(client, 0x3054, 0x400);
+	reg16_write16(client, 0x304a, 0x110);
+	usleep_range(25000, 25500); /* wait 25 ms */
+
+	for (i = 0; i < 6; i += 2) {
+		/* first 4 bytes are equal on all ar014x */
+		reg16_read16(client, 0x3800 + i + 4, &val);
+		priv->id[i]     = val >> 8;
+		priv->id[i + 1] = val & 0xff;
+	}
+}
+
+static ssize_t ar0140_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0140_priv *priv = to_ar0140(client);
+
+	ar0140_otp_id_read(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ar0140, S_IRUGO, ar0140_otp_id_show, NULL);
+
+static int ar0140_initialize(struct i2c_client *client)
+{
+	struct ar0140_priv *priv = to_ar0140(client);
+	u16 val = 0;
+	u16 pid = 0;
+	int ret = 0;
+	int tmp_addr;
+
+	ar0140_s_port(client, 1);
+
+	/* check and show model ID */
+	reg16_read16(client, AR0140_PID, &pid);
+
+	if (pid != AR0140_VERSION_REG) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	tmp_addr = client->addr;
+	if (priv->max9271_addr) {
+		/* setup serializer HS generator */
+		client->addr = priv->max9271_addr;			/* Serializer I2C address */
+		reg8_write(client, 0x4e, priv->frame_preamble >> 16);	/* HS delay */
+		reg8_write(client, 0x4f, (priv->frame_preamble >> 8) & 0xff);
+		reg8_write(client, 0x50, priv->frame_preamble & 0xff);
+		reg8_write(client, 0x54, AR0140_MAX_WIDTH >> 8);	/* HS high period */
+		reg8_write(client, 0x55, AR0140_MAX_WIDTH & 0xff);
+		reg8_write(client, 0x56, (priv->hts - AR0140_MAX_WIDTH) >> 8); /* HS low period */
+		reg8_write(client, 0x57, (priv->hts - AR0140_MAX_WIDTH) & 0xff);
+		reg8_write(client, 0x58, priv->vts >> 8);		/* HS count */
+		reg8_write(client, 0x59, priv->vts & 0xff);
+	}
+	client->addr = tmp_addr;
+
+	/* Read OTP IDs */
+	ar0140_otp_id_read(client);
+	/* Program wizard registers */
+	ar0140_set_regs(client, ar0140_regs_wizard, ARRAY_SIZE(ar0140_regs_wizard));
+	/* Enable stream */
+	reg16_read16(client, 0x301a, &val);	// read inital reset_register value
+	val |= (1 << 2);			// Set streamOn bit
+	reg16_write16(client, 0x301a, val);	// Start Streaming
+
+	dev_info(&client->dev, "ar0140 PID %x, res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, AR0140_MAX_WIDTH, AR0140_MAX_HEIGHT, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+err:
+	ar0140_s_port(client, 0);
+
+	return ret;
+}
+
+static int ar0140_parse_dt(struct device_node *np, struct ar0140_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	int i;
+	struct device_node *endpoint = NULL, *rendpoint = NULL;
+	int tmp_addr = 0;
+
+	for (i = 0; ; i++) {
+		endpoint = of_graph_get_next_endpoint(np, endpoint);
+		if (!endpoint)
+			break;
+
+		of_node_put(endpoint);
+
+		rendpoint = of_parse_phandle(endpoint, "remote-endpoint", 0);
+		if (!rendpoint)
+			continue;
+
+		if (!of_property_read_u32(rendpoint, "max9271-addr", &priv->max9271_addr) &&
+		    !of_property_read_u32(rendpoint->parent->parent, "reg", &priv->max9286_addr) &&
+		    !kstrtouint(strrchr(rendpoint->full_name, '@') + 1, 0, &priv->port))
+			break;
+
+		if (!of_property_read_u32(rendpoint, "ti9x3-addr", &priv->ti9x3_addr) &&
+		    !of_property_match_string(rendpoint->parent->parent, "compatible", "ti,ti9x4") &&
+		    !of_property_read_u32(rendpoint->parent->parent, "reg", &priv->ti9x4_addr) &&
+		    !kstrtouint(strrchr(rendpoint->full_name, '@') + 1, 0, &priv->port))
+			break;
+	}
+
+	if (!priv->max9286_addr && !priv->ti9x4_addr) {
+		dev_err(&client->dev, "deserializer does not present for AR0140\n");
+		return -EINVAL;
+	}
+
+	ar0140_s_port(client, 1);
+
+	/* setup I2C translator address */
+	tmp_addr = client->addr;
+	if (priv->max9286_addr) {
+		client->addr = priv->max9271_addr;			/* Serializer I2C address */
+
+		reg8_write(client, 0x09, tmp_addr << 1);		/* Sensor translated I2C address */
+		reg8_write(client, 0x0A, AR0140_I2C_ADDR << 1);		/* Sensor native I2C address */
+		usleep_range(2000, 2500);				/* wait 2ms */
+	};
+	if (priv->ti9x4_addr) {
+		client->addr = priv->ti9x4_addr;			/* Deserializer I2C address */
+
+		reg8_write(client, 0x4c, (priv->port << 4) | (1 << priv->port)); /* Select RX port number */
+		usleep_range(2000, 2500);				/* wait 2ms */
+		reg8_write(client, 0x65, tmp_addr << 1);		/* Sensor translated I2C address */
+		reg8_write(client, 0x5d, AR0140_I2C_ADDR << 1);		/* Sensor native I2C address */
+
+		reg8_write(client, 0x6e, 0x9a);				/* GPIO0 - fsin, GPIO1 - reset */
+	}
+	client->addr = tmp_addr;
+
+	mdelay(10);
+
+	return 0;
+}
+
+static int ar0140_probe(struct i2c_client *client,
+		       const struct i2c_device_id *did)
+{
+	struct ar0140_priv *priv;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ar0140_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_GAIN, 1, 0x7ff, 1, 0x80);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_ANALOGUE_GAIN, 1, 0x7ff, 1, 0x1);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 1, 0x400, 1, 0x206);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0140_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->sd.entity.flags |= MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ar0140_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ar0140_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = AR0140_MAX_WIDTH;
+	priv->rect.height = AR0140_MAX_HEIGHT;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ar0140) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+#ifdef CONFIG_SOC_CAMERA_AR0140
+	v4l_err(client, "failed to probe @ 0x%02x (%s)\n",
+		client->addr, client->adapter->name);
+#endif
+	return ret;
+}
+
+static int ar0140_remove(struct i2c_client *client)
+{
+	struct ar0140_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ar0140);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+#ifdef CONFIG_SOC_CAMERA_AR0140
+static const struct i2c_device_id ar0140_id[] = {
+	{ "ar0140", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ar0140_id);
+
+static const struct of_device_id ar0140_of_ids[] = {
+	{ .compatible = "aptina,ar0140", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ar0140_of_ids);
+
+static struct i2c_driver ar0140_i2c_driver = {
+	.driver	= {
+		.name		= "ar0140",
+		.of_match_table	= ar0140_of_ids,
+	},
+	.probe		= ar0140_probe,
+	.remove		= ar0140_remove,
+	.id_table	= ar0140_id,
+};
+
+module_i2c_driver(ar0140_i2c_driver);
+
+MODULE_DESCRIPTION("SoC Camera driver for AR0140");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
+#endif
diff --git a/drivers/media/i2c/soc_camera/ar0140.h b/drivers/media/i2c/soc_camera/ar0140.h
new file mode 100644
index 0000000..85792c5
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/ar0140.h
@@ -0,0 +1,475 @@
+/*
+ * ON Semiconductor AR0140 sensor camera wizard 1344x968@30/BGGR/BT601/RAW12
+ *
+ * Copyright (C) 2018 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+//#define AR0140_DISPLAY_PATTERN_FIXED
+//#define AR0140_DISPLAY_PATTERN_COLOR_BAR
+
+//#define AR0140_EMBEDDED_LINE
+
+#define AR0140_MAX_WIDTH	1280
+#define AR0140_MAX_HEIGHT	800
+
+#define AR0140_DELAY		0xffff
+
+#define AR0140_SENSOR_WIDTH	1280
+#define AR0140_SENSOR_HEIGHT	800
+
+#define AR0140_X_START		((AR0140_SENSOR_WIDTH - AR0140_MAX_WIDTH) / 2)
+#define AR0140_Y_START		((AR0140_SENSOR_HEIGHT - AR0140_MAX_HEIGHT) / 2)
+#define AR0140_X_END		(AR0140_X_START + AR0140_MAX_WIDTH - 1)
+#define AR0140_Y_END		(AR0140_Y_START + AR0140_MAX_HEIGHT + 1) /* must be +1 and not -1 or 2 lines missed - bug in imager? */
+
+struct ar0140_reg {
+	u16	reg;
+	u16	val;
+};
+
+static const struct ar0140_reg ar0140_regs_wizard[] = {
+{0x301A, 0x0001},	// reset
+{AR0140_DELAY, 100},
+{0x301A, 0x10D8},	// Stream off and setup parallel
+{0x3070, 0x0001},
+{0x3070, 0x0000},	//  1: Solid color test pattern,
+			//  2: Full color bar test pattern,
+			//  3: Fade to grey color bar test pattern,
+			//256: Walking 1 test pattern (12 bit)
+#ifdef AR0140_DISPLAY_PATTERN_FIXED
+{0x3070, 0x0001},
+#endif
+{0x3072, 0x0fff},	// R
+{0x3074, 0x0fff},	// G(GR row)
+{0x3076, 0x0fff},	// B
+{0x3078, 0x0fff},	// G(GB row)
+#ifdef AR0140_DISPLAY_PATTERN_COLOR_BAR
+{0x3070, 0x0002},
+#endif
+{AR0140_DELAY, 250},
+/* SEQ_CTRL_PORT */
+{0x3088, 0x8000},
+/* SEQ_DATA_PORT */
+{0x3086, 0x4558},
+{0x3086, 0x6E9B},
+{0x3086, 0x4A31},
+{0x3086, 0x4342},
+{0x3086, 0x8E03},
+{0x3086, 0x2714},
+{0x3086, 0x4578},
+{0x3086, 0x7B3D},
+{0x3086, 0xFF3D},
+{0x3086, 0xFF3D},
+{0x3086, 0xEA27},
+{0x3086, 0x043D},
+{0x3086, 0x1027},
+{0x3086, 0x0527},
+{0x3086, 0x1535},
+{0x3086, 0x2705},
+{0x3086, 0x3D10},
+{0x3086, 0x4558},
+{0x3086, 0x2704},
+{0x3086, 0x2714},
+{0x3086, 0x3DFF},
+{0x3086, 0x3DFF},
+{0x3086, 0x3DEA},
+{0x3086, 0x2704},
+{0x3086, 0x6227},
+{0x3086, 0x288E},
+{0x3086, 0x0036},
+{0x3086, 0x2708},
+{0x3086, 0x3D64},
+{0x3086, 0x7A3D},
+{0x3086, 0x0444},
+{0x3086, 0x2C4B},
+{0x3086, 0x8F00},
+{0x3086, 0x4372},
+{0x3086, 0x719F},
+{0x3086, 0x6343},
+{0x3086, 0x166F},
+{0x3086, 0x9F92},
+{0x3086, 0x1244},
+{0x3086, 0x1663},
+{0x3086, 0x4316},
+{0x3086, 0x9326},
+{0x3086, 0x0426},
+{0x3086, 0x848E},
+{0x3086, 0x0327},
+{0x3086, 0xFC5C},
+{0x3086, 0x0D57},
+{0x3086, 0x5417},
+{0x3086, 0x0955},
+{0x3086, 0x5649},
+{0x3086, 0x5F53},
+{0x3086, 0x0553},
+{0x3086, 0x0728},
+{0x3086, 0x6C4C},
+{0x3086, 0x0928},
+{0x3086, 0x2C72},
+{0x3086, 0xAD7C},
+{0x3086, 0xA928},
+{0x3086, 0xA879},
+{0x3086, 0x6026},
+{0x3086, 0x9C5C},
+{0x3086, 0x1B45},
+{0x3086, 0x4845},
+{0x3086, 0x0845},
+{0x3086, 0x8826},
+{0x3086, 0xBE8E},
+{0x3086, 0x0127},
+{0x3086, 0xF817},
+{0x3086, 0x0227},
+{0x3086, 0xFA17},
+{0x3086, 0x095C},
+{0x3086, 0x0B17},
+{0x3086, 0x1026},
+{0x3086, 0xBA5C},
+{0x3086, 0x0317},
+{0x3086, 0x1026},
+{0x3086, 0xB217},
+{0x3086, 0x065F},
+{0x3086, 0x2888},
+{0x3086, 0x9060},
+{0x3086, 0x27F2},
+{0x3086, 0x1710},
+{0x3086, 0x26A2},
+{0x3086, 0x26A3},
+{0x3086, 0x5F4D},
+{0x3086, 0x2808},
+{0x3086, 0x1927},
+{0x3086, 0xFA84},
+{0x3086, 0x69A0},
+{0x3086, 0x785D},
+{0x3086, 0x2888},
+{0x3086, 0x8710},
+{0x3086, 0x8C82},
+{0x3086, 0x8926},
+{0x3086, 0xB217},
+{0x3086, 0x036B},
+{0x3086, 0x9C60},
+{0x3086, 0x9417},
+{0x3086, 0x2926},
+{0x3086, 0x8345},
+{0x3086, 0xA817},
+{0x3086, 0x0727},
+{0x3086, 0xFB17},
+{0x3086, 0x2945},
+{0x3086, 0x881F},
+{0x3086, 0x1708},
+{0x3086, 0x27FA},
+{0x3086, 0x5D87},
+{0x3086, 0x108C},
+{0x3086, 0x8289},
+{0x3086, 0x170E},
+{0x3086, 0x4826},
+{0x3086, 0x9A28},
+{0x3086, 0x884C},
+{0x3086, 0x0B79},
+{0x3086, 0x1730},
+{0x3086, 0x2692},
+{0x3086, 0x1709},
+{0x3086, 0x9160},
+{0x3086, 0x27F2},
+{0x3086, 0x1710},
+{0x3086, 0x2682},
+{0x3086, 0x2683},
+{0x3086, 0x5F4D},
+{0x3086, 0x2808},
+{0x3086, 0x1927},
+{0x3086, 0xFA84},
+{0x3086, 0x69A1},
+{0x3086, 0x785D},
+{0x3086, 0x2888},
+{0x3086, 0x8710},
+{0x3086, 0x8C80},
+{0x3086, 0x8A26},
+{0x3086, 0x9217},
+{0x3086, 0x036B},
+{0x3086, 0x9D95},
+{0x3086, 0x2603},
+{0x3086, 0x5C01},
+{0x3086, 0x4558},
+{0x3086, 0x8E00},
+{0x3086, 0x2798},
+{0x3086, 0x170A},
+{0x3086, 0x4A65},
+{0x3086, 0x4316},
+{0x3086, 0x6643},
+{0x3086, 0x165B},
+{0x3086, 0x4316},
+{0x3086, 0x5943},
+{0x3086, 0x168E},
+{0x3086, 0x0327},
+{0x3086, 0x9C45},
+{0x3086, 0x7817},
+{0x3086, 0x0727},
+{0x3086, 0x9D17},
+{0x3086, 0x225D},
+{0x3086, 0x8710},
+{0x3086, 0x2808},
+{0x3086, 0x530D},
+{0x3086, 0x8C80},
+{0x3086, 0x8A45},
+{0x3086, 0x5823},
+{0x3086, 0x1708},
+{0x3086, 0x8E01},
+{0x3086, 0x2798},
+{0x3086, 0x8E00},
+{0x3086, 0x2644},
+{0x3086, 0x5C05},
+{0x3086, 0x1244},
+{0x3086, 0x4B71},
+{0x3086, 0x759E},
+{0x3086, 0x8B85},
+{0x3086, 0x0143},
+{0x3086, 0x7271},
+{0x3086, 0xA346},
+{0x3086, 0x4316},
+{0x3086, 0x6FA3},
+{0x3086, 0x9612},
+{0x3086, 0x4416},
+{0x3086, 0x4643},
+{0x3086, 0x1697},
+{0x3086, 0x2604},
+{0x3086, 0x2684},
+{0x3086, 0x8E03},
+{0x3086, 0x27FC},
+{0x3086, 0x5C0D},
+{0x3086, 0x5754},
+{0x3086, 0x1709},
+{0x3086, 0x5556},
+{0x3086, 0x495F},
+{0x3086, 0x5305},
+{0x3086, 0x5307},
+{0x3086, 0x286C},
+{0x3086, 0x4C09},
+{0x3086, 0x282C},
+{0x3086, 0x72AE},
+{0x3086, 0x7CAA},
+{0x3086, 0x28A8},
+{0x3086, 0x7960},
+{0x3086, 0x269C},
+{0x3086, 0x5C1B},
+{0x3086, 0x4548},
+{0x3086, 0x4508},
+{0x3086, 0x4588},
+{0x3086, 0x26BE},
+{0x3086, 0x8E01},
+{0x3086, 0x27F8},
+{0x3086, 0x1702},
+{0x3086, 0x27FA},
+{0x3086, 0x1709},
+{0x3086, 0x5C0B},
+{0x3086, 0x1710},
+{0x3086, 0x26BA},
+{0x3086, 0x5C03},
+{0x3086, 0x1710},
+{0x3086, 0x26B2},
+{0x3086, 0x1706},
+{0x3086, 0x5F28},
+{0x3086, 0x8898},
+{0x3086, 0x6027},
+{0x3086, 0xF217},
+{0x3086, 0x1026},
+{0x3086, 0xA226},
+{0x3086, 0xA35F},
+{0x3086, 0x4D28},
+{0x3086, 0x081A},
+{0x3086, 0x27FA},
+{0x3086, 0x8469},
+{0x3086, 0xA578},
+{0x3086, 0x5D28},
+{0x3086, 0x8887},
+{0x3086, 0x108C},
+{0x3086, 0x8289},
+{0x3086, 0x26B2},
+{0x3086, 0x1703},
+{0x3086, 0x6BA4},
+{0x3086, 0x6099},
+{0x3086, 0x1729},
+{0x3086, 0x2683},
+{0x3086, 0x45A8},
+{0x3086, 0x1707},
+{0x3086, 0x27FB},
+{0x3086, 0x1729},
+{0x3086, 0x4588},
+{0x3086, 0x2017},
+{0x3086, 0x0827},
+{0x3086, 0xFA5D},
+{0x3086, 0x8710},
+{0x3086, 0x8C82},
+{0x3086, 0x8917},
+{0x3086, 0x0E48},
+{0x3086, 0x269A},
+{0x3086, 0x2888},
+{0x3086, 0x4C0B},
+{0x3086, 0x7917},
+{0x3086, 0x3026},
+{0x3086, 0x9217},
+{0x3086, 0x099A},
+{0x3086, 0x6027},
+{0x3086, 0xF217},
+{0x3086, 0x1026},
+{0x3086, 0x8226},
+{0x3086, 0x835F},
+{0x3086, 0x4D28},
+{0x3086, 0x081A},
+{0x3086, 0x27FA},
+{0x3086, 0x8469},
+{0x3086, 0xAB78},
+{0x3086, 0x5D28},
+{0x3086, 0x8887},
+{0x3086, 0x108C},
+{0x3086, 0x808A},
+{0x3086, 0x2692},
+{0x3086, 0x1703},
+{0x3086, 0x6BA6},
+{0x3086, 0xA726},
+{0x3086, 0x035C},
+{0x3086, 0x0145},
+{0x3086, 0x588E},
+{0x3086, 0x0027},
+{0x3086, 0x9817},
+{0x3086, 0x0A4A},
+{0x3086, 0x0A43},
+{0x3086, 0x160B},
+{0x3086, 0x438E},
+{0x3086, 0x0327},
+{0x3086, 0x9C45},
+{0x3086, 0x7817},
+{0x3086, 0x0727},
+{0x3086, 0x9D17},
+{0x3086, 0x225D},
+{0x3086, 0x8710},
+{0x3086, 0x2808},
+{0x3086, 0x530D},
+{0x3086, 0x8C80},
+{0x3086, 0x8A45},
+{0x3086, 0x5817},
+{0x3086, 0x088E},
+{0x3086, 0x0127},
+{0x3086, 0x988E},
+{0x3086, 0x0076},
+{0x3086, 0xAC77},
+{0x3086, 0xAC46},
+{0x3086, 0x4416},
+{0x3086, 0x16A8},
+{0x3086, 0x7A26},
+{0x3086, 0x445C},
+{0x3086, 0x0512},
+{0x3086, 0x444B},
+{0x3086, 0x7175},
+{0x3086, 0xA24A},
+{0x3086, 0x0343},
+{0x3086, 0x1604},
+{0x3086, 0x4316},
+{0x3086, 0x5843},
+{0x3086, 0x165A},
+{0x3086, 0x4316},
+{0x3086, 0x0643},
+{0x3086, 0x1607},
+{0x3086, 0x4316},
+{0x3086, 0x8E03},
+{0x3086, 0x279C},
+{0x3086, 0x4578},
+{0x3086, 0x7B17},
+{0x3086, 0x078B},
+{0x3086, 0x8627},
+{0x3086, 0x9D17},
+{0x3086, 0x2345},
+{0x3086, 0x5822},
+{0x3086, 0x1708},
+{0x3086, 0x8E01},
+{0x3086, 0x2798},
+{0x3086, 0x8E00},
+{0x3086, 0x2644},
+{0x3086, 0x5C05},
+{0x3086, 0x1244},
+{0x3086, 0x4B8D},
+{0x3086, 0x602C},
+{0x3086, 0x2C2C},
+{0x3086, 0x2C00},
+/* End Sequencer */
+#ifdef AR0140_EMBEDDED_LINE
+{0x3064, 0x1982}, // SMIA_TEST
+#else
+{0x3064, 0x1802}, // SMIA_TEST
+#endif
+/* PCLK=27Mhz/0x2 *0x30 /1/0x10 - TI serializers */
+{0x302A, 0x0010}, // vt_pix_clk_div
+{0x302E, 0x0002}, // pre_pll_clk_div
+{0x3030, 0x0030}, // pll_multiplier
+#if 0
+/* Resolution: 1284x804x29.98p */
+{0x3002, 0x001A}, // y_addr_start 
+{0x3004, 0x0014}, // x_addr_start 
+{0x3006, 0x033D}, // y_addr_end}, 804 lines
+{0x3008, 0x0517}, // x_addr_end}, 1284px
+{0x300A, 0x0344}, // frame_length_lines}, 840 lines
+{0x300C, 0x0648}, // line_length_pck}, 1608px
+#else
+{0x31B0, 0x0056}, // FRAME_PREAMBLE
+{0x31B2, 0x0045}, // LINE_PREAMBLE
+{0x3004, AR0140_X_START}, // X_ADDR_START_
+{0x3008, AR0140_X_END}, // X_ADDR_END_
+{0x3002, AR0140_Y_START}, // Y_ADDR_START_
+{0x3006, AR0140_Y_END}, // Y_ADDR_END_
+{0x3402, 0x0000 | AR0140_MAX_WIDTH}, // X_OUTPUT_CONTROL
+{0x3404, 0x0000 | AR0140_MAX_HEIGHT}, // Y_OUTPUT_CONTROL
+{0x300A, AR0140_SENSOR_HEIGHT + 36}, // FRAME_LENGTH_LINES_
+{0x300C, AR0140_SENSOR_WIDTH + 328}, // LINE_LENGTH_PCK_
+#endif
+/* Rev3 Optimized Settings */
+{0x3044, 0x0400},
+{0x3052, 0xA134},
+{0x3092, 0x010F},
+{0x30FE, 0x0080},
+{0x3ECE, 0x40FF},
+{0x3ED0, 0xFF40},
+{0x3ED2, 0xA906},
+{0x3ED4, 0x001F},
+{0x3ED6, 0x638F},
+{0x3ED8, 0xCC99},
+{0x3EDA, 0x0888},
+{0x3EDE, 0x8878},
+{0x3EE0, 0x7744},
+{0x3EE2, 0x5563},
+{0x3EE4, 0xAAE0},
+{0x3EE6, 0x3400},
+{0x3EEA, 0xA4FF},
+{0x3EEC, 0x80F0},
+{0x3EEE, 0x0000},
+{0x31E0, 0x1701},
+/* HDR mode */
+/* 2D Motion Compensation */
+{0x318A, 0x0E74}, // hdr_mc_ctrl1
+{0x318C, 0xC000}, // hdr_mc_ctrl2
+{0x318E, 0x0800}, // hdr_mc_ctrl3: Gain before DLO set to 1
+{0x3190, 0x0000}, // hdr_mc_ctrl4: if DLO enabled overrides 2D MC
+{0x3192, 0x0400}, // hdr_mc_ctrl5
+{0x3194, 0x0BB8}, // hdr_mc_ctrl6: T1 barrier set to 3000
+{0x3196, 0x0E74}, // hdr_mc_ctrl7: T2 barrier set to 3700
+{0x3198, 0x183C}, // hdr_mc_ctrl8: Motion detect Q1 set to 60}, Q2 set to 24
+{0x3200, 0x0002}, // adacd_control
+{0x3202, 0x00A0}, // adacd_noise_model1
+{0x3206, 0x0A06}, // adacd_noise_floor1
+{0x3208, 0x1A12}, // adacd_noise_floor2
+{0x320A, 0x0080}, // adacd_pedestal
+{0x306E, 0x9010}, // datapath select - LV noncontinuous
+{0x31AC, 0x100C}, // DATA_FORMAT_BITS: RAW12
+{0x31AE, 0x0301}, // SERIAL_FORMAT
+{0x301A, 0x11D8}, // RESET_REGISTER
+// patch start
+{0x3012, 0x0206}, // COARSE_INTEGRATION_TIME_: T1 exposure - max=0x400
+// patch end
+// enable trigger
+{0x340A, 0x0070}, // GPIO_CONTROL1: GPIO3 is trigger
+{0x340C, 0x0080}, // GPIO_CONTROL2: GPIO3 is trigger
+{0x30CE, 0x0120}, // TRIGGER_MODE
+//{0x30DC, 0x0120}, // TRIGGER_DELAY
+};
diff --git a/drivers/media/i2c/soc_camera/ov106xx.c b/drivers/media/i2c/soc_camera/ov106xx.c
index 02384fb..c7bd92e 100644
--- a/drivers/media/i2c/soc_camera/ov106xx.c
+++ b/drivers/media/i2c/soc_camera/ov106xx.c
@@ -13,6 +13,7 @@
 #include "ov490_ov10640.c"
 #include "ov495_ov2775.c"
 #include "ar0132.c"
+#include "ar0140.c"
 #include "ar0143.c"
 #include "ar0220.c"
 #include "ar0231.c"
@@ -28,6 +29,7 @@
 	ID_OV490_OV10640,
 	ID_OV495_OV2775,
 	ID_AR0132,
+	ID_AR0140,
 	ID_AR0143,
 	ID_AR0220,
 	ID_AR0231,
@@ -69,6 +71,12 @@ static int ov106xx_probe(struct i2c_client *client,
 		goto out;
 	}
 
+	ret = ar0140_probe(client, did);
+	if (!ret) {
+		chip_id = ID_AR0140;
+		goto out;
+	}
+
 	ret = ar0143_probe(client, did);
 	if (!ret) {
 		chip_id = ID_AR0143;
@@ -144,6 +152,9 @@ static int ov106xx_remove(struct i2c_client *client)
 	case ID_AR0132:
 		ar0132_remove(client);
 		break;
+	case ID_AR0140:
+		ar0140_remove(client);
+		break;
 	case ID_AR0143:
 		ar0143_remove(client);
 		break;
@@ -200,6 +211,6 @@ static int ov106xx_remove(struct i2c_client *client)
 
 module_i2c_driver(ov106xx_i2c_driver);
 
-MODULE_DESCRIPTION("SoC Camera driver for OV10635, OV490+OV10640, OV495+OV2775, AR0132/143/220/223, AP0101+AR014X");
+MODULE_DESCRIPTION("SoC Camera driver for OV10635, OV490+OV10640, OV495+OV2775, AR0132/140/143/220/223, AP0101+AR014X");
 MODULE_AUTHOR("Vladimir Barinov");
 MODULE_LICENSE("GPL");
-- 
1.9.1

