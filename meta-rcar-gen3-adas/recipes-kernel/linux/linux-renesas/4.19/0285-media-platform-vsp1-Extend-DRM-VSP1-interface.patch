From 7142fa67551cffc7147e70498f98ea39fb93999b Mon Sep 17 00:00:00 2001
From: Valentine Barshak <valentine.barshak@cogentembedded.com>
Date: Tue, 13 Nov 2018 18:11:49 +0300
Subject: [PATCH 2/3] media: platform: vsp1: Extend DRM-VSP1 interface

- Extend DRM-VSP1 interface
- Add alpha-plane support for VSP1

This is based on the original "extend DRM-VSP1 interface" patch by
Konstantin Kozhevnikov <Konstantin.Kozhevnikov@cogentembedded.com>.

The only change is that "ckey", "ckey_set0", and "ckey_set1" properties
are used only when the conflicting "colorkey" property is disabled.

Signed-off-by: Valentine Barshak <valentine.barshak@cogentembedded.com>
---
 drivers/media/platform/vsp1/vsp1_bru.c  | 17 ++++++++++++++-
 drivers/media/platform/vsp1/vsp1_dl.c   |  5 +++++
 drivers/media/platform/vsp1/vsp1_drm.c  | 37 +++++++++++++++++++++++++++++++--
 drivers/media/platform/vsp1/vsp1_lif.c  |  2 +-
 drivers/media/platform/vsp1/vsp1_pipe.c |  4 ++++
 drivers/media/platform/vsp1/vsp1_rpf.c  | 26 ++++++++++++++++++++---
 drivers/media/platform/vsp1/vsp1_rwpf.c |  1 +
 drivers/media/platform/vsp1/vsp1_rwpf.h |  6 ++++++
 drivers/media/platform/vsp1/vsp1_wpf.c  |  4 ++++
 include/media/vsp1.h                    |  6 ++++++
 10 files changed, 101 insertions(+), 7 deletions(-)

diff --git a/drivers/media/platform/vsp1/vsp1_bru.c b/drivers/media/platform/vsp1/vsp1_bru.c
index 8d59e42..f72418a 100644
--- a/drivers/media/platform/vsp1/vsp1_bru.c
+++ b/drivers/media/platform/vsp1/vsp1_bru.c
@@ -396,6 +396,20 @@ static void bru_prepare(struct vsp1_entity *entity,
 			ctrl |= VI6_BRU_CTRL_SRCSEL_BRUIN(i);
 
 		vsp1_bru_write(bru, dlb, VI6_BRU_CTRL(i), ctrl);
+		dev_dbg(entity->vsp1->dev, "bru#%d: ctrl=%X\n", i, ctrl);
+
+		/* ...set blending formula as defined by the input RPF */
+		if (bru->inputs[i].rpf) {
+			if (bru->inputs[i].rpf->blend) {
+				vsp1_bru_write(bru, dlb, VI6_BRU_BLD(i),
+					       bru->inputs[i].rpf->blend);
+				dev_dbg(entity->vsp1->dev,
+					"bru#%d(#%d): setup blending formula: %X\n",
+					i, bru->inputs[i].rpf->entity.index,
+					bru->inputs[i].rpf->blend);
+				continue;
+			}
+		}
 
 		/*
 		 * Harcode the blending formula to
@@ -462,7 +476,8 @@ struct vsp1_bru *vsp1_bru_create(struct vsp1_device *vsp1,
 	v4l2_ctrl_new_std(&bru->ctrls, &bru_ctrl_ops, V4L2_CID_BG_COLOR,
 			  0, 0xffffff, 1, 0);
 
-	bru->bgcolor = 0;
+	/* ...for YUV, set black background */
+	bru->bgcolor = 0x00800080;
 
 	bru->entity.subdev.ctrl_handler = &bru->ctrls;
 
diff --git a/drivers/media/platform/vsp1/vsp1_dl.c b/drivers/media/platform/vsp1/vsp1_dl.c
index 5dd21c2..605a0dc 100644
--- a/drivers/media/platform/vsp1/vsp1_dl.c
+++ b/drivers/media/platform/vsp1/vsp1_dl.c
@@ -340,6 +340,7 @@ void vsp1_dl_set_addr_auto_fld(struct vsp1_dl_body *dlb,
 	u32 y_top_index, y_bot_index;
 	u32 u_top_index, u_bot_index;
 	u32 v_top_index, v_bot_index;
+	u32 alpha_index;
 	dma_addr_t y_top_addr, y_bot_addr;
 	dma_addr_t u_top_addr, u_bot_addr;
 	dma_addr_t v_top_addr, v_bot_addr;
@@ -355,6 +356,7 @@ void vsp1_dl_set_addr_auto_fld(struct vsp1_dl_body *dlb,
 	u_bot_index = rpf->entity.index * 8 + 3;
 	v_top_index = rpf->entity.index * 8 + 4;
 	v_bot_index = rpf->entity.index * 8 + 5;
+	alpha_index = rpf->entity.index * 8 + 6;
 
 	switch (rpf->fmtinfo->fourcc) {
 	case V4L2_PIX_FMT_YUV420M:
@@ -403,6 +405,9 @@ void vsp1_dl_set_addr_auto_fld(struct vsp1_dl_body *dlb,
 	dlb->src_dst_addr[u_bot_index].addr = u_bot_addr;
 	dlb->src_dst_addr[v_top_index].addr = v_top_addr;
 	dlb->src_dst_addr[v_bot_index].addr = v_bot_addr;
+
+	/* ...set alpha-plane address as needed */
+	dlb->src_dst_addr[alpha_index].addr = rpf->mem.alpha;
 }
 
 static struct vsp1_dl_list *vsp1_dl_list_alloc(struct vsp1_dl_manager *dlm,
diff --git a/drivers/media/platform/vsp1/vsp1_drm.c b/drivers/media/platform/vsp1/vsp1_drm.c
index f7dfc2e..0b2dd3f 100644
--- a/drivers/media/platform/vsp1/vsp1_drm.c
+++ b/drivers/media/platform/vsp1/vsp1_drm.c
@@ -11,6 +11,7 @@
  * (at your option) any later version.
  */
 
+//#define DEBUG
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
 #include <linux/slab.h>
@@ -199,7 +200,14 @@ int vsp1_du_setup_lif(struct device *dev, unsigned int pipe_index,
 
 		format.format.width = cfg->width;
 		format.format.height = cfg->height;
+#if 0
 		format.format.code = MEDIA_BUS_FMT_ARGB8888_1X32;
+#else
+		/* ...always blend in YUV colorspace;
+		 * apply conversion as needed
+		 */
+		format.format.code = MEDIA_BUS_FMT_AYUV8_1X32;
+#endif
 		format.format.field = V4L2_FIELD_NONE;
 
 		ret = v4l2_subdev_call(&pipe->bru->subdev, pad,
@@ -215,7 +223,12 @@ int vsp1_du_setup_lif(struct device *dev, unsigned int pipe_index,
 	format.pad = pipe->bru->source_pad;
 	format.format.width = cfg->width;
 	format.format.height = cfg->height;
+#if 0
 	format.format.code = MEDIA_BUS_FMT_ARGB8888_1X32;
+#else
+	/* ...always blend in YUV colorspace; apply conversion as needed */
+	format.format.code = MEDIA_BUS_FMT_AYUV8_1X32;
+#endif
 	format.format.field = V4L2_FIELD_NONE;
 
 	ret = v4l2_subdev_call(&pipe->bru->subdev, pad, set_fmt, NULL,
@@ -238,6 +251,13 @@ int vsp1_du_setup_lif(struct device *dev, unsigned int pipe_index,
 		format.format.code, pipe->output->entity.index);
 
 	format.pad = RWPF_PAD_SOURCE;
+	/* ...force conversion back to ARGB at the output */
+	format.format.code = MEDIA_BUS_FMT_ARGB8888_1X32;
+	ret = v4l2_subdev_call(&vsp1->wpf[0]->entity.subdev, pad, set_fmt, NULL,
+			       &format);
+	if (ret < 0)
+		return ret;
+
 	ret = v4l2_subdev_call(&pipe->output->entity.subdev, pad, get_fmt, NULL,
 			       &format);
 	if (ret < 0)
@@ -376,12 +396,14 @@ int vsp1_du_atomic_update(struct device *dev, unsigned int pipe_index,
 	}
 
 	dev_dbg(vsp1->dev,
-		"%s: RPF%u: (%u,%u)/%ux%u -> (%u,%u)/%ux%u (%08x), pitch %u dma { %pad, %pad, %pad } zpos %u\n",
+		"%s: RPF%u: (%u,%u)/%ux%u -> (%u,%u)/%ux%u (%08x), pitch %u "
+		"dma { %pad, %pad, %pad } zpos %u, alpha %pad, ckey %x/%x/%x\n",
 		__func__, rpf_index,
 		cfg->src.left, cfg->src.top, cfg->src.width, cfg->src.height,
 		cfg->dst.left, cfg->dst.top, cfg->dst.width, cfg->dst.height,
 		cfg->pixelformat, cfg->pitch, &cfg->mem[0], &cfg->mem[1],
-		&cfg->mem[2], cfg->zpos);
+		&cfg->mem[2], cfg->zpos, &cfg->alpha_mem, cfg->ckey,
+		cfg->ckey_set0, cfg->ckey_set1);
 
 	/*
 	 * Store the format, stride, memory buffer address, crop and compose
@@ -409,6 +431,11 @@ int vsp1_du_atomic_update(struct device *dev, unsigned int pipe_index,
 	rpf->colorkey_en = cfg->colorkey_en;
 	rpf->colorkey_alpha = cfg->colorkey_alpha;
 	rpf->interlaced = cfg->interlaced;
+	rpf->alpha_pitch = cfg->alpha_pitch;
+	rpf->ckey = cfg->ckey;
+	rpf->ckey_set0 = cfg->ckey_set0;
+	rpf->ckey_set1 = cfg->ckey_set1;
+	rpf->blend = cfg->blend;
 
 	if ((vsp1->ths_quirks & VSP1_AUTO_FLD_NOT_SUPPORT) &&
 	    rpf->interlaced) {
@@ -420,6 +447,7 @@ int vsp1_du_atomic_update(struct device *dev, unsigned int pipe_index,
 	rpf->mem.addr[0] = cfg->mem[0];
 	rpf->mem.addr[1] = cfg->mem[1];
 	rpf->mem.addr[2] = cfg->mem[2];
+	rpf->mem.alpha = cfg->alpha_mem;
 
 	vsp1->drm->inputs[rpf_index].crop = cfg->src;
 	vsp1->drm->inputs[rpf_index].compose = cfg->dst;
@@ -496,7 +524,12 @@ static int vsp1_du_setup_rpf_pipe(struct vsp1_device *vsp1,
 		__func__, format.format.width, format.format.height,
 		format.format.code, rpf->entity.index);
 
+#if 0
 	format.format.code = MEDIA_BUS_FMT_ARGB8888_1X32;
+#else
+	/* ...do blending in YUV color-space; apply conversion as needed */
+	format.format.code = MEDIA_BUS_FMT_AYUV8_1X32;
+#endif
 
 	ret = v4l2_subdev_call(&rpf->entity.subdev, pad, set_fmt, NULL,
 			       &format);
diff --git a/drivers/media/platform/vsp1/vsp1_lif.c b/drivers/media/platform/vsp1/vsp1_lif.c
index d495fae..5500cf8 100644
--- a/drivers/media/platform/vsp1/vsp1_lif.c
+++ b/drivers/media/platform/vsp1/vsp1_lif.c
@@ -163,7 +163,7 @@ static void lif_prepare(struct vsp1_entity *entity,
 
 	vsp1_lif_write(lif, dlb, VI6_LIF_CTRL,
 			(obth << VI6_LIF_CTRL_OBTH_SHIFT) |
-			(format->code == 0 ? VI6_LIF_CTRL_CFMT : 0) |
+			(format->code != MEDIA_BUS_FMT_ARGB8888_1X32 ? VI6_LIF_CTRL_CFMT : 0) |
 			VI6_LIF_CTRL_REQSEL | VI6_LIF_CTRL_LIF_EN);
 
 	/*
diff --git a/drivers/media/platform/vsp1/vsp1_pipe.c b/drivers/media/platform/vsp1/vsp1_pipe.c
index 71c91e9..d119bd0 100644
--- a/drivers/media/platform/vsp1/vsp1_pipe.c
+++ b/drivers/media/platform/vsp1/vsp1_pipe.c
@@ -144,6 +144,10 @@ static const struct vsp1_format_info vsp1_video_formats[] = {
 	  VI6_FMT_Y_U_V_444, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
 	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
 	  3, { 8, 8, 8 }, false, true, 1, 1, false },
+	{ V4L2_PIX_FMT_GREY, MEDIA_BUS_FMT_Y8_1X8,
+	  /*VI6_FMT_Y_U_V_444*/0xDEAD, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  1, { 8, 0, 0 }, false, false, 0, 0, false },
 };
 
 /**
diff --git a/drivers/media/platform/vsp1/vsp1_rpf.c b/drivers/media/platform/vsp1/vsp1_rpf.c
index 424dc2c..9d90f6b 100644
--- a/drivers/media/platform/vsp1/vsp1_rpf.c
+++ b/drivers/media/platform/vsp1/vsp1_rpf.c
@@ -11,6 +11,7 @@
  * (at your option) any later version.
  */
 
+//#define DEBUG
 #include <linux/device.h>
 
 #include <media/v4l2-subdev.h>
@@ -93,8 +94,10 @@ static void rpf_prepare(struct vsp1_entity *entity,
 	if (sink_format->code != source_format->code)
 		infmt |= VI6_RPF_INFMT_CSC;
 
+	dev_dbg(entity->vsp1->dev, "rpf#%d: infmt=%x (csc=%d)\n",
+		rpf->entity.index, infmt, !!(infmt & VI6_RPF_INFMT_CSC));
 	vsp1_rpf_write(rpf, dlb, VI6_RPF_INFMT, infmt);
-	vsp1_rpf_write(rpf, dlb, VI6_RPF_DSWAP, fmtinfo->swap);
+	vsp1_rpf_write(rpf, dlb, VI6_RPF_DSWAP, fmtinfo->swap | 0xF00);
 
 	/* Output location */
 	if (pipe->bru) {
@@ -117,6 +120,17 @@ static void rpf_prepare(struct vsp1_entity *entity,
 			       (left << VI6_RPF_LOC_HCOORD_SHIFT) |
 			       (top << VI6_RPF_LOC_VCOORD_SHIFT));
 
+	// ...setup alpha-plane as required
+	if (rpf->mem.alpha) {
+		vsp1_rpf_write(rpf, dlb, VI6_RPF_SRCM_ADDR_AI, rpf->mem.alpha);
+		vsp1_rpf_write(rpf, dlb, VI6_RPF_ALPH_SEL, VI6_RPF_ALPH_SEL_ASEL_8B_PLANE);
+		vsp1_rpf_write(rpf, dlb, VI6_RPF_SRCM_ASTRIDE, rpf->alpha_pitch);
+		dev_dbg(entity->vsp1->dev,
+			"rpf#%d: setup alpha-plane: buffer=%pad, stride=%u\n",
+			rpf->entity.index, &rpf->mem.alpha, rpf->alpha_pitch);
+		goto out;
+	}
+
 	/*
 	 * On Gen2 use the alpha channel (extended to 8 bits) when available or
 	 * a fixed alpha value set through the V4L2_CID_ALPHA_COMPONENT control
@@ -172,7 +186,9 @@ static void rpf_prepare(struct vsp1_entity *entity,
 	if (entity->vsp1->info->gen == 3) {
 		u32 mult;
 
-		if (fmtinfo->alpha &&
+		dev_dbg(entity->vsp1->dev, "rpf#%d: alpha=%x, fourcc=%x\n",
+			rpf->entity.index, fmtinfo->alpha, fmtinfo->fourcc);
+		if (0 && fmtinfo->alpha &&
 		    fmtinfo->fourcc != V4L2_PIX_FMT_ARGB555) {
 			/*
 			 * When the input contains an alpha channel enable the
@@ -203,6 +219,7 @@ static void rpf_prepare(struct vsp1_entity *entity,
 		rpf->mult_alpha = mult;
 	}
 
+out:
 	vsp1_rpf_write(rpf, dlb, VI6_RPF_MSK_CTRL, 0);
 
 	if (rpf->colorkey_en) {
@@ -211,7 +228,10 @@ static void rpf_prepare(struct vsp1_entity *entity,
 		vsp1_rpf_write(rpf, dlb, VI6_RPF_CKEY_CTRL,
 			       VI6_RPF_CKEY_CTRL_SAPE0);
 	} else {
-		vsp1_rpf_write(rpf, dlb, VI6_RPF_CKEY_CTRL, 0);
+		/* ...set up color keying */
+		vsp1_rpf_write(rpf, dlb, VI6_RPF_CKEY_CTRL, rpf->ckey);
+		vsp1_rpf_write(rpf, dlb, VI6_RPF_CKEY_SET0, rpf->ckey_set0);
+		vsp1_rpf_write(rpf, dlb, VI6_RPF_CKEY_SET1, rpf->ckey_set1);
 	}
 }
 
diff --git a/drivers/media/platform/vsp1/vsp1_rwpf.c b/drivers/media/platform/vsp1/vsp1_rwpf.c
index cfd8f19..9f4ad2b 100644
--- a/drivers/media/platform/vsp1/vsp1_rwpf.c
+++ b/drivers/media/platform/vsp1/vsp1_rwpf.c
@@ -11,6 +11,7 @@
  * (at your option) any later version.
  */
 
+//#define DEBUG
 #include <media/v4l2-subdev.h>
 
 #include "vsp1.h"
diff --git a/drivers/media/platform/vsp1/vsp1_rwpf.h b/drivers/media/platform/vsp1/vsp1_rwpf.h
index 6cecc86..f59abbfa 100644
--- a/drivers/media/platform/vsp1/vsp1_rwpf.h
+++ b/drivers/media/platform/vsp1/vsp1_rwpf.h
@@ -33,6 +33,7 @@ struct vsp1_video;
 
 struct vsp1_rwpf_memory {
 	dma_addr_t addr[3];
+	dma_addr_t alpha;
 };
 
 struct vsp1_rwpf {
@@ -77,6 +78,11 @@ struct vsp1_rwpf {
 
 	int write_back;
 	dma_addr_t buf_addr[3];
+	unsigned int alpha_pitch;
+	unsigned int ckey;
+	unsigned int ckey_set0;
+	unsigned int ckey_set1;
+	unsigned int blend;
 };
 
 static inline struct vsp1_rwpf *to_rwpf(struct v4l2_subdev *subdev)
diff --git a/drivers/media/platform/vsp1/vsp1_wpf.c b/drivers/media/platform/vsp1/vsp1_wpf.c
index b940cb6..0f33aa8 100644
--- a/drivers/media/platform/vsp1/vsp1_wpf.c
+++ b/drivers/media/platform/vsp1/vsp1_wpf.c
@@ -11,6 +11,7 @@
  * (at your option) any later version.
  */
 
+//#define DEBUG
 #include <linux/device.h>
 
 #include <media/v4l2-subdev.h>
@@ -352,6 +353,9 @@ static void wpf_configure(struct vsp1_entity *entity,
 	unsigned int offset;
 	u32 outfmt = 0;
 
+	dev_dbg(vsp1->dev, "wpf#%d: outfmt=%x (csc=%d)\n",
+		wpf->entity.index, outfmt, !!(outfmt & VI6_WPF_OUTFMT_CSC));
+
 	if (pipe->vmute_flag) {
 		vsp1_wpf_write(wpf, dlb, VI6_WPF_SRCRPF,
 			       VI6_WPF_SRCRPF_VIRACT_MST);
diff --git a/include/media/vsp1.h b/include/media/vsp1.h
index 772506b..f7551ef 100644
--- a/include/media/vsp1.h
+++ b/include/media/vsp1.h
@@ -53,6 +53,11 @@ struct vsp1_du_atomic_config {
 	u32 pixelformat;
 	unsigned int pitch;
 	dma_addr_t mem[3];
+	dma_addr_t alpha_mem;
+	unsigned int alpha_pitch;
+	unsigned int ckey;
+	unsigned int ckey_set0;
+	unsigned int ckey_set1;
 	struct v4l2_rect src;
 	struct v4l2_rect dst;
 	unsigned int alpha;
@@ -61,6 +66,7 @@ struct vsp1_du_atomic_config {
 	u32 colorkey_alpha;
 	bool colorkey_en;
 	bool interlaced;
+	unsigned int blend;
 };
 
 void vsp1_du_atomic_begin(struct device *dev, unsigned int pipe_index);
-- 
2.7.4

