From f56b70cc5014afe5fe15f8cc4f6d34a47137206b Mon Sep 17 00:00:00 2001
From: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
Date: Mon, 21 Sep 2020 23:21:16 +0300
Subject: [PATCH] media: i2c: add camera lvds support

This adds GMSL1 and FPDLink3 video support

Signed-off-by: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
---
 drivers/media/i2c/Kconfig                 |    4 +
 drivers/media/i2c/Makefile                |    4 +
 drivers/media/i2c/fpdlink/Kconfig         |   15 +
 drivers/media/i2c/fpdlink/Makefile        |    2 +
 drivers/media/i2c/fpdlink/ub9x4.c         |  931 +++++++++++++++++++++++
 drivers/media/i2c/fpdlink/ub9x4.h         |   19 +
 drivers/media/i2c/gmsl/Kconfig            |   14 +
 drivers/media/i2c/gmsl/Makefile           |    2 +
 drivers/media/i2c/gmsl/common.h           |  508 +++++++++++++
 drivers/media/i2c/gmsl/max9286.c          | 1123 ++++++++++++++++++++++++++++
 drivers/media/i2c/gmsl/max9286_debug.h    |   89 +++
 drivers/media/i2c/gmsl/max9295.h          |   39 +
 drivers/media/i2c/imagers/Kconfig         |   13 +
 drivers/media/i2c/imagers/Makefile        |    7 +
 drivers/media/i2c/imagers/ov10635.c       |  702 ++++++++++++++++++
 drivers/media/i2c/imagers/ov10635.h       | 1143 +++++++++++++++++++++++++++++
 drivers/media/i2c/imagers/ov10635_debug.h |   54 ++
 drivers/media/i2c/imagers/ov490.c         | 1075 +++++++++++++++++++++++++++
 drivers/media/i2c/imagers/ov490.h         |  101 +++
 19 files changed, 5845 insertions(+)
 create mode 100644 drivers/media/i2c/fpdlink/Kconfig
 create mode 100644 drivers/media/i2c/fpdlink/Makefile
 create mode 100644 drivers/media/i2c/fpdlink/ub9x4.c
 create mode 100644 drivers/media/i2c/fpdlink/ub9x4.h
 create mode 100644 drivers/media/i2c/gmsl/Kconfig
 create mode 100644 drivers/media/i2c/gmsl/Makefile
 create mode 100644 drivers/media/i2c/gmsl/common.h
 create mode 100644 drivers/media/i2c/gmsl/max9286.c
 create mode 100644 drivers/media/i2c/gmsl/max9286_debug.h
 create mode 100644 drivers/media/i2c/gmsl/max9295.h
 create mode 100644 drivers/media/i2c/imagers/Kconfig
 create mode 100644 drivers/media/i2c/imagers/Makefile
 create mode 100644 drivers/media/i2c/imagers/ov10635.c
 create mode 100644 drivers/media/i2c/imagers/ov10635.h
 create mode 100644 drivers/media/i2c/imagers/ov10635_debug.h
 create mode 100644 drivers/media/i2c/imagers/ov490.c
 create mode 100644 drivers/media/i2c/imagers/ov490.h

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 6e5ee08..ed4f74b 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -1179,4 +1179,8 @@ config VIDEO_ST_MIPID02
 
 endmenu
 
+source "drivers/media/i2c/gmsl/Kconfig"
+source "drivers/media/i2c/fpdlink/Kconfig"
+source "drivers/media/i2c/imagers/Kconfig"
+
 endif
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index eb04dba..41d4ca6 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -7,6 +7,10 @@ obj-$(CONFIG_VIDEO_ET8EK8)	+= et8ek8/
 obj-$(CONFIG_VIDEO_CX25840) += cx25840/
 obj-$(CONFIG_VIDEO_M5MOLS)	+= m5mols/
 
+obj-y				+= imagers/
+obj-y				+= gmsl/
+obj-y				+= fpdlink/
+
 obj-$(CONFIG_VIDEO_APTINA_PLL) += aptina-pll.o
 obj-$(CONFIG_VIDEO_TVAUDIO) += tvaudio.o
 obj-$(CONFIG_VIDEO_TDA7432) += tda7432.o
diff --git a/drivers/media/i2c/fpdlink/Kconfig b/drivers/media/i2c/fpdlink/Kconfig
new file mode 100644
index 0000000..2687507
--- /dev/null
+++ b/drivers/media/i2c/fpdlink/Kconfig
@@ -0,0 +1,15 @@
+#
+# GMSL video device configuration
+#
+
+config VIDEO_UB9X4
+	tristate "TI DS90UB960 FPDLink3 deserializer support"
+	depends on I2C && I2C_MUX
+	depends on VIDEO_V4L2_SUBDEV_API && MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a Texas Instruments DS90UB960/UB954/UB964 FPDLink3
+	  deserializer driver
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ub9x4.
diff --git a/drivers/media/i2c/fpdlink/Makefile b/drivers/media/i2c/fpdlink/Makefile
new file mode 100644
index 0000000..3a694ed
--- /dev/null
+++ b/drivers/media/i2c/fpdlink/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_VIDEO_UB9X4)	+= ub9x4.o
diff --git a/drivers/media/i2c/fpdlink/ub9x4.c b/drivers/media/i2c/fpdlink/ub9x4.c
new file mode 100644
index 0000000..3ce38d2
--- /dev/null
+++ b/drivers/media/i2c/fpdlink/ub9x4.c
@@ -0,0 +1,931 @@
+/*
+ * TI DS90UB954/960/964 FPDLinkIII driver
+ *
+ * Copyright (C) 2017-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/reboot.h>
+#include <linux/regulator/consumer.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-clk.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "ub9x4.h"
+#include "../gmsl/common.h"
+
+#define UB9X4_N_LINKS		4
+
+enum ub9x4_pads {
+	UB9X4_SINK_LINK0,
+	UB9X4_SINK_LINK1,
+	UB9X4_SINK_LINK2,
+	UB9X4_SINK_LINK3,
+	UB9X4_SOURCE,
+	UB9X4_N_PADS,
+};
+
+struct ub9x4_sink {
+	struct v4l2_async_subdev asd;
+	struct v4l2_subdev	*sd;
+	struct fwnode_handle	*fwnode;
+};
+
+#define asd_to_ub9x4_sink(_asd) \
+	container_of(_asd, struct ub9x4_sink, asd)
+
+struct ub9x4_priv {
+	struct i2c_client*client;
+	struct v4l2_subdev	sd;
+	struct media_pad	pads[UB9X4_N_PADS];
+
+	struct i2c_mux_core	*mux;
+	unsigned int		mux_channel;
+
+	unsigned int		nsinks;
+	struct ub9x4_sink	sinks[UB9X4_N_LINKS];
+	struct v4l2_async_subdev *subdevs[UB9X4_N_LINKS];
+	struct v4l2_async_notifier notifier;
+	struct v4l2_ctrl_handler ctrls;
+
+	int			des_addr;
+	int			n_links;
+	int			links_mask;
+	int			lanes;
+	int			csi_rate;
+	const char		*forwarding_mode;
+	int			fs_time;
+	int			fps_numerator;
+	int			fps_denominator;
+	int			is_coax;
+	int			dvp_bus;
+	int			dvp_lsb;
+	int			hsync;
+	int			vsync;
+	int			poc_delay;
+	atomic_t		use_count;
+	int			ser_addr[4];
+	char			chip_id[6];
+	int			ser_id;
+	int			vc_map;
+	int			csi_map;
+	int			gpio[4];
+	struct gpio_desc	*pwen; /* chip power en */
+	struct regulator	*poc_reg[4]; /* PoC power supply */
+	struct v4l2_clk		*ref_clk; /* ref clock */
+	struct notifier_block	reboot_notifier;
+};
+
+static int ser_id;
+module_param(ser_id, int, 0644);
+MODULE_PARM_DESC(ser_id, "  Serializer ID (default: UB913)");
+
+static int is_stp;
+module_param(is_stp, int, 0644);
+MODULE_PARM_DESC(is_stp, "  STP cable (default: Coax cable)");
+
+static int dvp_bus = 8;
+module_param(dvp_bus, int, 0644);
+MODULE_PARM_DESC(dvp_bus, "  DVP/CSI over FPDLink (default: DVP 8-bit)");
+
+static int dvp_lsb = 0;
+module_param(dvp_lsb, int, 0644);
+MODULE_PARM_DESC(dvp_lsb, "  DVP 8-bit LSB/MSB selection (default: DVP 8-bit MSB)");
+
+static int hsync;
+module_param(hsync, int, 0644);
+MODULE_PARM_DESC(hsync, " HSYNC invertion (default: 0 - not inverted)");
+
+static int vsync = 1;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 1 - inverted)");
+
+static int poc_delay;
+module_param(poc_delay, int, 0644);
+MODULE_PARM_DESC(poc_delay, " Delay in ms after POC enable (default: 0 ms)");
+
+static int vc_map = 0x3210;
+module_param(vc_map, int, 0644);
+MODULE_PARM_DESC(vc_map, " CSI VC MAP (default: 0xe4 - linear map VCx=LINKx)");
+
+static int csi_map = 0;
+module_param(csi_map, int, 0644);
+MODULE_PARM_DESC(csi_map, " CSI TX MAP (default: 0 - forwarding of all links to CSI0)");
+
+static int gpio0 = 0, gpio1 = 0, gpio2 = 0, gpio3 = 0;
+module_param(gpio0, int, 0644);
+MODULE_PARM_DESC(gpio0, "  GPIO0 function select (default: GPIO0 low level)");
+module_param(gpio1, int, 0644);
+MODULE_PARM_DESC(gpio1, "  GPIO1 function select (default: GPIO1 low level)");
+module_param(gpio2, int, 0644);
+MODULE_PARM_DESC(gpio2, "  GPIO2 function select (default: GPIO2 low level)");
+module_param(gpio3, int, 0644);
+MODULE_PARM_DESC(gpio3, "  GPIO3 function select (default: GPIO3 low level)");
+
+static void ub9x4_read_chipid(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+
+	/* Chip ID */
+	reg8_read(client, 0xf1, &priv->chip_id[0]);
+	reg8_read(client, 0xf2, &priv->chip_id[1]);
+	reg8_read(client, 0xf3, &priv->chip_id[2]);
+	reg8_read(client, 0xf4, &priv->chip_id[3]);
+	reg8_read(client, 0xf5, &priv->chip_id[4]);
+	priv->chip_id[5] = '\0';
+}
+
+static void ub9x4_initial_setup(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+
+	/* Initial setup */
+	client->addr = priv->des_addr;				/* ub9x4 I2C */
+	reg8_write(client, 0x0d, 0xb9);				/* VDDIO 3.3V */
+	switch (priv->csi_rate) {
+	case 1600: /* REFCLK = 25MHZ */
+	case 1500: /* REFCLK = 23MHZ */
+	case 1450: /* REFCLK = 22.5MHZ */
+		reg8_write(client, 0x1f, 0x00);			/* CSI rate 1.5/1.6Gbps */
+		break;
+	case 1200: /* REFCLK = 25MHZ */
+	case 1100: /* REFCLK = 22.5MHZ */
+		reg8_write(client, 0x1f, 0x01);			/* CSI rate 1.1/1.2Gbps */
+		break;
+	case 800: /* REFCLK = 25MHZ */
+	case 700: /* REFCLK = 22.5MHZ */
+		reg8_write(client, 0x1f, 0x02);			/* CSI rate 700/800Mbps */
+		break;
+	case 400: /* REFCLK = 25MHZ */
+	case 350: /* REFCLK = 22.5MHZ */
+		reg8_write(client, 0x1f, 0x03);			/* CSI rate 350/400Mbps */
+		break;
+	default:
+		dev_err(&client->dev, "unsupported CSI rate %d\n", priv->csi_rate);
+	}
+
+	switch (priv->csi_rate) {
+	case 1600:
+	case 1200:
+	case 800:
+	case 400:
+		/* FrameSync setup for REFCLK=25MHz,   FPS=30: period_counts=1/FPS/12mks=1/30/12e-6=2777 -> HI=2, LO=2775 */
+		priv->fs_time = 2790;
+		break;
+	case 1500:
+		/* FrameSync setup for REFCLK=23MHz, FPS=30: period_counts=1/FPS/13.043mks=1/30/13.043e-6=2556 -> HI=2, LO=2554 */
+		priv->fs_time = 2570;
+		break;
+	case 1450:
+	case 1100:
+	case 700:
+	case 350:
+		/* FrameSync setup for REFCLK=22.5MHz, FPS=30: period_counts=1/FPS/13.333mks=1/30/13.333e-6=2500 -> HI=2, LO=2498 */
+		priv->fs_time = 2513;
+		break;
+	default:
+		priv->fs_time = 0;
+		dev_err(&client->dev, "unsupported CSI rate %d\n", priv->csi_rate);
+	}
+
+	if (strcmp(priv->forwarding_mode, "round-robin") == 0) {
+		reg8_write(client, 0x21, 0x03);			/* Round Robin forwarding enable for CSI0/CSI1 */
+	} else if (strcmp(priv->forwarding_mode, "synchronized") == 0) {
+		reg8_write(client, 0x21, 0x54);			/* Basic Syncronized forwarding enable (FrameSync must be enabled!!) for CSI0/CSI1 */
+	}
+
+	reg8_write(client, 0x32, 0x03);				/* Select TX for CSI0/CSI1, RX for CSI0 */
+	reg8_write(client, 0x33, ((priv->lanes - 1) ^ 0x3) << 4); /* disable CSI output, set CSI lane count, non-continuous CSI mode */
+	reg8_write(client, 0x20, 0xf0 | priv->csi_map);		/* disable port forwarding */
+#if 0
+	/* FrameSync setup for REFCLK=25MHz,   FPS=30: period_counts=1/2/FPS*25MHz  =1/2/30*25Mhz  =416666 -> FS_TIME=416666 */
+	/* FrameSync setup for REFCLK=22.5MHz, FPS=30: period_counts=1/2/FPS*22.5Mhz=1/2/30*22.5Mhz=375000 -> FS_TIME=375000 */
+// #define FS_TIME (priv->csi_rate == 1450 ? 376000 : 417666)
+ #define FS_TIME (priv->csi_rate == 1450 ? 385000 : 428000) // FPS=29.2 (new vendor's firmware AWB restriction?)
+	reg8_write(client, 0x1a, FS_TIME >> 16);		/* FrameSync time 24bit */
+	reg8_write(client, 0x1b, (FS_TIME >> 8) & 0xff);
+	reg8_write(client, 0x1c, FS_TIME & 0xff);
+	reg8_write(client, 0x18, 0x43);				/* Enable FrameSync, 50/50 mode, Frame clock from 25MHz */
+#else
+	reg8_write(client, 0x19, 2 >> 8);			/* FrameSync high time MSB */
+	reg8_write(client, 0x1a, 2 & 0xff);			/* FrameSync high time LSB */
+	reg8_write(client, 0x1b, priv->fs_time >> 8);		/* FrameSync low time MSB */
+	reg8_write(client, 0x1c, priv->fs_time & 0xff);		/* FrameSync low time LSB */
+	reg8_write(client, 0x18, 0x00);				/* Disable FrameSync - must be enabled after all cameras are set up */
+#endif
+}
+
+static void ub9x4_fpdlink3_setup(struct i2c_client *client, int idx)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+	u8 port_config = 0x78;
+	u8 port_config2 = 0;
+
+	/* FPDLinkIII setup */
+	client->addr = priv->des_addr;				/* ub9x4 I2C */
+	reg8_write(client, 0x4c, (idx << 4) | (1 << idx));	/* Select RX port number */
+	usleep_range(2000, 2500);
+
+	switch (priv->ser_id) {
+	case UB913_ID:
+		reg8_write(client, 0x58, 0x58);			/* Back channel: Freq=2.5Mbps */
+		break;
+	case UB953_ID:
+		reg8_write(client, 0x58, 0x5e);			/* Back channel: Freq=50Mbps */
+		break;
+	default:
+		break;
+	}
+
+	reg8_write(client, 0x5c, priv->ser_addr[idx] << 1);	/* UB9X3 I2C addr */
+//	reg8_write(client, 0x5d, 0x30 << 1);			/* SENSOR I2C native - must be set by sensor driver */
+//	reg8_write(client, 0x65, (0x60 + idx) << 1);		/* SENSOR I2C translated - must be set by sensor driver */
+
+	if (priv->is_coax)
+		port_config |= 0x04;				/* Coax */
+	else
+		port_config |= 0x00;				/* STP */
+
+	switch (priv->dvp_bus) {
+	case 8:
+		port_config2 |= (priv->dvp_lsb ? 0xC0 : 0x80);	/* RAW10 as 8-bit prosessing using LSB/MSB bits  */
+		/* fall through */
+	case 10:
+		port_config |= 0x03;				/* DVP over FPDLink (UB913 compatible) RAW10/RAW8 */
+		break;
+	case 12:
+		port_config |= 0x02;				/* DVP over FPDLink (UB913 compatible) RAW12 */
+		break;
+	default:
+		port_config |= 0x00;				/* CSI over FPDLink (UB953 compatible) */
+	}
+
+	if (priv->vsync)
+		port_config2 |= 0x01;				/* VSYNC acive low */
+	if (priv->hsync)
+		port_config2 |= 0x02;				/* HSYNC acive low */
+
+	reg8_write(client, 0x6d, port_config);
+	reg8_write(client, 0x7c, port_config2);
+	reg8_write(client, 0x70, ((priv->vc_map >> (idx * 4)) << 6) | 0x1e); /* CSI data type: yuv422 8-bit, assign VC */
+	reg8_write(client, 0x71, ((priv->vc_map >> (idx * 4)) << 6) | 0x2c); /* CSI data type: RAW12, assign VC */
+	reg8_write(client, 0xbc, 0x00);				/* Setup minimal time between FV and LV to 3 PCLKs */
+	reg8_write(client, 0x72, priv->vc_map >> (idx * 4));	/* CSI VC MAP */
+}
+
+static int ub9x4_initialize(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+	int i, ret, timeout;
+	u8 port_sts1[4] = {0, 0, 0, 0}, port_sts2[4] = {0, 0, 0, 0};
+
+	dev_info(&client->dev, "LINKs=%d, LANES=%d, FORWARDING=%s, CABLE=%s, ID=%s\n",
+			       priv->n_links, priv->lanes, priv->forwarding_mode, priv->is_coax ? "coax" : "stp", priv->chip_id);
+
+	ub9x4_initial_setup(client);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i])) {
+			ret = regulator_enable(priv->poc_reg[i]); /* POC power on */
+			if (ret) {
+				dev_err(&client->dev, "failed to enable poc regulator\n");
+				continue;
+			}
+			mdelay(priv->poc_delay);
+		}
+
+		ub9x4_fpdlink3_setup(client, i);
+	}
+
+	client->addr = priv->des_addr;
+
+	/* check lock status */
+	for (timeout = 500 / priv->n_links; timeout > 0; timeout--) {
+		for (i = 0; i < priv->n_links; i++) {
+			if ((port_sts1[i] & 0x1) && (port_sts2[i] & 0x4))
+				continue;
+
+			reg8_write(client, 0x4c, (i << 4) | (1 << i));	/* Select RX port number */
+			usleep_range(1000, 1500);
+			reg8_read(client, 0x4d, &port_sts1[i]);		/* Lock status */
+			reg8_read(client, 0x4e, &port_sts2[i]);		/* Freq stable */
+		}
+	}
+
+	if (!timeout)
+		dev_info(&client->dev, "Receiver lock status [%d,%d,%d,%d]\n",
+				       (port_sts1[0] & 0x1) && (port_sts2[0] & 0x4),
+				       (port_sts1[1] & 0x1) && (port_sts2[1] & 0x4),
+				       (port_sts1[2] & 0x1) && (port_sts2[2] & 0x4),
+				       (port_sts1[3] & 0x1) && (port_sts2[3] & 0x4));
+
+	if (priv->poc_delay)
+		mdelay(100);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!((port_sts1[i] & 0x1) && (port_sts2[i] & 0x4)))
+			continue;
+
+		reg8_write(client, 0x4c, (i << 4) | (1 << i));			/* Select RX port number */
+		usleep_range(1000, 1500);
+
+		/*
+		 * Enable only FSIN for remote gpio, all permanent states (0 or 1) setup on serializer side:
+		 * this avoids intermittent remote gpio noise (f.e. reset or spuriouse fsin) caused by
+		 * unstable/bad link, hence unstable backchannel
+		 */
+		client->addr = priv->ser_addr[i];				/* UB9X3 I2C addr */
+		switch (priv->ser_id) {
+		case UB913_ID:
+			reg8_write(client, 0x0d, 0x55);				/* Enable remote GPIO0/1 */
+			reg8_write(client, 0x11, 0x10);				/* I2C high pulse width */
+			reg8_write(client, 0x12, 0x10);				/* I2C low pulse width */
+			break;
+		case UB953_ID:
+			reg8_write(client, 0x0d, (priv->gpio[0] & 0x1) << 0 |
+						 (priv->gpio[1] & 0x1) << 1 |
+						 (priv->gpio[2] & 0x1) << 2 |
+						 (priv->gpio[3] & 0x1) << 3 |
+						 (priv->gpio[0] & 0x2) << 3 |
+						 (priv->gpio[1] & 0x2) << 4 |
+						 (priv->gpio[2] & 0x2) << 5 |
+						 (priv->gpio[3] & 0x2) << 6);	/* Enable FSIN remote GPIOs and set local constant gpios */
+			reg8_write(client, 0x0e, (!!priv->gpio[0] << 4) |
+						 (!!priv->gpio[1] << 5) |
+						 (!!priv->gpio[2] << 6) |
+						 (!!priv->gpio[3] << 7));	/* Enable serializer GPIOs only for output */
+			reg8_write(client, 0x0b, 0x10);				/* I2C high pulse width */
+			reg8_write(client, 0x0c, 0x10);				/* I2C low pulse width */
+			break;
+		}
+		client->addr = priv->des_addr;
+
+		reg8_write(client, 0x6e, 0x88 | (priv->gpio[1] << 4) | priv->gpio[0]); /* Remote GPIO1/GPIO0 setup */
+		reg8_write(client, 0x6f, 0x88 | (priv->gpio[3] << 4) | priv->gpio[2]); /* Remote GPIO3/GPIO2 setup */
+
+		priv->links_mask |= BIT(i);
+		i2c_mux_add_adapter(priv->mux, 0, i, 0);
+	}
+
+	return 0;
+}
+
+static int ub9x4_post_initialize(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+
+	reg8_write(client, 0x33, ((priv->lanes - 1) ^ 0x3) << 4 | 0x1); /* enable CSI output, set CSI lane count, non-continuous CSI mode */
+	reg8_write(client, 0x18, 0x01);					/* Enable FrameSync, HI/LO mode, Frame clock from port0 */
+//	reg8_write(client, 0x18, 0x80);					/* Enable FrameSync, Frame clock is external */
+
+	return 0;
+}
+
+static int ub9x4_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+
+	if (enable) {
+		if (atomic_inc_return(&priv->use_count) == 1)
+			reg8_write(client, 0x20, 0x00 | priv->csi_map); /* enable port forwarding to CSI */
+	} else {
+		if (atomic_dec_return(&priv->use_count) == 0)
+			reg8_write(client, 0x20, 0xf0 | priv->csi_map); /* disable port forwarding to CSI */
+	}
+
+	return 0;
+}
+
+static int ub9x4_g_frame_interval(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_frame_interval *ival)
+{
+	return 0;
+}
+
+static int ub9x4_s_frame_interval(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_frame_interval *ival)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+	struct v4l2_fract *tpf = &ival->interval;
+
+	if (priv->fps_denominator != tpf->denominator ||
+	    priv->fps_numerator != tpf->numerator) {
+		int f_time;
+
+		f_time = priv->fs_time * 30 * tpf->numerator / tpf->denominator;
+		reg8_write(client, 0x1b, f_time >> 8);			/* FrameSync low time MSB */
+		reg8_write(client, 0x1c, f_time & 0xff);		/* FrameSync low time LSB */
+
+		priv->fps_denominator = tpf->denominator;
+		priv->fps_numerator = tpf->numerator;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ub9x4_video_ops = {
+	.s_stream = ub9x4_s_stream,
+	.g_frame_interval = ub9x4_g_frame_interval,
+	.s_frame_interval = ub9x4_s_frame_interval,
+};
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ub9x4_g_register(struct v4l2_subdev *sd,
+				      struct v4l2_dbg_register *reg)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+	int ret;
+	u8 val = 0;
+
+	ret = reg8_read(client, (u8)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u8);
+
+	return 0;
+}
+
+static int ub9x4_s_register(struct v4l2_subdev *sd,
+				      const struct v4l2_dbg_register *reg)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+
+	return reg8_write(client, (u8)reg->reg, (u8)reg->val);
+}
+#endif
+
+static int ub9x4_reboot_notifier(struct notifier_block *nb, unsigned long event, void *buf)
+{
+	struct ub9x4_priv *priv = container_of(nb, struct ub9x4_priv, reboot_notifier);
+	int i;
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i]))
+			regulator_disable(priv->poc_reg[i]); /* POC power off */
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct v4l2_subdev_core_ops ub9x4_subdev_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ub9x4_g_register,
+	.s_register = ub9x4_s_register,
+#endif
+};
+
+static struct v4l2_subdev_ops ub9x4_subdev_ops = {
+	.core = &ub9x4_subdev_core_ops,
+	.video = &ub9x4_video_ops,
+};
+
+/* -----------------------------------------------------------------------------
+ * I2C Multiplexer
+ */
+
+static int ub9x4_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	/* Do nothing! */
+	return 0;
+}
+
+static int ub9x4_i2c_mux_init(struct ub9x4_priv *priv)
+{
+	struct i2c_client *client = priv->client;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	priv->mux = i2c_mux_alloc(client->adapter, &client->dev,
+				  priv->nsinks, 0, I2C_MUX_LOCKED,
+				  ub9x4_i2c_mux_select, NULL);
+	if (!priv->mux)
+		return -ENOMEM;
+
+	priv->mux->priv = priv;
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * Async handling and registration of subdevices and links.
+ */
+
+static int ub9x4_notify_bound(struct v4l2_async_notifier *notifier,
+			      struct v4l2_subdev *subdev,
+			      struct v4l2_async_subdev *asd)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct ub9x4_sink *sink = asd_to_ub9x4_sink(asd);
+	int sink_pad = sink - &priv->sinks[0];
+	int src_pad;
+
+	src_pad = media_entity_get_fwnode_pad(&subdev->entity, sink->fwnode, MEDIA_PAD_FL_SOURCE);
+	if (src_pad < 0) {
+		dev_err(&priv->client->dev, "Failed to find pad for %s\n", subdev->name);
+		return src_pad;
+	}
+
+	sink->sd = subdev;
+
+	dev_dbg(&priv->client->dev, "Bound %s:%u -> %s:%u\n",
+		subdev->name, src_pad, priv->sd.name, sink_pad);
+
+	return media_create_pad_link(&subdev->entity, src_pad,
+				     &priv->sd.entity, sink_pad,
+				     MEDIA_LNK_FL_ENABLED |
+				     MEDIA_LNK_FL_IMMUTABLE);
+}
+
+static void ub9x4_notify_unbind(struct v4l2_async_notifier *notifier,
+				struct v4l2_subdev *subdev,
+				struct v4l2_async_subdev *asd)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct ub9x4_sink *sink = asd_to_ub9x4_sink(asd);
+
+	sink->sd = NULL;
+
+	dev_dbg(&priv->client->dev, "Unbind %s\n", subdev->name);
+}
+
+static const struct v4l2_async_notifier_operations ub9x4_notify_ops = {
+	.bound = ub9x4_notify_bound,
+	.unbind = ub9x4_notify_unbind,
+};
+
+static int ub9x4_v4l2_init(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+	struct device_node *ep;
+	unsigned int i;
+	int err;
+	int pixel_rate;
+
+	v4l2_async_notifier_init(&priv->notifier);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!(priv->links_mask & (1 << i)))
+			continue;
+		err = v4l2_async_notifier_add_subdev(&priv->notifier, priv->subdevs[i]);
+		if (err < 0)
+			return err;
+	}
+
+	priv->notifier.ops = &ub9x4_notify_ops;
+	err = v4l2_async_subdev_notifier_register(&priv->sd, &priv->notifier);
+	if (err < 0)
+		return err;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ub9x4_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Only YUV422 bpp=16 supported atm, decode to pixel_rate from fixed csi_rate */
+	pixel_rate = priv->csi_rate / priv->lanes * 1000000;
+	v4l2_ctrl_handler_init(&priv->ctrls, 1);
+	v4l2_ctrl_new_std(&priv->ctrls, NULL, V4L2_CID_PIXEL_RATE,
+			  pixel_rate, pixel_rate, 1, pixel_rate);
+	priv->sd.ctrl_handler = &priv->ctrls;
+	err = priv->ctrls.error;
+	if (err)
+		return err;
+
+	/* Pads init */
+	priv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	priv->pads[UB9X4_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	priv->pads[UB9X4_SINK_LINK0].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[UB9X4_SINK_LINK1].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[UB9X4_SINK_LINK2].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[UB9X4_SINK_LINK3].flags = MEDIA_PAD_FL_SINK;
+	err = media_entity_pads_init(&priv->sd.entity, UB9X4_N_PADS, priv->pads);
+	if (err)
+		return err;
+
+	/* Subdevice register */
+	ep = of_graph_get_endpoint_by_regs(client->dev.of_node, UB9X4_SOURCE, -1);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to retrieve endpoint on \"port@4\"\n");
+		return -ENOENT;
+	}
+	priv->sd.fwnode = of_fwnode_handle(ep);
+	v4l2_set_subdevdata(&priv->sd, priv);
+
+	of_node_put(ep);
+
+	err = v4l2_async_register_subdev(&priv->sd);
+	if (err < 0) {
+		dev_err(&client->dev, "Unable to register subdevice\n");
+		goto err_put_node;
+	}
+
+	return 0;
+
+err_put_node:
+	of_node_put(ep);
+	return err;
+}
+
+static int ub9x4_parse_dt(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+	struct device_node *np = client->dev.of_node;
+	struct device_node *endpoint = NULL;
+	int err, i;
+	int sensor_delay;
+	char forwarding_mode_default[20] = "round-robin"; /* round-robin, synchronized */
+	struct property *prop;
+	u8 val = 0;
+	u32 addrs[4], naddrs;
+
+	i = of_property_match_string(np, "reg-names", "ub9x4");
+	if (i >= 0)
+		of_property_read_u32_index(np, "reg", i, (unsigned int *)&client->addr);
+	priv->des_addr = client->addr;
+
+	naddrs = of_property_count_elems_of_size(np, "regs", sizeof(u32));
+	err = of_property_read_u32_array(client->dev.of_node, "regs", addrs,
+					 naddrs);
+	if (err < 0) {
+		dev_err(&client->dev, "Invalid DT regs property\n");
+		return -EINVAL;
+	}
+	priv->n_links = naddrs;
+	memcpy(priv->ser_addr, addrs, naddrs * sizeof(u32));
+
+	priv->ref_clk = v4l2_clk_get(&client->dev, "ref_clk");
+	if (!IS_ERR(priv->ref_clk)) {
+		dev_info(&client->dev, "ref_clk = %luKHz", v4l2_clk_get_rate(priv->ref_clk) / 1000);
+		v4l2_clk_enable(priv->ref_clk);
+	}
+
+	priv->pwen = devm_gpiod_get(&client->dev, NULL, GPIOD_OUT_HIGH);
+	if (!IS_ERR(priv->pwen)) {
+		mdelay(5);
+		gpiod_direction_output(priv->pwen, 0);
+		mdelay(5);
+	}
+
+	for (i = 0; i < priv->n_links; i++) {
+		char poc_name[10];
+
+		sprintf(poc_name, "poc%d", i);
+		priv->poc_reg[i] = devm_regulator_get(&client->dev, poc_name);
+		if (PTR_ERR(priv->poc_reg[i]) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+	}
+
+	reg8_read(client, 0x00, &val); /* read ub9x4 ID: self i2c address */
+	if (val != (priv->des_addr << 1))
+		return -ENODEV;
+
+	ub9x4_read_chipid(client);
+
+	if (!of_property_read_u32(np, "ti,sensor_delay", &sensor_delay))
+		mdelay(sensor_delay);
+	if (of_property_read_string(np, "ti,forwarding-mode", &priv->forwarding_mode))
+		priv->forwarding_mode = forwarding_mode_default;
+	if (of_property_read_bool(np, "ti,stp"))
+		priv->is_coax = 0;
+	else
+		priv->is_coax = 1;
+	if (of_property_read_u32(np, "ti,dvp_bus", &priv->dvp_bus))
+		priv->dvp_bus = 8;
+	if (of_property_read_bool(np, "ti,dvp_lsb"))
+		priv->dvp_lsb = 1;
+	else
+		priv->dvp_lsb = 0;
+	if (of_property_read_u32(np, "ti,hsync", &priv->hsync))
+		priv->hsync = 0;
+	if (of_property_read_u32(np, "ti,vsync", &priv->vsync))
+		priv->vsync = 1;
+	if (of_property_read_u32(np, "ti,ser_id", &priv->ser_id))
+		priv->ser_id = UB913_ID;
+	if (of_property_read_u32(np, "ti,poc-delay", &priv->poc_delay))
+		priv->poc_delay = 10;
+	if (of_property_read_u32(np, "csi-rate", &priv->csi_rate))
+		priv->csi_rate = 1450;
+	if (of_property_read_u32(np, "ti,vc-map", &priv->vc_map))
+		priv->vc_map = 0x3210;
+	for (i = 0; i < 4; i++) {
+		char name[10];
+
+		sprintf(name, "ti,gpio%d", i);
+		if (of_property_read_u32(np, name, &priv->gpio[i]))
+			priv->gpio[i] = 0;
+	}
+
+	/*
+	 * CSI forwarding of all links is to CSI0 by default.
+	 * Decide if any link will be forwarded to CSI1 instead CSI0
+	 */
+	prop = of_find_property(np, "ti,csi1-links", NULL);
+	if (prop) {
+		const __be32 *link = NULL;
+		u32 v;
+
+		for (i = 0; i < 4; i++) {
+			link = of_prop_next_u32(prop, link, &v);
+			if (!link)
+				break;
+			priv->csi_map |= BIT(v);
+		}
+	} else {
+		priv->csi_map = 0;
+	}
+
+	/* module params override dts */
+	if (is_stp)
+		priv->is_coax = 0;
+	if (dvp_bus != 8)
+		priv->dvp_bus = dvp_bus;
+	if (dvp_lsb)
+		priv->dvp_lsb = dvp_lsb;
+	if (hsync)
+		priv->hsync = hsync;
+	if (!vsync)
+		priv->vsync = vsync;
+	if (ser_id)
+		priv->ser_id = ser_id;
+	if (poc_delay)
+		priv->poc_delay = poc_delay;
+	if (vc_map != 0x3210)
+		priv->vc_map = vc_map;
+	if (csi_map)
+		priv->csi_map = csi_map;
+	if (gpio0)
+		priv->gpio[0] = gpio0;
+	if (gpio1)
+		priv->gpio[1] = gpio1;
+	if (gpio2)
+		priv->gpio[2] = gpio2;
+	if (gpio3)
+		priv->gpio[3] = gpio3;
+
+	for_each_endpoint_of_node(np, endpoint) {
+		struct ub9x4_sink *sink;
+		struct of_endpoint ep;
+
+		of_graph_parse_endpoint(endpoint, &ep);
+		dev_dbg(&client->dev, "Endpoint %pOF on port %d", ep.local_node, ep.port);
+
+		if (ep.port > UB9X4_N_LINKS) {
+			dev_err(&client->dev, "Invalid endpoint %s on port %d",
+				of_node_full_name(ep.local_node), ep.port);
+			continue;
+		}
+
+		if (ep.port == UB9X4_SOURCE) {
+			struct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = 0 };
+
+			err = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint), &v4l2_ep);
+			if (err) {
+				of_node_put(endpoint);
+				return err;
+			}
+
+			if (v4l2_ep.bus_type != V4L2_MBUS_CSI2_DPHY) {
+				dev_err(&client->dev, "Unsupported bus: %u\n", v4l2_ep.bus_type);
+				of_node_put(endpoint);
+				return -EINVAL;
+			}
+
+			priv->lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;
+
+			continue;
+		}
+
+		sink = &priv->sinks[ep.port];
+		sink->fwnode = fwnode_graph_get_remote_endpoint(of_fwnode_handle(endpoint));
+		if (!sink->fwnode) {
+			dev_err(&client->dev, "Endpoint %pOF has no remote endpoint connection\n", ep.local_node);
+			continue;
+		}
+
+		sink->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+		sink->asd.match.fwnode = sink->fwnode;
+
+		priv->subdevs[priv->nsinks] = &sink->asd;
+		priv->nsinks++;
+	}
+
+	of_node_put(endpoint);
+
+	return 0;
+}
+
+static int ub9x4_probe(struct i2c_client *client,
+		       const struct i2c_device_id *did)
+{
+	struct ub9x4_priv *priv;
+	int err;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, priv);
+	priv->client = client;
+	atomic_set(&priv->use_count, 0);
+	priv->fps_numerator = 1;
+	priv->fps_denominator = 30;
+
+	err = ub9x4_parse_dt(client);
+	if (err)
+		goto out;
+
+	err = ub9x4_i2c_mux_init(priv);
+	if (err) {
+		dev_err(&client->dev, "Unable to initialize I2C multiplexer\n");
+		goto out;
+	}
+
+	err = ub9x4_initialize(client);
+	if (err < 0)
+		goto out;
+
+	err = ub9x4_v4l2_init(client);
+	if (err < 0)
+		goto out;
+
+	/* FIXIT: v4l2_i2c_subdev_init re-assigned clientdata */
+	i2c_set_clientdata(client, priv);
+	ub9x4_post_initialize(client);
+
+	priv->reboot_notifier.notifier_call = ub9x4_reboot_notifier;
+	err = register_reboot_notifier(&priv->reboot_notifier);
+	if (err)
+		dev_err(&client->dev, "failed to register reboot notifier\n");
+
+out:
+	return err;
+}
+
+static int ub9x4_remove(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+	int i;
+
+	unregister_reboot_notifier(&priv->reboot_notifier);
+
+	i2c_mux_del_adapters(priv->mux);
+	v4l2_async_notifier_unregister(&priv->notifier);
+	v4l2_async_notifier_cleanup(&priv->notifier);
+	v4l2_async_unregister_subdev(&priv->sd);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i]))
+			regulator_disable(priv->poc_reg[i]); /* POC power off */
+	}
+
+	return 0;
+}
+
+static const struct of_device_id ub9x4_dt_ids[] = {
+	{ .compatible = "ti,ub9x4" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ub9x4_dt_ids);
+
+static const struct i2c_device_id ub9x4_id[] = {
+	{ "ub9x4", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ub9x4_id);
+
+static struct i2c_driver ub9x4_i2c_driver = {
+	.driver = {
+		.name = "ub9x4",
+		.of_match_table = of_match_ptr(ub9x4_dt_ids),
+	},
+	.probe = ub9x4_probe,
+	.remove = ub9x4_remove,
+	.id_table = ub9x4_id,
+};
+
+module_i2c_driver(ub9x4_i2c_driver);
+
+MODULE_DESCRIPTION("FPDLinkIII driver for ds90ub9x4");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/fpdlink/ub9x4.h b/drivers/media/i2c/fpdlink/ub9x4.h
new file mode 100644
index 0000000..e89aa9a
--- /dev/null
+++ b/drivers/media/i2c/fpdlink/ub9x4.h
@@ -0,0 +1,19 @@
+/*
+ * TI FPDLinkIII driver include file
+ *
+ * Copyright (C) 2017-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef _UB9X4_H
+#define _UB9X4_H
+
+#define UB913_ID	0x58
+#define UB953_ID	0x30 /* or starapped to 0x32 */
+#define UB9X4_ID	0x00 /* strapped */
+
+#endif /* _UB9X4_H */
diff --git a/drivers/media/i2c/gmsl/Kconfig b/drivers/media/i2c/gmsl/Kconfig
new file mode 100644
index 0000000..e58a8da
--- /dev/null
+++ b/drivers/media/i2c/gmsl/Kconfig
@@ -0,0 +1,14 @@
+#
+# GMSL video device configuration
+#
+
+config VIDEO_MAX9286
+	tristate "MAXIM MAX9286 GMSL deserializer support"
+	depends on I2C && I2C_MUX
+	depends on VIDEO_V4L2_SUBDEV_API && MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a MAXIM MAX9286 GMSL deserializer driver
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called max9286.
diff --git a/drivers/media/i2c/gmsl/Makefile b/drivers/media/i2c/gmsl/Makefile
new file mode 100644
index 0000000..763100a
--- /dev/null
+++ b/drivers/media/i2c/gmsl/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_VIDEO_MAX9286)	+= max9286.o
diff --git a/drivers/media/i2c/gmsl/common.h b/drivers/media/i2c/gmsl/common.h
new file mode 100644
index 0000000..144feed
--- /dev/null
+++ b/drivers/media/i2c/gmsl/common.h
@@ -0,0 +1,508 @@
+/*
+ * MAXIM GMSL common header
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/i2c-mux.h>
+#include "max9295.h"
+
+#define MAX9271_ID			0x09
+#define MAX9286_ID			0x40
+#define MAX9288_ID			0x2A
+#define MAX9290_ID			0x2C
+#define MAX9295A_ID			0x91
+#define MAX9295B_ID			0x93
+#define MAX9296A_ID			0x94
+#define MAX96705_ID			0x41
+#define MAX96706_ID			0x4A
+#define MAX96707_ID			0x45 /* MAX96715: same but lack of HS pin */
+#define MAX96708_ID			0x4C
+#define MAX96712_ID			0x20
+
+#define UB960_ID			0x00 /* strapped */
+
+#define BROADCAST			0x6f
+
+#define REG8_NUM_RETRIES		1 /* number of read/write retries */
+#define REG16_NUM_RETRIES		10 /* number of read/write retries */
+
+static inline char* chip_name(int id)
+{
+	switch (id) {
+	case MAX9271_ID:
+		return "MAX9271";
+	case MAX9286_ID:
+		return "MAX9286";
+	case MAX9288_ID:
+		return "MAX9288";
+	case MAX9290_ID:
+		return "MAX9290";
+	case MAX9295A_ID:
+		return "MAX9295A";
+	case MAX9295B_ID:
+		return "MAX9295B";
+	case MAX9296A_ID:
+		return "MAX9296A";
+	case MAX96705_ID:
+		return "MAX96705";
+	case MAX96706_ID:
+		return "MAX96706";
+	case MAX96707_ID:
+		return "MAX96707";
+	case MAX96712_ID:
+		return "MAX96712";
+	default:
+		return "serializer";
+	}
+}
+
+enum gmsl_mode {
+	MODE_GMSL1 = 1,
+	MODE_GMSL2,
+};
+
+#define MAXIM_I2C_I2C_SPEED_837KHZ	(0x7 << 2) /* 837kbps */
+#define MAXIM_I2C_I2C_SPEED_533KHZ	(0x6 << 2) /* 533kbps */
+#define MAXIM_I2C_I2C_SPEED_339KHZ	(0x5 << 2) /* 339 kbps */
+#define MAXIM_I2C_I2C_SPEED_173KHZ	(0x4 << 2) /* 174kbps */
+#define MAXIM_I2C_I2C_SPEED_105KHZ	(0x3 << 2) /* 105 kbps */
+#define MAXIM_I2C_I2C_SPEED_085KHZ	(0x2 << 2) /* 84.7 kbps */
+#define MAXIM_I2C_I2C_SPEED_028KHZ	(0x1 << 2) /* 28.3 kbps */
+#define MAXIM_I2C_I2C_SPEED		MAXIM_I2C_I2C_SPEED_339KHZ
+
+#define MIPI_DT_GENERIC			0x10
+#define MIPI_DT_GENERIC_1		0x11
+#define MIPI_DT_EMB			0x12
+#define MIPI_DT_YUV8			0x1e
+#define MIPI_DT_YUV10			0x1f
+#define MIPI_DT_RGB565			0x22
+#define MIPI_DT_RGB666			0x23
+#define MIPI_DT_RGB888			0x24
+#define MIPI_DT_RAW8			0x2a
+#define MIPI_DT_RAW10			0x2b
+#define MIPI_DT_RAW12			0x2c
+#define MIPI_DT_RAW14			0x2d
+#define MIPI_DT_RAW16			0x2e
+#define MIPI_DT_RAW20			0x2f
+#define MIPI_DT_YUV12			0x30
+
+static inline int mipi_dt_to_bpp(unsigned int dt)
+{
+	switch (dt) {
+		case 0x2a:
+		case 0x10 ... 0x12:
+		case 0x31 ... 0x37:
+			return 0x08;
+		case 0x2b:
+			return 0x0a;
+		case 0x2c:
+			return 0x0c;
+		case 0x0d:
+			return 0x0e;
+		case 0x22:
+		case 0x1e:
+		case 0x2e:
+			return 0x10;
+		case 0x23:
+			return 0x12;
+		case 0x1f:
+		case 0x2f:
+			return 0x14;
+		case 0x24:
+		case 0x30:
+			return 0x18;
+		default:
+			return 0x08;
+	}
+}
+
+static inline int reg8_read(struct i2c_client *client, u8 reg, u8 *val)
+{
+	int ret, retries;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_read_byte_data(client, reg);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = ret;
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_write(struct i2c_client *client, u8 reg, u8 val)
+{
+	int ret, retries;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_write_byte_data(client, reg, val);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2;
+		reg8_read(client, reg, &val2);
+		if (val != val2)
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x "
+				"0x%x->0x%x\n", client->addr, reg, val, val2);
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read(struct i2c_client *client, u16 reg, u8 *val)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, buf, 1);
+			if (ret == 1)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = buf[0];
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write(struct i2c_client *client, u16 reg, u8 val)
+{
+	int ret, retries;
+	u8 buf[3] = {reg >> 8, reg & 0xff, val};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 3);
+		if (ret == 3)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2;
+		reg16_read(client, reg, &val2);
+		if (val != val2)
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x "
+				"0x%x->0x%x\n", client->addr, reg, val, val2);
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read16(struct i2c_client *client, u16 reg, u16 *val)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, buf, 2);
+			if (ret == 2)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = ((u16)buf[0] << 8) | buf[1];
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write16(struct i2c_client *client, u16 reg, u16 val)
+{
+	int ret, retries;
+	u8 buf[4] = {reg >> 8, reg & 0xff, val >> 8, val & 0xff};
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 4);
+		if (ret == 4)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read_n(struct i2c_client *client, u16 reg, u8 *val, int n)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, val, n);
+			if (ret == n)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x registers 0x%x-0x%x: %d\n",
+			client->addr, reg, reg + n, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write_n(struct i2c_client *client, u16 reg, const u8* val, int n)
+{
+	int ret, retries;
+	u8 buf[8];
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+	memcpy(&buf[2], val, n);
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2 + n);
+		if (ret == 2 + n)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x-0x%x: %d\n",
+			client->addr, reg, reg + n, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2[n];
+		ret = reg16_read_n(client, reg, val2, n);
+		if (ret < 0)
+			return ret;
+
+		if (memcmp(val, val2, n)) {
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x-0x%x "
+				"'%*phN'->'%*phN'\n", client->addr, reg, reg + n,
+				n, val, n, val2);
+				ret = -EBADE;
+		}
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_read_addr(struct i2c_client *client, int addr, u8 reg, u8 *val)
+{
+	int ret, retries;
+	union i2c_smbus_data data;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_xfer(client->adapter, addr, client->flags,
+				     I2C_SMBUS_READ, reg, I2C_SMBUS_BYTE_DATA, &data);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			addr, reg, ret);
+	} else {
+		*val = data.byte;
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_write_addr(struct i2c_client *client, u8 addr, u8 reg, u8 val)
+{
+	int ret, retries;
+	union i2c_smbus_data data;
+
+	data.byte = val;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_xfer(client->adapter, addr, client->flags,
+				     I2C_SMBUS_WRITE, reg, I2C_SMBUS_BYTE_DATA, &data);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x value 0x%0x: %d\n",
+			addr, reg, val, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+
+static inline int reg16_write_addr(struct i2c_client *client, int chip, u16 reg, u8 val)
+{
+	struct i2c_msg msg[1];
+	u8 wbuf[3];
+	int ret;
+
+	msg->addr = chip;
+	msg->flags = 0;
+	msg->len = 3;
+	msg->buf = wbuf;
+	wbuf[0] = reg >> 8;
+	wbuf[1] = reg & 0xff;
+	wbuf[2] = val;
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret < 0) {
+		dev_dbg(&client->dev, "i2c fail: chip 0x%02x wr 0x%04x (0x%02x): %d\n",
+			chip, reg, val, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline int reg16_read_addr(struct i2c_client *client, int chip, u16 reg, int *val)
+{
+	struct i2c_msg msg[2];
+	u8 wbuf[2];
+	u8 rbuf[1];
+	int ret;
+
+	msg[0].addr = chip;
+	msg[0].flags = 0;
+	msg[0].len = 2;
+	msg[0].buf = wbuf;
+	wbuf[0] = reg >> 8;
+	wbuf[1] = reg & 0xff;
+
+	msg[1].addr = chip;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = rbuf;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_dbg(&client->dev, "i2c fail: chip 0x%02x rd 0x%04x: %d\n", chip, reg, ret);
+		return ret;
+	}
+
+	*val = rbuf[0];
+
+	return 0;
+}
+
+#define __reg8_read(addr, reg, val)		reg8_read_addr(priv->client, addr, reg, val)
+#define __reg8_write(addr, reg, val)		reg8_write_addr(priv->client, addr, reg, val)
+#define __reg16_read(addr, reg, val)		reg16_read_addr(priv->client, addr, reg, val)
+#define __reg16_write(addr, reg, val)		reg16_write_addr(priv->client, addr, reg, val)
+
+/* copy this struct from drivers/i2c/i2c-mux.c for getting muxc from adapter private data */
+struct i2c_mux_priv {
+	struct i2c_adapter adap;
+	struct i2c_algorithm algo;
+	struct i2c_mux_core *muxc;
+	u32 chan_id;
+};
+
+static inline int get_des_id(struct i2c_client *client)
+{
+	struct i2c_mux_priv *mux_priv = client->adapter->algo_data;
+
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9286"))
+		return MAX9286_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9288"))
+		return MAX9288_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9296"))
+		return MAX9296A_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max96706"))
+		return MAX96706_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max96712"))
+		return MAX96712_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "ti9x4"))
+		return UB960_ID;
+
+	return -EINVAL;
+}
+
+static inline int get_des_addr(struct i2c_client *client)
+{
+	struct i2c_mux_priv *mux_priv = client->adapter->algo_data;
+
+	return to_i2c_client(mux_priv->muxc->dev)->addr;
+}
+
+static inline void setup_i2c_translator(struct i2c_client *client, int ser_addr, int sensor_addr)
+{
+	int gmsl_mode = MODE_GMSL2;
+
+	switch (get_des_id(client)) {
+	case MAX9286_ID:
+	case MAX9288_ID:
+	case MAX96706_ID:
+		reg8_write_addr(client, ser_addr, 0x09, client->addr << 1);	/* Sensor translated I2C address */
+		reg8_write_addr(client, ser_addr, 0x0A, sensor_addr << 1);	/* Sensor native I2C address */
+		break;
+	case MAX9296A_ID:
+	case MAX96712_ID:
+		/* parse gmsl mode from deserializer */
+		reg16_read_addr(client, get_des_addr(client), 6, &gmsl_mode);
+		gmsl_mode = !!(gmsl_mode & BIT(7)) + 1;
+
+		if (gmsl_mode == MODE_GMSL1) {
+			reg8_write_addr(client, ser_addr, 0x09, client->addr << 1);	/* Sensor translated I2C address */
+			reg8_write_addr(client, ser_addr, 0x0A, sensor_addr << 1);	/* Sensor native I2C address */
+		}
+		if (gmsl_mode == MODE_GMSL2) {
+			reg16_write_addr(client, ser_addr, MAX9295_I2C2, client->addr << 1); /* Sensor translated I2C address */
+			reg16_write_addr(client, ser_addr, MAX9295_I2C3, sensor_addr << 1); /* Sensor native I2C address */
+		}
+		break;
+	case UB960_ID:
+		reg8_write_addr(client, get_des_addr(client), 0x65, client->addr << 1);	/* Sensor translated I2C address */
+		reg8_write_addr(client, get_des_addr(client), 0x5d, sensor_addr << 1);	/* Sensor native I2C address */
+		break;
+	}
+	usleep_range(2000, 2500);
+}
diff --git a/drivers/media/i2c/gmsl/max9286.c b/drivers/media/i2c/gmsl/max9286.c
new file mode 100644
index 0000000..08a5df0
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max9286.c
@@ -0,0 +1,1123 @@
+/*
+ * MAXIM max9286 GMSL driver
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/reboot.h>
+#include <linux/regulator/consumer.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "common.h"
+
+#define MAX9286_N_LINKS		4
+
+enum max9286_pads {
+	MAX9286_SINK_LINK0,
+	MAX9286_SINK_LINK1,
+	MAX9286_SINK_LINK2,
+	MAX9286_SINK_LINK3,
+	MAX9286_SOURCE,
+	MAX9286_N_PADS,
+};
+
+struct max9286_sink {
+	struct v4l2_async_subdev asd;
+	struct v4l2_subdev	*sd;
+	struct fwnode_handle	*fwnode;
+};
+
+#define asd_to_max9286_sink(_asd) \
+	container_of(_asd, struct max9286_sink, asd)
+
+struct max9286_priv {
+	struct i2c_client	*client;
+	struct v4l2_subdev	sd;
+	struct media_pad	pads[MAX9286_N_PADS];
+
+	struct i2c_mux_core	*mux;
+	unsigned int		mux_channel;
+
+	unsigned int		nsinks;
+	struct max9286_sink	sinks[MAX9286_N_LINKS];
+	struct v4l2_async_subdev *subdevs[MAX9286_N_LINKS];
+	struct v4l2_async_notifier notifier;
+	struct v4l2_ctrl_handler ctrls;
+
+	int			des_addr;
+	int			des_quirk_addr; /* second MAX9286 on the same I2C bus */
+	int			n_links;
+	int			links_mask;
+	int			lanes;
+	long			pixel_rate;
+	const char		*fsync_mode;
+	int			fsync_period;
+	int			pclk;
+	char			pclk_rising_edge;
+	int			gpio_resetb;
+	int			active_low_resetb;
+	int			him;
+	int			hsync;
+	int			vsync;
+	int			timeout;
+	int			poc_delay;
+	int			bws;
+	int			dbl;
+	int			dt;
+	int			hsgen;
+	u64			crossbar;
+	char			cb[16];
+	int			hts;
+	int			vts;
+	int			hts_delay;
+	atomic_t		use_count;
+	u32			csi2_outord;
+	u32			switchin;
+	int			ser_addr[4];
+	int			ser_id;
+	struct regulator	*poc_reg[4]; /* PoC power supply */
+	struct notifier_block	reboot_notifier;
+	/* link statistic */
+	int			prbserr[4];
+	int			deterr[4];
+	int			correrr[4];
+};
+
+#include "max9286_debug.h"
+
+static char fsync_mode_default[20] = "manual"; /* manual, automatic, semi-automatic, external */
+
+static int conf_link;
+module_param(conf_link, int, 0644);
+MODULE_PARM_DESC(conf_link, " Force configuration link. Used only if robust firmware flashing required (f.e. recovery)");
+
+static int poc_trig;
+module_param(poc_trig, int, 0644);
+MODULE_PARM_DESC(poc_trig, " Use PoC triggering during reverse channel setup. Useful on systems with dedicated PoC and unstable ser-des lock");
+
+static int him;
+module_param(him, int, 0644);
+MODULE_PARM_DESC(him, " Use High-Immunity mode (default: leagacy mode)");
+
+static int fsync_period;
+module_param(fsync_period, int, 0644);
+MODULE_PARM_DESC(fsync_period, " Frame sync period (default: 3.2MHz)");
+
+static int hsync;
+module_param(hsync, int, 0644);
+MODULE_PARM_DESC(hsync, " HSYNC invertion (default: 0 - not inverted)");
+
+static int vsync = 1;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 1 - inverted)");
+
+static int gpio_resetb;
+module_param(gpio_resetb, int, 0644);
+MODULE_PARM_DESC(gpio_resetb, " Serializer GPIO reset (default: 0 - not used)");
+
+static int active_low_resetb;
+module_param(active_low_resetb, int, 0644);
+MODULE_PARM_DESC(active_low_resetb, " Serializer GPIO reset level (default: 0 - active high)");
+
+static int timeout_n = 100;
+module_param(timeout_n, int, 0644);
+MODULE_PARM_DESC(timeout_n, " Timeout of link detection (default: 100 retries)");
+
+static int poc_delay = 50;
+module_param(poc_delay, int, 0644);
+MODULE_PARM_DESC(poc_delay, " Delay in ms after POC enable (default: 50 ms)");
+
+static int bws;
+module_param(bws, int, 0644);
+MODULE_PARM_DESC(bws, " BWS mode (default: 0 - 24-bit gmsl packets)");
+
+static int dbl = 1;
+module_param(dbl, int, 0644);
+MODULE_PARM_DESC(dbl, " DBL mode (default: 1 - DBL mode enabled)");
+
+static int dt = 3;
+module_param(dt, int, 0644);
+MODULE_PARM_DESC(dt, " DataType (default: 3 - YUV8), 0 - RGB888, 5 - RAW8, 6 - RAW10, 7 - RAW12, 8 - RAW14");
+
+static int hsgen;
+module_param(hsgen, int, 0644);
+MODULE_PARM_DESC(hsgen, " Enable HS embedded generator (default: 0 - disabled)");
+
+static int pclk = 100;
+module_param(pclk, int, 0644);
+MODULE_PARM_DESC(pclk, " PCLK rate (default: 100MHz)");
+
+static int switchin = 0;
+module_param(switchin, int, 0644);
+MODULE_PARM_DESC(switchin, " COAX SWITCH IN+ and IN- (default: 0 - not switched)");
+
+static unsigned long crossbar = 0xba9876543210;
+module_param(crossbar, ulong, 0644);
+MODULE_PARM_DESC(crossbar, " Crossbar setup (default: ba9876543210 - reversed)");
+
+enum {
+	RGB888_DT = 0,
+	RGB565_DT,
+	RGB666_DT,
+	YUV8_DT, /* default */
+	YUV10_DT,
+	RAW8_DT,
+	RAW10_DT,
+	RAW12_DT,
+	RAW14_DT,
+};
+
+static int dt2bpp[9] = {
+	24,	/* RGB888 */
+	16,	/* RGB565 */
+	18,	/* RGB666 */
+	8,	/* YUV8 - default */
+	10,	/* YUV10 */
+	8,	/* RAW8/RAW16 */
+	10,	/* RAW10 */
+	12,	/* RAW12 */
+	14,	/* RAW14 */
+};
+
+static void max9286_write_remote_verify(struct i2c_client *client, int idx, u8 reg, u8 val)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	int timeout;
+
+	for (timeout = 0; timeout < 10; timeout++) {
+		int tmp_addr;
+		u8 sts = 0;
+		u8 val2 = 0;
+
+		reg8_write(client, reg, val);
+
+		tmp_addr = client->addr;
+		client->addr = priv->des_addr;
+		reg8_read(client, 0x70, &sts);
+		client->addr = tmp_addr;
+		if (sts & BIT(idx)) /* if ACKed */ {
+			reg8_read(client, reg, &val2);
+			if (val2 == val)
+				break;
+		}
+
+		usleep_range(1000, 1500);
+	}
+
+	if (timeout >= 10)
+		dev_err(&client->dev, "timeout remote write acked\n");
+}
+
+static void max9286_preinit(struct i2c_client *client, int addr)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+
+	client->addr = addr;
+	reg8_write(client, 0x0a, 0x00);		/* disable reverse control for all cams */
+	reg8_write(client, 0x00, 0x00);		/* disable all GMSL links [0:3] */
+//	usleep_range(2000, 2500);
+	reg8_write(client, 0x1b, priv->switchin); /* coax polarity (default - normal) */
+	reg8_write(client, 0x1c, (priv->him ? 0xf0 : 0x00) |
+				 (priv->bws ? 0x05 : 0x04)); /* high-immunity/legacy mode, BWS 24bit */
+}
+
+static void max9286_sensor_reset(struct i2c_client *client, int addr, int reset_on)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+
+	if (priv->ser_id == MAX96707_ID)
+		return;
+
+	if (priv->gpio_resetb < 1 || priv->gpio_resetb > 5)
+		return;
+
+	if (priv->active_low_resetb)
+		reset_on = !reset_on;
+
+	/* sensor reset/unreset using serializer gpio */
+	client->addr = addr;
+	reg8_write(client, 0x0f, (0xfe & ~BIT(priv->gpio_resetb)) | (reset_on ? BIT(priv->gpio_resetb) : 0)); /* set GPIOn value */
+	reg8_write(client, 0x0e, 0x42 | BIT(priv->gpio_resetb)); /* set GPIOn direction output */
+}
+
+static void max9286_postinit(struct i2c_client *client, int addr)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	int idx;
+
+	for (idx = 0; idx < priv->n_links; idx++) {
+		if (priv->ser_id == MAX96705_ID || priv->ser_id == MAX96707_ID)
+			continue;
+
+		client->addr = priv->des_addr;
+		reg8_write(client, 0x00, 0xe0 | BIT(idx));	/* enable GMSL link for CAMx */
+		reg8_write(client, 0x0a, 0x11 << idx);		/* enable reverse/forward control for CAMx */
+		usleep_range(5000, 5500);
+
+		client->addr = priv->ser_addr[idx];
+		max9286_sensor_reset(client, client->addr, 0);	/* sensor unreset using gpios. TODO: should be in imager driver */
+	}
+
+	client->addr = addr;
+	reg8_write(client, 0x0a, 0x00);				/* disable reverse control for all cams */
+	reg8_write(client, 0x00, 0xe0 | priv->links_mask);	/* enable GMSL link for CAMs */
+	reg8_write(client, 0x0b, priv->csi2_outord);		/* CSI2 output order */
+	reg8_write(client, 0x15, 0x9b);				/* enable CSI output, VC is set accordingly to Link number, BIT7 magic must be set */
+	reg8_write(client, 0x1b, priv->switchin | priv->links_mask); /* coax polarity, enable equalizer for CAMs */
+	reg8_write(client, 0x34, 0x22 | MAXIM_I2C_I2C_SPEED);	/* disable artificial ACK, I2C speed set */
+	usleep_range(5000, 5500);
+
+	if (strcmp(priv->fsync_mode, "manual") == 0) {
+		reg8_write(client, 0x01, 0x00);			/* manual: FRAMESYNC set manually via [0x06:0x08] regs */
+	} else if (strcmp(priv->fsync_mode, "automatic") == 0) {
+		reg8_write(client, 0x01, 0x02);			/* automatic: FRAMESYNC taken from the slowest Link */
+	} else if (strcmp(priv->fsync_mode, "semi-automatic") == 0) {
+		reg8_write(client, 0x01, 0x01);			/* semi-automatic: FRAMESYNC taken from the slowest Link */
+	} else if (strcmp(priv->fsync_mode, "external") == 0) {
+		reg8_write(client, 0x01, 0xc0);			/* ECU (aka MCU) based FrameSync using GPI-to-GPO */
+	}
+}
+
+static int max9286_reverse_channel_setup(struct i2c_client *client, int idx)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	u8 val = 0, lock_sts = 0, link_sts = 0;
+	int timeout = priv->timeout;
+	char timeout_str[40];
+	int ret = 0;
+
+	/* Reverse channel enable */
+	client->addr = priv->des_addr;
+	reg8_write(client, 0x34, 0xa2 | MAXIM_I2C_I2C_SPEED);	/* enable artificial ACKs, I2C speed set */
+	usleep_range(2000, 2500);
+	reg8_write(client, 0x00, 0xe0 | BIT(idx));		/* enable GMSL link for CAMx */
+	reg8_write(client, 0x0a, 0x11 << idx);			/* enable reverse control for CAMx */
+	usleep_range(2000, 2500);
+
+	for (;;) {
+		if (priv->him) {
+			/* HIM mode setup */
+			client->addr = 0x40;
+			reg8_write(client, 0x4d, 0xc0);
+			usleep_range(2000, 2500);
+			reg8_write(client, 0x04, 0x43);		/* wake-up, enable reverse_control/conf_link */
+			usleep_range(2000, 2500);
+			if (priv->bws) {
+				reg8_write(client, 0x07, 0x04 | (priv->pclk_rising_edge ? 0 : 0x10) |
+							 (priv->dbl ? 0x80 : 0) |
+							 (priv->bws ? 0x20 : 0)); /* RAW/YUV, PCLK edge, HS/VS encoding enabled, DBL mode, BWS 24/32-bit */
+				usleep_range(2000, 2500);
+			}
+		} else {
+			/* Legacy mode setup */
+			client->addr = priv->des_addr;
+			reg8_write(client, 0x3f, 0x4f);		/* enable custom reverse channel & first pulse length */
+			reg8_write(client, 0x3b, 0x1e);		/* first pulse length rise time changed from 300ns to 200ns, amplitude 100mV */
+			usleep_range(2000, 2500);
+
+			client->addr = 0x40;
+			reg8_write(client, 0x04, 0x43);		/* wake-up, enable reverse_control/conf_link */
+			usleep_range(2000, 2500);
+			reg8_write(client, 0x08, 0x01);		/* reverse channel receiver high threshold enable */
+			reg8_write(client, 0x97, 0x5f);		/* enable reverse control channel programming (MAX96705-MAX96711 only) */
+			usleep_range(2000, 2500);
+			if (priv->bws) {
+				reg8_write(client, 0x07, 0x04 | (priv->pclk_rising_edge ? 0 : 0x10) |
+							 (priv->dbl ? 0x80 : 0) |
+							 (priv->bws ? 0x20 : 0)); /* RAW/YUV, PCLK edge, HS/VS encoding enabled, DBL mode, BWS 24/32-bit */
+				usleep_range(2000, 2500);
+			}
+
+			client->addr = priv->des_addr;
+			reg8_write(client, 0x3b, 0x19);		/* reverse channel increase amplitude 170mV to compensate high threshold enabled */
+			usleep_range(2000, 2500);
+		}
+
+		client->addr = 0x40;
+		reg8_read(client, 0x1e, &val);			/* read max9271 ID */
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID || --timeout == 0) {
+			priv->ser_id = val;
+			break;
+		}
+
+		/* Check if already initialized (after reboot/reset ?) */
+		client->addr = priv->ser_addr[idx];
+		reg8_read(client, 0x1e, &val);			/* read max9271 ID */
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID) {
+			priv->ser_id = val;
+			reg8_write(client, 0x04, 0x43);		/* enable reverse_control/conf_link */
+			usleep_range(2000, 2500);
+			ret = -EADDRINUSE;
+			break;
+		}
+
+		if (poc_trig) {
+			if (!IS_ERR(priv->poc_reg[idx]) && (timeout % poc_trig == 0)) {
+				regulator_disable(priv->poc_reg[idx]); /* POC power off */
+				mdelay(200);
+				ret = regulator_enable(priv->poc_reg[idx]); /* POC power on */
+				if (ret)
+					dev_err(&client->dev, "failed to enable poc regulator\n");
+				mdelay(priv->poc_delay);
+			}
+		}
+	}
+
+	max9286_sensor_reset(client, client->addr, 1);	/* sensor reset */
+
+	client->addr = priv->des_addr;			/* MAX9286-CAMx I2C */
+	reg8_read(client, 0x27, &lock_sts);		/* LOCK status */
+	reg8_read(client, 0x49, &link_sts);		/* LINK status */
+
+	if (!timeout) {
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	priv->links_mask |= BIT(idx);
+	priv->csi2_outord &= ~(0x3 << (idx * 2));
+	priv->csi2_outord |= ((hweight8(priv->links_mask) - 1) << (idx * 2));
+
+out:
+	sprintf(timeout_str, "retries=%d lock_sts=%d link_sts=0x%x", priv->timeout - timeout, !!(lock_sts & 0x80), link_sts & (0x11 << idx));
+	dev_info(&client->dev, "link%d %s %sat 0x%x %s %s\n", idx, chip_name(priv->ser_id),
+			       ret == -EADDRINUSE ? "already " : "", priv->ser_addr[idx],
+			       ret == -ETIMEDOUT ? "not found: timeout GMSL link establish" : "",
+			       priv->timeout - timeout ? timeout_str : "");
+
+	return ret;
+}
+
+static void max9286_initial_setup(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+
+	/* Initial setup */
+	client->addr = priv->des_addr;
+	reg8_write(client, 0x15, 0x13);				/* disable CSI output, VC is set accordingly to Link number */
+	reg8_write(client, 0x69, 0x0f);				/* mask CSI forwarding from all links */
+	reg8_write(client, 0x12, ((priv->lanes - 1) << 6) |
+				 (priv->dbl ? 0x30 : 0) |
+				 (priv->dt & 0xf));		/* setup lanes, DBL mode, DataType */
+
+	/* Start GMSL initialization with FSYNC disabled. This is required for some odd LVDS cameras */
+	reg8_write(client, 0x01, 0xc0);				/* ECU (aka MCU) based FrameSync using GPI-to-GPO */
+	reg8_write(client, 0x06, priv->fsync_period & 0xff);
+	reg8_write(client, 0x07, (priv->fsync_period >> 8) & 0xff);
+	reg8_write(client, 0x08, priv->fsync_period >> 16);
+
+	reg8_write(client, 0x63, 0);				/* disable overlap window */
+	reg8_write(client, 0x64, 0);
+	reg8_write(client, 0x0c, 0x91 | (priv->vsync ? BIT(3) : 0) | (priv->hsync ? BIT(2) : 0)); /* enable HS/VS encoding, use D14/15 for HS/VS, invert HS/VS */
+	reg8_write(client, 0x19, 0x0c);				/* Drive HSTRAIL state for 120ns after the last payload bit */
+}
+
+static void max9286_gmsl_link_setup(struct i2c_client *client, int idx)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+
+	/* GMSL setup */
+	client->addr = 0x40;
+	reg8_write(client, 0x0d, 0x22 | MAXIM_I2C_I2C_SPEED);	/* disable artificial ACK, I2C speed set */
+	reg8_write(client, 0x07, 0x04 | (priv->pclk_rising_edge ? 0 : 0x10) |
+					(priv->dbl ? 0x80 : 0) |
+					(priv->bws ? 0x20 : 0)); /* RAW/YUV, PCLK edge, HS/VS encoding enabled, DBL mode, BWS 24/32-bit */
+	usleep_range(2000, 2500);
+	reg8_write(client, 0x02, 0xff);				/* spread spectrum +-4%, pclk range automatic, Gbps automatic  */
+	usleep_range(2000, 2500);
+
+	if (priv->ser_id == MAX96705_ID || priv->ser_id == MAX96707_ID) {
+		switch (priv->dt) {
+		case YUV8_DT:
+			/* setup crossbar for YUV8/RAW8: reverse DVP bus */
+			reg8_write(client, 0x20, priv->cb[7]);
+			reg8_write(client, 0x21, priv->cb[6]);
+			reg8_write(client, 0x22, priv->cb[5]);
+			reg8_write(client, 0x23, priv->cb[4]);
+			reg8_write(client, 0x24, priv->cb[3]);
+			reg8_write(client, 0x25, priv->cb[2]);
+			reg8_write(client, 0x26, priv->cb[1]);
+			reg8_write(client, 0x27, priv->cb[0]);
+
+			/* this is second byte if DBL=1 */
+			reg8_write(client, 0x30, priv->cb[7] + 16);
+			reg8_write(client, 0x31, priv->cb[6] + 16);
+			reg8_write(client, 0x32, priv->cb[5] + 16);
+			reg8_write(client, 0x33, priv->cb[4] + 16);
+			reg8_write(client, 0x34, priv->cb[3] + 16);
+			reg8_write(client, 0x35, priv->cb[2] + 16);
+			reg8_write(client, 0x36, priv->cb[1] + 16);
+			reg8_write(client, 0x37, priv->cb[0] + 16);
+			break;
+		case RAW12_DT:
+			/* setup crossbar for RAW12: reverse DVP bus */
+			reg8_write(client, 0x20, priv->cb[11]);
+			reg8_write(client, 0x21, priv->cb[10]);
+			reg8_write(client, 0x22, priv->cb[9]);
+			reg8_write(client, 0x23, priv->cb[8]);
+			reg8_write(client, 0x24, priv->cb[7]);
+			reg8_write(client, 0x25, priv->cb[6]);
+			reg8_write(client, 0x26, priv->cb[5]);
+			reg8_write(client, 0x27, priv->cb[4]);
+			reg8_write(client, 0x28, priv->cb[3]);
+			reg8_write(client, 0x29, priv->cb[2]);
+			reg8_write(client, 0x2a, priv->cb[1]);
+			reg8_write(client, 0x2b, priv->cb[0]);
+
+			/* this is second byte if DBL=1 */
+			reg8_write(client, 0x30, priv->cb[11] + 16);
+			reg8_write(client, 0x31, priv->cb[10] + 16);
+			reg8_write(client, 0x32, priv->cb[9] + 16);
+			reg8_write(client, 0x33, priv->cb[8] + 16);
+			reg8_write(client, 0x34, priv->cb[7] + 16);
+			reg8_write(client, 0x35, priv->cb[6] + 16);
+			reg8_write(client, 0x36, priv->cb[5] + 16);
+			reg8_write(client, 0x37, priv->cb[4] + 16);
+			reg8_write(client, 0x38, priv->cb[3] + 16);
+			reg8_write(client, 0x39, priv->cb[2] + 16);
+			reg8_write(client, 0x3a, priv->cb[1] + 16);
+			reg8_write(client, 0x3b, priv->cb[0] + 16);
+
+			if (!priv->bws && priv->dbl)
+				dev_err(&client->dev, " BWS must be 27/32-bit for RAW12 in DBL mode\n");
+
+			break;
+		}
+
+		if (priv->hsgen) {
+			/* HS/VS pins map */
+			reg8_write(client, 0x3f, 0x10);			/* HS (NC) */
+			reg8_write(client, 0x41, 0x10);			/* DE (NC) */
+			if (priv->ser_id == MAX96705_ID)
+				reg8_write(client, 0x40, 15);		/* VS (DIN13) */
+			if (priv->ser_id == MAX96707_ID)
+				reg8_write(client, 0x40, 13);		/* VS (DIN13) */
+#if 0
+			/* following must come from imager */
+#define SENSOR_WIDTH	(1280*2)
+#define HTS		(1288*2)
+#define VTS		960
+#define HTS_DELAY	0x9
+			reg8_write(client, 0x4e, HTS_DELAY >> 16);	/* HS delay */
+			reg8_write(client, 0x4f, (HTS_DELAY >> 8) & 0xff);
+			reg8_write(client, 0x50, HTS_DELAY & 0xff);
+			reg8_write(client, 0x54, SENSOR_WIDTH >> 8);	/* HS high period */
+			reg8_write(client, 0x55, SENSOR_WIDTH & 0xff);
+			reg8_write(client, 0x56, (HTS - SENSOR_WIDTH) >> 8); /* HS low period */
+			reg8_write(client, 0x57, (HTS - SENSOR_WIDTH) & 0xff);
+			reg8_write(client, 0x58, VTS >> 8);		/* HS count */
+			reg8_write(client, 0x59, VTS & 0xff );
+#endif
+			reg8_write(client, 0x43, 0x15);			/* enable HS generator */
+		}
+	}
+
+	client->addr = priv->des_addr;
+	reg8_write(client, 0x34, 0x22 | MAXIM_I2C_I2C_SPEED);	/* disable artificial ACK, I2C speed set */
+	usleep_range(2000, 2500);
+
+	/* I2C translator setup */
+	client->addr = 0x40;
+//	reg8_write(client, 0x09, maxim_map[2][idx] << 1);	/* SENSOR I2C translated - must be set by sensor driver */
+//	reg8_write(client, 0x0A, 0x30 << 1);			/* SENSOR I2C native - must be set by sensor driver */
+	reg8_write(client, 0x0B, BROADCAST << 1);		/* broadcast I2C */
+	reg8_write(client, 0x0C, priv->ser_addr[idx] << 1);
+	/* I2C addresse change */
+	reg8_write(client, 0x01, priv->des_addr << 1);
+	reg8_write(client, 0x00, priv->ser_addr[idx] << 1);
+	usleep_range(2000, 2500);
+	/* put MAX9271 in configuration link state  */
+	client->addr = priv->ser_addr[idx];
+	reg8_write(client, 0x04, 0x43);				/* enable reverse_control/conf_link */
+	usleep_range(2000, 2500);
+}
+
+static int max9286_initialize(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	int i, ret;
+
+	dev_info(&client->dev, "LINKs=%d, LANES=%d, FSYNC mode=%s, FSYNC period=%d, PCLK edge=%s\n",
+			       priv->n_links, priv->lanes, priv->fsync_mode, priv->fsync_period,
+			       priv->pclk_rising_edge ? "rising" : "falling");
+
+	if (priv->des_quirk_addr)
+		max9286_preinit(client, priv->des_quirk_addr);
+
+	max9286_preinit(client, priv->des_addr);
+	max9286_initial_setup(client);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i])) {
+			ret = regulator_enable(priv->poc_reg[i]); /* POC power on */
+			if (ret) {
+				dev_err(&client->dev, "failed to enable poc regulator\n");
+				continue;
+			}
+			mdelay(priv->poc_delay);
+		}
+
+		ret = max9286_reverse_channel_setup(client, i);
+		if (ret == -ETIMEDOUT)
+			continue;
+		if (!ret)
+			max9286_gmsl_link_setup(client, i);
+
+		i2c_mux_add_adapter(priv->mux, 0, i, 0);
+	}
+
+	max9286_postinit(client, priv->des_addr);
+
+	client->addr = priv->des_addr;
+
+	return 0;
+}
+
+static int max9286_post_initialize(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	int idx;
+
+	for (idx = 0; idx < priv->n_links; idx++) {
+		if (!(priv->links_mask & (1 << idx)))
+			continue;
+
+		client->addr = priv->des_addr;
+		reg8_write(client, 0x0a, 0x11 << idx); /* enable reverse/forward control for CAMx */
+//		usleep_range(5000, 5500);
+
+		/* switch to GMSL serial_link for streaming video */
+		client->addr = priv->ser_addr[idx];
+		max9286_write_remote_verify(client, idx, 0x04, conf_link ? 0x43 : 0x83);
+	}
+
+	client->addr = priv->des_addr;
+	reg8_write(client, 0x0a, (priv->links_mask << 4) | priv->links_mask); /* enable reverse/forward control for all detected CAMs */
+
+	return 0;
+}
+
+static int max9286_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct max9286_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+
+	if (enable) {
+		if (atomic_inc_return(&priv->use_count) == 1)
+			reg8_write(client, 0x69, priv->links_mask ^ 0x0f); /* unmask CSI forwarding from detected links */
+	} else {
+		if (atomic_dec_return(&priv->use_count) == 0)
+			reg8_write(client, 0x69, 0x0f); /* mask CSI forwarding from all links */
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops max9286_video_ops = {
+	.s_stream	= max9286_s_stream,
+};
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int max9286_g_register(struct v4l2_subdev *sd,
+				      struct v4l2_dbg_register *reg)
+{
+	struct max9286_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+	int ret;
+	u8 val = 0;
+
+	ret = reg8_read(client, (u8)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u8);
+
+	return 0;
+}
+
+static int max9286_s_register(struct v4l2_subdev *sd,
+				      const struct v4l2_dbg_register *reg)
+{
+	struct max9286_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+
+	return reg8_write(client, (u8)reg->reg, (u8)reg->val);
+}
+#endif
+
+static int max9286_reboot_notifier(struct notifier_block *nb, unsigned long event, void *buf)
+{
+	struct max9286_priv *priv = container_of(nb, struct max9286_priv, reboot_notifier);
+	int i;
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i]))
+			regulator_disable(priv->poc_reg[i]); /* POC power off */
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct v4l2_subdev_core_ops max9286_subdev_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register	= max9286_g_register,
+	.s_register	= max9286_s_register,
+#endif
+};
+
+static const struct v4l2_subdev_ops max9286_subdev_ops = {
+	.core		= &max9286_subdev_core_ops,
+	.video		= &max9286_video_ops,
+};
+
+/* -----------------------------------------------------------------------------
+ * I2C Multiplexer
+ */
+
+static int max9286_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	/* Do nothing! */
+	return 0;
+}
+
+static int max9286_i2c_mux_init(struct max9286_priv *priv)
+{
+	struct i2c_client *client = priv->client;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	priv->mux = i2c_mux_alloc(client->adapter, &client->dev,
+				  priv->nsinks, 0, I2C_MUX_LOCKED,
+				  max9286_i2c_mux_select, NULL);
+	if (!priv->mux)
+		return -ENOMEM;
+
+	priv->mux->priv = priv;
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * Async handling and registration of subdevices and links.
+ */
+
+static int max9286_notify_bound(struct v4l2_async_notifier *notifier,
+				struct v4l2_subdev *subdev,
+				struct v4l2_async_subdev *asd)
+{
+	struct max9286_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max9286_sink *sink = asd_to_max9286_sink(asd);
+	int sink_pad = sink - &priv->sinks[0];
+	int src_pad;
+
+	src_pad = media_entity_get_fwnode_pad(&subdev->entity, sink->fwnode, MEDIA_PAD_FL_SOURCE);
+	if (src_pad < 0) {
+		dev_err(&priv->client->dev, "Failed to find pad for %s\n", subdev->name);
+		return src_pad;
+	}
+
+	sink->sd = subdev;
+
+	dev_dbg(&priv->client->dev, "Bound %s:%u -> %s:%u\n",
+		subdev->name, src_pad, priv->sd.name, sink_pad);
+
+	return media_create_pad_link(&subdev->entity, src_pad,
+				     &priv->sd.entity, sink_pad,
+				     MEDIA_LNK_FL_ENABLED |
+				     MEDIA_LNK_FL_IMMUTABLE);
+}
+
+static void max9286_notify_unbind(struct v4l2_async_notifier *notifier,
+				  struct v4l2_subdev *subdev,
+				  struct v4l2_async_subdev *asd)
+{
+	struct max9286_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max9286_sink *sink = asd_to_max9286_sink(asd);
+
+	sink->sd = NULL;
+
+	dev_dbg(&priv->client->dev, "Unbind %s\n", subdev->name);
+}
+
+static const struct v4l2_async_notifier_operations max9286_notify_ops = {
+	.bound = max9286_notify_bound,
+	.unbind = max9286_notify_unbind,
+};
+
+static int max9286_v4l2_init(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	struct device_node *ep;
+	unsigned int i;
+	int err;
+
+	v4l2_async_notifier_init(&priv->notifier);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!(priv->links_mask & (1 << i)))
+			continue;
+		err = v4l2_async_notifier_add_subdev(&priv->notifier, priv->subdevs[i]);
+		if (err < 0)
+			return err;
+	}
+
+	priv->notifier.ops = &max9286_notify_ops;
+	err = v4l2_async_subdev_notifier_register(&priv->sd, &priv->notifier);
+	if (err < 0)
+		return err;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &max9286_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* CSI2_RATE = PCLK*bpp*n_links/lanes*/
+	priv->pixel_rate = priv->pclk * 2 * dt2bpp[priv->dt] / 8 * hweight8(priv->links_mask) / priv->lanes * 1000000;
+	v4l2_ctrl_handler_init(&priv->ctrls, 1);
+	v4l2_ctrl_new_std(&priv->ctrls, NULL, V4L2_CID_PIXEL_RATE,
+			  priv->pixel_rate, priv->pixel_rate, 1, priv->pixel_rate);
+	priv->sd.ctrl_handler = &priv->ctrls;
+	err = priv->ctrls.error;
+	if (err)
+		return err;
+
+	/* Pads init */
+	priv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	priv->pads[MAX9286_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	priv->pads[MAX9286_SINK_LINK0].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX9286_SINK_LINK1].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX9286_SINK_LINK2].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX9286_SINK_LINK3].flags = MEDIA_PAD_FL_SINK;
+	err = media_entity_pads_init(&priv->sd.entity, MAX9286_N_PADS, priv->pads);
+	if (err)
+		return err;
+
+	/* Subdevice register */
+	ep = of_graph_get_endpoint_by_regs(client->dev.of_node, MAX9286_SOURCE, -1);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to retrieve endpoint on \"port@4\"\n");
+		return -ENOENT;
+	}
+	priv->sd.fwnode = of_fwnode_handle(ep);
+	v4l2_set_subdevdata(&priv->sd, priv);
+
+	of_node_put(ep);
+
+	err = v4l2_async_register_subdev(&priv->sd);
+	if (err < 0) {
+		dev_err(&client->dev, "Unable to register subdevice\n");
+		goto err_put_node;
+	}
+
+	return 0;
+
+err_put_node:
+	of_node_put(ep);
+	return err;
+}
+
+static int max9286_parse_dt(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	struct device_node *np = client->dev.of_node;
+	struct device_node *endpoint = NULL;
+	int err, pwen, i;
+	int sensor_delay, gpio0 = 1, gpio1 = 1;
+	u8 val = 0;
+	u32 addrs[4], naddrs;
+
+	i = of_property_match_string(np, "reg-names", "max9286");
+	if (i >= 0)
+		of_property_read_u32_index(np, "reg", i, (unsigned int *)&client->addr);
+	priv->des_addr = client->addr;
+
+	naddrs = of_property_count_elems_of_size(np, "regs", sizeof(u32));
+	err = of_property_read_u32_array(client->dev.of_node, "regs", addrs,
+					 naddrs);
+	if (err < 0) {
+		dev_err(&client->dev, "Invalid DT regs property\n");
+		return -EINVAL;
+	}
+
+	priv->n_links = naddrs;
+	memcpy(priv->ser_addr, addrs, naddrs * sizeof(u32));
+
+	pwen = of_get_gpio(np, 0);
+	if (pwen > 0) {
+		err = gpio_request_one(pwen, GPIOF_OUT_INIT_HIGH, dev_name(&client->dev));
+		if (err)
+			dev_err(&client->dev, "cannot request PWEN gpio %d: %d\n", pwen, err);
+	}
+
+	mdelay(250);
+
+	for (i = 0; i < priv->n_links; i++) {
+		char poc_name[10];
+
+		sprintf(poc_name, "poc%d", i);
+		priv->poc_reg[i] = devm_regulator_get(&client->dev, poc_name);
+		if (PTR_ERR(priv->poc_reg[i]) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+	}
+
+	reg8_read(client, 0x1e, &val); /* read max9286 ID */
+	if (val != MAX9286_ID)
+		return -ENODEV;
+
+	if (!of_property_read_u32(np, "maxim,gpio0", &gpio0) ||
+	    !of_property_read_u32(np, "maxim,gpio1", &gpio1))
+		reg8_write(client, 0x0f, 0x08 | (gpio1 << 1) | gpio0);
+
+	if (of_property_read_u32(np, "maxim,resetb-gpio", &priv->gpio_resetb)) {
+		priv->gpio_resetb = -1;
+	} else {
+		if (of_property_read_bool(np, "maxim,resetb-active-high"))
+			priv->active_low_resetb = 0;
+		else
+			priv->active_low_resetb = 1;
+	}
+
+	if (!of_property_read_u32(np, "maxim,sensor_delay", &sensor_delay))
+		mdelay(sensor_delay);
+	if (of_property_read_string(np, "maxim,fsync-mode", &priv->fsync_mode))
+		priv->fsync_mode = fsync_mode_default;
+	if (of_property_read_u32(np, "maxim,fsync-period", &priv->fsync_period))
+		priv->fsync_period = 3200000;			/* 96MHz/30fps */
+	priv->pclk_rising_edge = true;
+	if (of_property_read_bool(np, "maxim,pclk-falling-edge"))
+		priv->pclk_rising_edge = false;
+	if (of_property_read_u32(np, "maxim,timeout", &priv->timeout))
+		priv->timeout = 100;
+	if (of_property_read_u32(np, "maxim,i2c-quirk", &priv->des_quirk_addr))
+		priv->des_quirk_addr = 0;
+	if (of_property_read_u32(np, "maxim,him", &priv->him))
+		priv->him = 0;
+	if (of_property_read_u32(np, "maxim,hsync", &priv->hsync))
+		priv->hsync = 0;
+	if (of_property_read_u32(np, "maxim,vsync", &priv->vsync))
+		priv->vsync = 1;
+	if (of_property_read_u32(np, "maxim,poc-delay", &priv->poc_delay))
+		priv->poc_delay = 50;
+	if (of_property_read_u32(np, "maxim,bws", &priv->bws))
+		priv->bws = 0;
+	if (of_property_read_u32(np, "maxim,dbl", &priv->dbl))
+		priv->dbl = 1;
+	if (of_property_read_u32(np, "maxim,dt", &priv->dt))
+		priv->dt = 3;
+	if (of_property_read_u32(np, "maxim,hsgen", &priv->hsgen))
+		priv->hsgen = 0;
+	if (of_property_read_u32(np, "maxim,pclk", &priv->pclk))
+		priv->pclk = pclk;
+	if (of_property_read_u32(np, "maxim,switchin", &priv->switchin))
+		priv->switchin = 0;
+	if (of_property_read_u64(np, "maxim,crossbar", &priv->crossbar))
+		priv->crossbar = crossbar;
+
+	/* module params override dts */
+	if (him)
+		priv->him = him;
+	if (fsync_period) {
+		priv->fsync_period = fsync_period;
+		priv->fsync_mode = fsync_mode_default;
+	}
+	if (hsync)
+		priv->hsync = hsync;
+	if (!vsync)
+		priv->vsync = vsync;
+	if (gpio_resetb)
+		priv->gpio_resetb = gpio_resetb;
+	if (active_low_resetb)
+		priv->active_low_resetb = active_low_resetb;
+	if (timeout_n)
+		priv->timeout = timeout_n;
+	if (poc_delay)
+		priv->poc_delay = poc_delay;
+	if (bws)
+		priv->bws = bws;
+	if (!dbl)
+		priv->dbl = dbl;
+	if (dt != 3)
+		priv->dt = dt;
+	if (hsgen)
+		priv->hsgen = hsgen;
+	if (pclk != 100)
+		priv->pclk = pclk;
+	if (switchin)
+		priv->switchin = switchin;
+
+	/* parse crossbar setup */
+	for (i = 0; i < 16; i++) {
+		priv->cb[i] = priv->crossbar % 16;
+		priv->crossbar /= 16;
+	}
+
+	for_each_endpoint_of_node(np, endpoint) {
+		struct max9286_sink *sink;
+		struct of_endpoint ep;
+
+		of_graph_parse_endpoint(endpoint, &ep);
+		dev_dbg(&client->dev, "Endpoint %pOF on port %d", ep.local_node, ep.port);
+
+		if (ep.port > MAX9286_N_LINKS) {
+			dev_err(&client->dev, "Invalid endpoint %s on port %d",
+				of_node_full_name(ep.local_node), ep.port);
+			continue;
+		}
+
+		if (ep.port == MAX9286_SOURCE) {
+			struct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = 0 };
+
+			err = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint), &v4l2_ep);
+			if (err) {
+				of_node_put(endpoint);
+				return err;
+			}
+
+			if (v4l2_ep.bus_type != V4L2_MBUS_CSI2_DPHY) {
+				dev_err(&client->dev, "Unsupported bus: %u\n", v4l2_ep.bus_type);
+				of_node_put(endpoint);
+				return -EINVAL;
+			}
+
+			priv->lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;
+
+			continue;
+		}
+
+		sink = &priv->sinks[ep.port];
+		sink->fwnode = fwnode_graph_get_remote_endpoint(of_fwnode_handle(endpoint));
+		if (!sink->fwnode) {
+			dev_err(&client->dev, "Endpoint %pOF has no remote endpoint connection\n", ep.local_node);
+			continue;
+		}
+
+		sink->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+		sink->asd.match.fwnode = sink->fwnode;
+
+		priv->subdevs[priv->nsinks] = &sink->asd;
+		priv->nsinks++;
+	}
+
+	of_node_put(endpoint);
+
+	return 0;
+}
+
+static int max9286_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+	struct max9286_priv *priv;
+	int err;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, priv);
+	priv->client = client;
+	atomic_set(&priv->use_count, 0);
+	priv->csi2_outord = 0xff;
+
+	err = max9286_parse_dt(client);
+	if (err)
+		goto out;
+
+	err = max9286_i2c_mux_init(priv);
+	if (err) {
+		dev_err(&client->dev, "Unable to initialize I2C multiplexer\n");
+		goto out;
+	}
+
+	err = max9286_initialize(client);
+	if (err < 0)
+		goto out;
+
+	err = max9286_v4l2_init(client);
+	if (err < 0)
+		goto out;
+
+	/* FIXIT: v4l2_i2c_subdev_init re-assigned clientdata */
+	i2c_set_clientdata(client, priv);
+	max9286_post_initialize(client);
+
+	priv->reboot_notifier.notifier_call = max9286_reboot_notifier;
+	err = register_reboot_notifier(&priv->reboot_notifier);
+	if (err) {
+		dev_err(&client->dev, "failed to register reboot notifier\n");
+		goto out;
+	}
+
+	err = sysfs_create_group(&client->dev.kobj, &max9286_group);
+	if (err < 0)
+		dev_err(&client->dev, "Sysfs registration failed\n");
+
+out:
+	return err;
+}
+
+static int max9286_remove(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	int i;
+
+	sysfs_remove_group(&client->dev.kobj,  &max9286_group);
+	unregister_reboot_notifier(&priv->reboot_notifier);
+
+	i2c_mux_del_adapters(priv->mux);
+	v4l2_async_notifier_unregister(&priv->notifier);
+	v4l2_async_notifier_cleanup(&priv->notifier);
+	v4l2_async_unregister_subdev(&priv->sd);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i]))
+			regulator_disable(priv->poc_reg[i]); /* POC power off */
+	}
+
+	return 0;
+}
+
+static const struct of_device_id max9286_dt_ids[] = {
+	{ .compatible = "maxim,max9286" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, max9286_dt_ids);
+
+static const struct i2c_device_id max9286_id[] = {
+	{ "max9286", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max9286_id);
+
+static struct i2c_driver max9286_i2c_driver = {
+	.driver	= {
+		.name		= "max9286",
+		.of_match_table	= of_match_ptr(max9286_dt_ids),
+	},
+	.probe		= max9286_probe,
+	.remove		= max9286_remove,
+	.id_table	= max9286_id,
+};
+
+module_i2c_driver(max9286_i2c_driver);
+
+MODULE_DESCRIPTION("GMSL driver for MAX9286");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/gmsl/max9286_debug.h b/drivers/media/i2c/gmsl/max9286_debug.h
new file mode 100644
index 0000000..ef00efd
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max9286_debug.h
@@ -0,0 +1,89 @@
+/*
+ * MAXIM max9286 GMSL driver
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+static const char *line_status[] =
+{
+	"BAT",
+	"GND",
+	"NORMAL",
+	"OPEN"
+};
+
+static ssize_t max9286_link_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int i = -1;
+	u8 val = 0;
+	bool lenghterr, linebuffof, hlocked, prbsok, vsyncdet, configdet, videodet;
+	int lf;
+	u8 prbserr = 0, deterr = 0, correrr = 0;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+
+	if (!sscanf(attr->attr.name, "link_%d", &i))
+		return -EINVAL;
+
+	if ((i < 0) || (i > 3))
+		return -EINVAL;
+
+	reg8_read(client, 0x20, &val);
+	lf = (val >> (2 * i)) & 0x03;
+
+	reg8_read(client, 0x21, &val);
+	hlocked = !!(val & (1 << i));
+	prbsok = !!(val & (1 << (i + 4)));
+
+	reg8_read(client, 0x22, &val);
+	lenghterr = !!(val & (1 << i));
+	linebuffof = !!(val & (1 << (i + 4)));
+
+	reg8_read(client, 0x23 + i, &prbserr);
+	priv->prbserr[i] += prbserr;
+
+	reg8_read(client, 0x27, &val);
+	vsyncdet = !!(val & (1 << i));
+
+	reg8_read(client, 0x28 + i, &deterr);
+	priv->deterr[i] += deterr;
+
+	reg8_read(client, 0x2c + i, &correrr);
+	priv->correrr[i] += correrr;
+
+	reg8_read(client, 0x49, &val);
+	configdet = !!(val & (1 << i));
+	videodet = !!(val & (1 << (i + 4)));
+
+	return sprintf(buf, "LINK:%d LF:%s HLOCKED:%d PRBSOK:%d LINBUFFOF:%d"
+		" LENGHTERR:%d VSYNCDET:%d CONFIGDET:%d VIDEODET:%d"
+		" PRBSERR:%d(%d) DETEERR:%d(%d) CORRERR:%d(%d)\n",
+		i, line_status[lf], hlocked, prbsok, lenghterr,
+		linebuffof, vsyncdet, configdet, videodet,
+		priv->prbserr[i], prbserr,
+		priv->deterr[i], deterr,
+		priv->correrr[i], correrr);
+}
+
+static DEVICE_ATTR(link_0, S_IRUGO, max9286_link_show, NULL);
+static DEVICE_ATTR(link_1, S_IRUGO, max9286_link_show, NULL);
+static DEVICE_ATTR(link_2, S_IRUGO, max9286_link_show, NULL);
+static DEVICE_ATTR(link_3, S_IRUGO, max9286_link_show, NULL);
+
+static struct attribute *max9286_attributes_links[] = {
+	&dev_attr_link_0.attr,
+	&dev_attr_link_1.attr,
+	&dev_attr_link_2.attr,
+	&dev_attr_link_3.attr,
+	NULL
+};
+
+static const struct attribute_group max9286_group = {
+	.attrs = max9286_attributes_links,
+};
diff --git a/drivers/media/i2c/gmsl/max9295.h b/drivers/media/i2c/gmsl/max9295.h
new file mode 100644
index 0000000..864c441
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max9295.h
@@ -0,0 +1,39 @@
+/*
+ * MAXIM max9295 GMSL2 driver header
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define MAX9295_REG2			0x02
+#define MAX9295_REG7			0x07
+#define MAX9295_CTRL0			0x10
+#define MAX9295_I2C2			0x42
+#define MAX9295_I2C3			0x43
+#define MAX9295_I2C4			0x44
+#define MAX9295_I2C5			0x45
+#define MAX9295_I2C6			0x46
+
+#define MAX9295_CROSS(n)		(0x1b0 + n)
+
+#define MAX9295_GPIO_A(n)		(0x2be + (3 * n))
+#define MAX9295_GPIO_B(n)		(0x2bf + (3 * n))
+#define MAX9295_GPIO_C(n)		(0x2c0 + (3 * n))
+
+#define MAX9295_VIDEO_TX_BASE(n)	(0x100 + (0x8 * n))
+#define MAX9295_VIDEO_TX0(n)		(MAX9295_VIDEO_TX_BASE(n) + 0)
+#define MAX9295_VIDEO_TX1(n)		(MAX9295_VIDEO_TX_BASE(n) + 1)
+
+#define MAX9295_FRONTTOP_0		0x308
+#define MAX9295_FRONTTOP_9		0x311
+#define MAX9295_FRONTTOP_12		0x314
+#define MAX9295_FRONTTOP_13		0x315
+
+#define MAX9295_MIPI_RX0		0x330
+#define MAX9295_MIPI_RX1		0x331
+#define MAX9295_MIPI_RX2		0x332
+#define MAX9295_MIPI_RX3		0x333
\ No newline at end of file
diff --git a/drivers/media/i2c/imagers/Kconfig b/drivers/media/i2c/imagers/Kconfig
new file mode 100644
index 0000000..8bd402f
--- /dev/null
+++ b/drivers/media/i2c/imagers/Kconfig
@@ -0,0 +1,13 @@
+#
+# LVDS camera video device configuration
+#
+
+config VIDEO_LVDS_CAMERA
+	tristate "LVDS camera support"
+	depends on I2C && VIDEO_V4L2_SUBDEV_API && MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a GMSL/FPDLink cameras support
+
+	  This camera should be used in conjunction with a GMSL or
+	  or FPDLink deserialiser
diff --git a/drivers/media/i2c/imagers/Makefile b/drivers/media/i2c/imagers/Makefile
new file mode 100644
index 0000000..3d012a0
--- /dev/null
+++ b/drivers/media/i2c/imagers/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+#obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ap0101_ar014x.o
+#obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ap0201_ar023x.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov10635.o
+#obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov2311.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov490.o
+#obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= dummy.o
diff --git a/drivers/media/i2c/imagers/ov10635.c b/drivers/media/i2c/imagers/ov10635.c
new file mode 100644
index 0000000..00507ba
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov10635.c
@@ -0,0 +1,702 @@
+/*
+ * OmniVision ov10635 sensor camera driver
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "ov10635.h"
+
+#define OV10635_I2C_ADDR		0x30
+
+#define OV10635_PID_REGA		0x300a
+#define OV10635_PID_REGB		0x300b
+#define OV10635_PID			0xa635
+
+#define OV10635_MEDIA_BUS_FMT		MEDIA_BUS_FMT_UYVY8_2X8
+
+struct ov10635_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				subsampling;
+	int				fps_denominator;
+	int				init_complete;
+	u8				id[6];
+	int				dvp_order;
+	int				vsync;
+	/* serializers */
+	int				ser_addr;
+};
+
+static int dvp_order = 0;
+module_param(dvp_order, int, 0644);
+MODULE_PARM_DESC(dvp_order, " DVP bus bits order");
+
+static int vsync = 0;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 0 - not inverted)");
+
+static inline struct ov10635_priv *to_ov10635(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov10635_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov10635_priv, hdl)->sd;
+}
+
+static int ov10635_set_regs(struct i2c_client *client,
+			    const struct ov10635_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (reg16_write(client, regs[i].reg, regs[i].val)) {
+			usleep_range(100, 150); /* wait 100ns */
+			if (reg16_write(client, regs[i].reg, regs[i].val))
+				printk("ov10635 reg 0x%04x write failed\n", regs[i].reg);
+		}
+	}
+
+	return 0;
+}
+
+static void ov10635_otp_id_read(struct i2c_client *client)
+{
+	struct ov10635_priv *priv = to_ov10635(client);
+	int i;
+
+	/* read camera id from OTP memory */
+	reg16_write(client, 0x3d10, 1);
+
+	usleep_range(15000, 16000); /* wait 15ms */
+
+	for (i = 0; i < 6; i++)
+		reg16_read(client, 0x3d00 + i, &priv->id[i]);
+}
+
+static int ov10635_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ov10635_set_window(struct v4l2_subdev *sd, int subsampling)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	/* disable clocks */
+	reg16_write(client, 0x302e, 0x00);
+	reg16_write(client, 0x301b, 0xff);
+	reg16_write(client, 0x301c, 0xff);
+	reg16_write(client, 0x301a, 0xff);
+
+	/* setup resolution */
+	reg16_write(client, 0x3808, priv->rect.width >> 8);
+	reg16_write(client, 0x3809, priv->rect.width & 0xff);
+	reg16_write(client, 0x380a, priv->rect.height >> 8);
+	reg16_write(client, 0x380b, priv->rect.height & 0xff);
+
+	/* enable/disable subsampling */
+	reg16_write(client, 0x5005, subsampling ? 0x89 : 0x08);
+	reg16_write(client, 0x3007, subsampling ? 0x02 : 0x01);
+	reg16_write(client, 0x4004, subsampling ? 0x02 : 0x04);
+
+#if 0 /* This is implemented in VIN via SOC_CAMERA layer, hence skip */
+	/* horiz crop start */
+	reg16_write(client, 0x3800, priv->rect.left >> 8);
+	reg16_write(client, 0x3801, priv->rect.left & 0xff);
+	/* horiz crop end */
+	reg16_write(client, 0x3804, (priv->rect.left + priv->rect.width + 1) >> 8);
+	reg16_write(client, 0x3805, (priv->rect.left + priv->rect.width + 1) & 0xff);
+	/* vert crop start */
+	reg16_write(client, 0x3802, priv->rect.top >> 8);
+	reg16_write(client, 0x3803, priv->rect.top & 0xff);
+	/* vert crop end */
+	reg16_write(client, 0x3806, (priv->rect.top + priv->rect.height + 1) >> 8);
+	reg16_write(client, 0x3807, (priv->rect.top + priv->rect.height + 1) & 0xff);
+#endif
+	/* enable clocks */
+	reg16_write(client, 0x301b, 0xf0);
+	reg16_write(client, 0x301c, 0xf0);
+	reg16_write(client, 0x301a, 0xf0);
+	reg16_write(client, 0x302e, 0x01);
+
+	return 0;
+};
+
+static int ov10635_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = OV10635_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov10635_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = OV10635_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ov10635_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = OV10635_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ov10635_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = OV10635_PID >> 8;
+	edid->edid[9] = OV10635_PID & 0xff;
+
+	return 0;
+}
+
+static int ov10635_set_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+	int subsampling = 0;
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > OV10635_MAX_WIDTH) ||
+	    (rect->top + rect->height > OV10635_MAX_HEIGHT))
+		*rect = priv->rect;
+
+	if (rect->width == OV10635_MAX_WIDTH / 2 &&
+	    rect->height == OV10635_MAX_HEIGHT / 2)
+		subsampling = 1;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	/* change window only for subsampling, crop is done by VIN */
+	if (subsampling != priv->subsampling) {
+		ov10635_set_window(sd, subsampling);
+		priv->subsampling = subsampling;
+	}
+
+	return 0;
+}
+
+static int ov10635_get_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = OV10635_MAX_WIDTH;
+		sel->r.height = OV10635_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = OV10635_MAX_WIDTH;
+		sel->r.height = OV10635_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ov10635_g_mbus_config(struct v4l2_subdev *sd,
+				 struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+static int ov10635_g_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *ival)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	ival->interval.numerator = 1;
+	ival->interval.denominator = priv->fps_denominator;
+
+	return 0;
+}
+
+static int ov10635_s_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *ival)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+	int ret = 0;
+
+	if (priv->fps_denominator != ival->interval.denominator) {
+		switch (ival->interval.denominator) {
+		case 5:
+			ret = ov10635_set_regs(client, ov10635_regs_5fps,
+					       ARRAY_SIZE(ov10635_regs_5fps));
+			break;
+		case 10:
+			ret = ov10635_set_regs(client, ov10635_regs_10fps,
+					       ARRAY_SIZE(ov10635_regs_10fps));
+			break;
+		case 15:
+			ret = ov10635_set_regs(client, ov10635_regs_15fps,
+					       ARRAY_SIZE(ov10635_regs_15fps));
+			break;
+		case 30:
+			ret = ov10635_set_regs(client, ov10635_regs_30fps,
+					       ARRAY_SIZE(ov10635_regs_30fps));
+			break;
+		default:
+			ret = -EINVAL;
+			goto out;
+		}
+
+		priv->fps_denominator = ival->interval.denominator;
+	}
+out:
+	return ret;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov10635_g_register(struct v4l2_subdev *sd,
+			      struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	__be64 be_val;
+
+	if (!reg->size)
+		reg->size = sizeof(u8);
+	if (reg->size > sizeof(reg->val))
+		reg->size = sizeof(reg->val);
+
+	ret = reg16_read_n(client, (u16)reg->reg, (u8*)&be_val, reg->size);
+	be_val = be_val << ((sizeof(be_val) - reg->size) * 8);
+	reg->val = be64_to_cpu(be_val);
+
+	return ret;
+}
+
+static int ov10635_s_register(struct v4l2_subdev *sd,
+			      const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 size = reg->size;
+	int ret;
+	__be64 be_val;
+
+	if (!size)
+		size = sizeof(u8);
+	if (size > sizeof(reg->val))
+		size = sizeof(reg->val);
+
+	be_val = cpu_to_be64(reg->val);
+	be_val = be_val >> ((sizeof(be_val) - size) * 8);
+	ret = reg16_write_n(client, (u16)reg->reg, (u8*)&be_val, size);
+
+	return ret;
+}
+#endif
+
+static struct v4l2_subdev_core_ops ov10635_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ov10635_g_register,
+	.s_register = ov10635_s_register,
+#endif
+};
+
+static int ov10635_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+	int ret = -EINVAL;
+	u8 val = 0;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		/* AEC/AGC target */
+		ret = reg16_write(client, 0xc46a, ctrl->val);
+		break;
+	case V4L2_CID_CONTRAST:
+		udelay(100);
+		ret = ov10635_set_regs(client, &ov10635_regs_contrast[ctrl->val][0], 18);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = reg16_write(client, 0xc316, ctrl->val);
+		break;
+	case V4L2_CID_HUE:
+		/* CMX ? */
+		ret = 0;
+		break;
+	case V4L2_CID_GAMMA:
+		ret = reg16_write(client, 0xc4be, ctrl->val >> 8);
+		ret |= reg16_write(client, 0xc4bf, ctrl->val & 0xff);
+		break;
+	case V4L2_CID_AUTOGAIN:
+		/* automatic gain/exposure */
+		ret = reg16_write(client, 0x56d0, !ctrl->val);
+		break;
+	case V4L2_CID_GAIN:
+		/* manual gain */
+		ret = reg16_write(client, 0x3504, 0);
+		ret |= reg16_write(client, 0x56d1, ctrl->val >> 8);
+		ret |= reg16_write(client, 0x56d2, ctrl->val & 0xff);
+		ret |= reg16_write(client, 0x3504, 1); /* validate gain */
+		break;
+	case V4L2_CID_EXPOSURE:
+		/* manual exposure */
+		ret = reg16_write(client, 0x3504, 0);
+		ret |= reg16_write(client, 0x56d5, ctrl->val >> 8);
+		ret |= reg16_write(client, 0x56d6, ctrl->val & 0xff);
+		ret |= reg16_write(client, 0x3504, 1); /* validate exposure */
+		break;
+	case V4L2_CID_HFLIP:
+		ret = reg16_read(client, 0x381d, &val);
+		if (ctrl->val)
+			val |= 0x3;
+		else
+			val &= ~0x3;
+		ret |= reg16_write(client, 0x381d, val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = reg16_read(client, 0x381c, &val);
+		if (ctrl->val)
+			val |= 0xc0;
+		else
+			val &= ~0xc0;
+		ret |= reg16_write(client, 0x381c, val);
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov10635_ctrl_ops = {
+	.s_ctrl = ov10635_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ov10635_video_ops = {
+	.s_stream	= ov10635_s_stream,
+	.g_mbus_config	= ov10635_g_mbus_config,
+	.g_frame_interval = ov10635_g_frame_interval,
+	.s_frame_interval = ov10635_s_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops ov10635_subdev_pad_ops = {
+	.get_edid	= ov10635_get_edid,
+	.enum_mbus_code	= ov10635_enum_mbus_code,
+	.get_selection	= ov10635_get_selection,
+	.set_selection	= ov10635_set_selection,
+	.get_fmt	= ov10635_get_fmt,
+	.set_fmt	= ov10635_set_fmt,
+};
+
+static struct v4l2_subdev_ops ov10635_subdev_ops = {
+	.core	= &ov10635_core_ops,
+	.video	= &ov10635_video_ops,
+	.pad	= &ov10635_subdev_pad_ops,
+};
+
+static ssize_t ov10635_otp_id_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ov10635, S_IRUGO, ov10635_otp_id_show, NULL);
+
+static int ov10635_initialize(struct i2c_client *client)
+{
+	struct ov10635_priv *priv = to_ov10635(client);
+	u8 val = 0;
+	u16 pid = 0;
+
+	setup_i2c_translator(client, priv->ser_addr, OV10635_I2C_ADDR);
+	udelay(100);
+
+	reg16_read(client, OV10635_PID_REGA, &val);
+	pid = val;
+	reg16_read(client, OV10635_PID_REGB, &val);
+	pid = (pid << 8) | val;
+
+	if (pid != OV10635_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	/* s/w reset sensor */
+	reg16_write(client, 0x103, 0x1);
+	udelay(100);
+	/* Program wizard registers */
+	ov10635_set_regs(client, ov10635_regs_wizard, ARRAY_SIZE(ov10635_regs_wizard));
+	/* Set DVP bit swap */
+	reg16_write(client, 0x4709, priv->dvp_order << 4);
+	/* Set VSYNC inversion */
+	reg16_write(client, 0x4708, priv->vsync ? 0x3 : 0x1);
+	/* Read OTP IDs */
+	ov10635_otp_id_read(client);
+
+	dev_info(&client->dev, "PID %x, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static const struct i2c_device_id ov10635_id[] = {
+	{ "ov10635", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov10635_id);
+
+static const struct of_device_id ov10635_of_ids[] = {
+	{ .compatible = "ovti,ov10635", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov10635_of_ids);
+
+static int ov10635_parse_dt(struct device_node *np, struct ov10635_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	u32 addrs[2], naddrs;
+	struct fwnode_handle *ep;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+	priv->ser_addr = addrs[1];
+
+	if (of_property_read_u32(np, "dvp-order", &priv->dvp_order))
+		priv->dvp_order = 0;
+	if (of_property_read_u32(np, "vsync", &priv->vsync))
+		priv->vsync = 0;
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	/* module params override dts */
+	if (dvp_order)
+		priv->dvp_order = dvp_order;
+	if (vsync)
+		priv->vsync = vsync;
+
+	return 0;
+}
+
+static int ov10635_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+	struct ov10635_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ov10635_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = OV10635_MAX_WIDTH;
+	priv->rect.height = OV10635_MAX_HEIGHT;
+	priv->fps_denominator = 30;
+
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 0xff, 1, 0x30);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 4, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 0xff, 1, 0xff);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_HUE, 0, 255, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_GAMMA, 0, 0xffff, 1, 0x233);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0x3ff, 1, 0x10);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, 0x80);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ov10635_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ov10635_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ov10635) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ov10635_remove(struct i2c_client *client)
+{
+	struct ov10635_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ov10635);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static struct i2c_driver ov10635_i2c_driver = {
+	.driver	= {
+		.name		= "ov10635",
+		.of_match_table	= ov10635_of_ids,
+	},
+	.probe		= ov10635_probe,
+	.remove		= ov10635_remove,
+	.id_table	= ov10635_id,
+};
+
+module_i2c_driver(ov10635_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for OV10635");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/ov10635.h b/drivers/media/i2c/imagers/ov10635.h
new file mode 100644
index 0000000..cf2ce07
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov10635.h
@@ -0,0 +1,1143 @@
+/*
+ * OmniVision ov10635 sensor camera wizard 1280x800@30/UYVY/BT601/8bit
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+//#define OV10635_DISPLAY_PATTERN
+
+#define OV10635_SENSOR_WIDTH		1312
+#define OV10635_SENSOR_HEIGHT		814
+
+#define OV10635_MAX_WIDTH		1280
+#define OV10635_MAX_HEIGHT		800
+
+#define OV10635_PCLK_96MHZ
+//#define OV10635_PCLK_88MHZ
+
+#if defined(OV10635_PCLK_96MHZ)
+/* VTS=PCLK/FPS/HTS/2 (=96MHz/30/1750/2) */
+ #define OV10635_HTS			1750
+ #define OV10635_VTS			914 /* fps=30 */
+#elif defined(OV10635_PCLK_88MHZ)
+/* VTS=PCLK/FPS/HTS/2 (=88MHz/1572/30/2) */
+ #define OV10635_HTS			1572
+ #define OV10635_VTS			933 /* fps=29.9998 */
+#else
+ #error PCLK not defined
+#endif
+
+struct ov10635_reg {
+	u16	reg;
+	u8	val;
+};
+
+static const struct ov10635_reg ov10635_regs_wizard[] = {
+//{0x0103, 0x01},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x301B, 0xFF},
+{0x301C, 0xFF},
+{0x301A, 0xFF},
+{0x3011, 0x42},
+{0x6900, 0x0C},
+{0x6901, 0x19},
+{0x3503, 0x10},
+{0x3025, 0x03},
+#if defined(OV10635_PCLK_96MHZ)
+{0x3003, 0x20},
+{0x3004, 0x21},
+#elif defined(OV10635_PCLK_88MHZ)
+{0x3003, 0x16},
+{0x3004, 0x30},
+#endif
+{0x3005, 0x40},
+{0x3006, 0x91},
+{0x3600, 0x74},
+{0x3601, 0x2B},
+{0x3612, 0x00},
+{0x3611, 0x67},
+{0x3633, 0xCA},
+{0x3602, 0xAF},
+{0x3603, 0x04},
+{0x3630, 0x28},
+{0x3631, 0x16},
+{0x3714, 0x10},
+{0x371D, 0x01},
+{0x4300, 0x3A},
+{0x3007, 0x01},
+{0x3024, 0x03},
+{0x3020, 0x0A},
+{0x3702, 0x0D},
+{0x3703, 0x20},
+{0x3704, 0x15},
+{0x3709, 0xA8},
+{0x370C, 0xC7},
+{0x370D, 0x80},
+{0x3712, 0x00},
+{0x3713, 0x20},
+{0x3715, 0x04},
+{0x381D, 0x40},
+{0x381C, 0x00},
+{0x3822, 0x50},
+{0x3824, 0x10},
+{0x3815, 0x8C},
+{0x3804, 0x05},
+{0x3805, 0x1F},
+{0x3800, 0x00},
+{0x3801, 0x00},
+{0x3806, 0x03},
+{0x3807, 0x28},
+{0x3802, 0x00},
+{0x3803, 0x07},
+{0x3808, 0x05},
+{0x3809, 0x00},
+{0x380A, 0x03},
+{0x380B, 0x20},
+{0x380C, OV10635_HTS >> 8},
+{0x380D, OV10635_HTS & 0xff},
+{0x380E, OV10635_VTS >> 8},
+{0x380F, OV10635_VTS & 0xff},
+{0x3813, 0x02},
+{0x3811, 0x08},
+{0x381F, 0x0C},
+{0x3819, 0x04},
+{0x3804, 0x01},
+{0x3805, 0x00},
+{0x3828, 0x03},
+{0x3829, 0x10},
+{0x382A, 0x10},
+{0x3621, 0x63},
+{0x5005, 0x08},
+{0x56D5, 0x00},
+{0x56D6, 0x80},
+{0x56D7, 0x00},
+{0x56D8, 0x00},
+{0x56D9, 0x00},
+{0x56DA, 0x80},
+{0x56DB, 0x00},
+{0x56DC, 0x00},
+{0x56E8, 0x00},
+{0x56E9, 0x7F},
+{0x56EA, 0x00},
+{0x56EB, 0x7F},
+{0x5100, 0x00},
+{0x5101, 0x80},
+{0x5102, 0x00},
+{0x5103, 0x80},
+{0x5104, 0x00},
+{0x5105, 0x80},
+{0x5106, 0x00},
+{0x5107, 0x80},
+{0x5108, 0x00},
+{0x5109, 0x00},
+{0x510A, 0x00},
+{0x510B, 0x00},
+{0x510C, 0x00},
+{0x510D, 0x00},
+{0x510E, 0x00},
+{0x510F, 0x00},
+{0x5110, 0x00},
+{0x5111, 0x80},
+{0x5112, 0x00},
+{0x5113, 0x80},
+{0x5114, 0x00},
+{0x5115, 0x80},
+{0x5116, 0x00},
+{0x5117, 0x80},
+{0x5118, 0x00},
+{0x5119, 0x00},
+{0x511A, 0x00},
+{0x511B, 0x00},
+{0x511C, 0x00},
+{0x511D, 0x00},
+{0x511E, 0x00},
+{0x511F, 0x00},
+{0x56D0, 0x00},
+{0x5006, 0x04},
+{0x5608, 0x05},
+{0x52D7, 0x06},
+{0x528D, 0x08},
+{0x5293, 0x12},
+{0x52D3, 0x12},
+{0x5288, 0x06},
+{0x5289, 0x20},
+{0x52C8, 0x06},
+{0x52C9, 0x20},
+{0x52CD, 0x04},
+{0x5381, 0x00},
+{0x5382, 0xFF},
+{0x5589, 0x76},
+{0x558A, 0x47},
+{0x558B, 0xEF},
+{0x558C, 0xC9},
+{0x558D, 0x49},
+{0x558E, 0x30},
+{0x558F, 0x67},
+{0x5590, 0x3F},
+{0x5591, 0xF0},
+{0x5592, 0x10},
+{0x55A2, 0x6D},
+{0x55A3, 0x55},
+{0x55A4, 0xC3},
+{0x55A5, 0xB5},
+{0x55A6, 0x43},
+{0x55A7, 0x38},
+{0x55A8, 0x5F},
+{0x55A9, 0x4B},
+{0x55AA, 0xF0},
+{0x55AB, 0x10},
+{0x5581, 0x52},
+{0x5300, 0x01},
+{0x5301, 0x00},
+{0x5302, 0x00},
+{0x5303, 0x0E},
+{0x5304, 0x00},
+{0x5305, 0x0E},
+{0x5306, 0x00},
+{0x5307, 0x36},
+{0x5308, 0x00},
+{0x5309, 0xD9},
+{0x530A, 0x00},
+{0x530B, 0x0F},
+{0x530C, 0x00},
+{0x530D, 0x2C},
+{0x530E, 0x00},
+{0x530F, 0x59},
+{0x5310, 0x00},
+{0x5311, 0x7B},
+{0x5312, 0x00},
+{0x5313, 0x22},
+{0x5314, 0x00},
+{0x5315, 0xD5},
+{0x5316, 0x00},
+{0x5317, 0x13},
+{0x5318, 0x00},
+{0x5319, 0x18},
+{0x531A, 0x00},
+{0x531B, 0x26},
+{0x531C, 0x00},
+{0x531D, 0xDC},
+{0x531E, 0x00},
+{0x531F, 0x02},
+{0x5320, 0x00},
+{0x5321, 0x24},
+{0x5322, 0x00},
+{0x5323, 0x56},
+{0x5324, 0x00},
+{0x5325, 0x85},
+{0x5326, 0x00},
+{0x5327, 0x20},
+{0x5609, 0x01},
+{0x560A, 0x40},
+{0x560B, 0x01},
+{0x560C, 0x40},
+{0x560D, 0x00},
+{0x560E, 0xFA},
+{0x560F, 0x00},
+{0x5610, 0xFA},
+{0x5611, 0x02},
+{0x5612, 0x80},
+{0x5613, 0x02},
+{0x5614, 0x80},
+{0x5615, 0x01},
+{0x5616, 0x2C},
+{0x5617, 0x01},
+{0x5618, 0x2C},
+{0x563B, 0x01},
+{0x563C, 0x01},
+{0x563D, 0x01},
+{0x563E, 0x01},
+{0x563F, 0x03},
+{0x5640, 0x03},
+{0x5641, 0x03},
+{0x5642, 0x05},
+{0x5643, 0x09},
+{0x5644, 0x05},
+{0x5645, 0x05},
+{0x5646, 0x05},
+{0x5647, 0x05},
+{0x5651, 0x00},
+{0x5652, 0x80},
+{0x521A, 0x01},
+{0x521B, 0x03},
+{0x521C, 0x06},
+{0x521D, 0x0A},
+{0x521E, 0x0E},
+{0x521F, 0x12},
+{0x5220, 0x16},
+{0x5223, 0x02},
+{0x5225, 0x04},
+{0x5227, 0x08},
+{0x5229, 0x0C},
+{0x522B, 0x12},
+{0x522D, 0x18},
+{0x522F, 0x1E},
+{0x5241, 0x04},
+{0x5242, 0x01},
+{0x5243, 0x03},
+{0x5244, 0x06},
+{0x5245, 0x0A},
+{0x5246, 0x0E},
+{0x5247, 0x12},
+{0x5248, 0x16},
+{0x524A, 0x03},
+{0x524C, 0x04},
+{0x524E, 0x08},
+{0x5250, 0x0C},
+{0x5252, 0x12},
+{0x5254, 0x18},
+{0x5256, 0x1E},
+{0x4606, (2*OV10635_HTS) >> 8}, /* fifo_line_length = 2*hts */
+{0x4607, (2*OV10635_HTS) & 0xff},
+{0x460a, (2*(OV10635_HTS-OV10635_MAX_WIDTH)) >> 8}, /* fifo_hsync_start = 2*(hts - xres) */
+{0x460b, (2*(OV10635_HTS-OV10635_MAX_WIDTH)) & 0xff },
+{0x460C, 0x00},
+{0x4620, 0x0E},
+#if 0
+{0x4700, 0x02}, // BT656: mode is acceptable but artefact lines on left/bottom due to BT656 SAV/EAV are parsed as image data
+#else
+{0x4700, 0x04}, // BT601: 0x08 is also accaptable as HS/VS mode
+#endif
+{0x4701, 0x00},
+{0x4702, 0x01},
+{0x4004, 0x04},
+{0x4005, 0x18},
+{0x4001, 0x06},
+{0x4050, 0x22},
+{0x4051, 0x24},
+{0x4052, 0x02},
+{0x4057, 0x9C},
+{0x405A, 0x00},
+{0x4202, 0x02},
+{0x3023, 0x10},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x6F10, 0x07},
+{0x6F11, 0x82},
+{0x6F12, 0x04},
+{0x6F13, 0x00},
+{0xD000, 0x19},
+{0xD001, 0xA0},
+{0xD002, 0x00},
+{0xD003, 0x01},
+{0xD004, 0xA9},
+{0xD005, 0xAD},
+{0xD006, 0x10},
+{0xD007, 0x40},
+{0xD008, 0x44},
+{0xD009, 0x00},
+{0xD00A, 0x68},
+{0xD00B, 0x00},
+{0xD00C, 0x15},
+{0xD00D, 0x00},
+{0xD00E, 0x00},
+{0xD00F, 0x00},
+{0xD040, 0x9C},
+{0xD041, 0x21},
+{0xD042, 0xFF},
+{0xD043, 0xF8},
+{0xD044, 0xD4},
+{0xD045, 0x01},
+{0xD046, 0x48},
+{0xD047, 0x00},
+{0xD048, 0xD4},
+{0xD049, 0x01},
+{0xD04A, 0x50},
+{0xD04B, 0x04},
+{0xD04C, 0x18},
+{0xD04D, 0x60},
+{0xD04E, 0x00},
+{0xD04F, 0x01},
+{0xD050, 0xA8},
+{0xD051, 0x63},
+{0xD052, 0x02},
+{0xD053, 0xA4},
+{0xD054, 0x85},
+{0xD055, 0x43},
+{0xD056, 0x00},
+{0xD057, 0x00},
+{0xD058, 0x18},
+{0xD059, 0x60},
+{0xD05A, 0x00},
+{0xD05B, 0x01},
+{0xD05C, 0xA8},
+{0xD05D, 0x63},
+{0xD05E, 0x03},
+{0xD05F, 0xF0},
+{0xD060, 0x98},
+{0xD061, 0xA3},
+{0xD062, 0x00},
+{0xD063, 0x00},
+{0xD064, 0x8C},
+{0xD065, 0x6A},
+{0xD066, 0x00},
+{0xD067, 0x6E},
+{0xD068, 0xE5},
+{0xD069, 0x85},
+{0xD06A, 0x18},
+{0xD06B, 0x00},
+{0xD06C, 0x10},
+{0xD06D, 0x00},
+{0xD06E, 0x00},
+{0xD06F, 0x10},
+{0xD070, 0x9C},
+{0xD071, 0x80},
+{0xD072, 0x00},
+{0xD073, 0x03},
+{0xD074, 0x18},
+{0xD075, 0x60},
+{0xD076, 0x00},
+{0xD077, 0x01},
+{0xD078, 0xA8},
+{0xD079, 0x63},
+{0xD07A, 0x07},
+{0xD07B, 0x80},
+{0xD07C, 0x07},
+{0xD07D, 0xFF},
+{0xD07E, 0xF9},
+{0xD07F, 0x03},
+{0xD080, 0x8C},
+{0xD081, 0x63},
+{0xD082, 0x00},
+{0xD083, 0x00},
+{0xD084, 0xA5},
+{0xD085, 0x6B},
+{0xD086, 0x00},
+{0xD087, 0xFF},
+{0xD088, 0x18},
+{0xD089, 0x80},
+{0xD08A, 0x00},
+{0xD08B, 0x01},
+{0xD08C, 0xA8},
+{0xD08D, 0x84},
+{0xD08E, 0x01},
+{0xD08F, 0x04},
+{0xD090, 0xE1},
+{0xD091, 0x6B},
+{0xD092, 0x58},
+{0xD093, 0x00},
+{0xD094, 0x94},
+{0xD095, 0x6A},
+{0xD096, 0x00},
+{0xD097, 0x70},
+{0xD098, 0xE1},
+{0xD099, 0x6B},
+{0xD09A, 0x20},
+{0xD09B, 0x00},
+{0xD09C, 0x95},
+{0xD09D, 0x6B},
+{0xD09E, 0x00},
+{0xD09F, 0x00},
+{0xD0A0, 0xE4},
+{0xD0A1, 0x8B},
+{0xD0A2, 0x18},
+{0xD0A3, 0x00},
+{0xD0A4, 0x0C},
+{0xD0A5, 0x00},
+{0xD0A6, 0x00},
+{0xD0A7, 0x23},
+{0xD0A8, 0x15},
+{0xD0A9, 0x00},
+{0xD0AA, 0x00},
+{0xD0AB, 0x00},
+{0xD0AC, 0x18},
+{0xD0AD, 0x60},
+{0xD0AE, 0x80},
+{0xD0AF, 0x06},
+{0xD0B0, 0xA8},
+{0xD0B1, 0x83},
+{0xD0B2, 0x40},
+{0xD0B3, 0x08},
+{0xD0B4, 0xA8},
+{0xD0B5, 0xE3},
+{0xD0B6, 0x38},
+{0xD0B7, 0x2A},
+{0xD0B8, 0xA8},
+{0xD0B9, 0xC3},
+{0xD0BA, 0x40},
+{0xD0BB, 0x09},
+{0xD0BC, 0xA8},
+{0xD0BD, 0xA3},
+{0xD0BE, 0x38},
+{0xD0BF, 0x29},
+{0xD0C0, 0x8C},
+{0xD0C1, 0x65},
+{0xD0C2, 0x00},
+{0xD0C3, 0x00},
+{0xD0C4, 0xD8},
+{0xD0C5, 0x04},
+{0xD0C6, 0x18},
+{0xD0C7, 0x00},
+{0xD0C8, 0x8C},
+{0xD0C9, 0x67},
+{0xD0CA, 0x00},
+{0xD0CB, 0x00},
+{0xD0CC, 0xD8},
+{0xD0CD, 0x06},
+{0xD0CE, 0x18},
+{0xD0CF, 0x00},
+{0xD0D0, 0x18},
+{0xD0D1, 0x60},
+{0xD0D2, 0x80},
+{0xD0D3, 0x06},
+{0xD0D4, 0xA8},
+{0xD0D5, 0xE3},
+{0xD0D6, 0x67},
+{0xD0D7, 0x02},
+{0xD0D8, 0xA9},
+{0xD0D9, 0x03},
+{0xD0DA, 0x67},
+{0xD0DB, 0x03},
+{0xD0DC, 0xA8},
+{0xD0DD, 0xC3},
+{0xD0DE, 0x3D},
+{0xD0DF, 0x05},
+{0xD0E0, 0x8C},
+{0xD0E1, 0x66},
+{0xD0E2, 0x00},
+{0xD0E3, 0x00},
+{0xD0E4, 0xB8},
+{0xD0E5, 0x63},
+{0xD0E6, 0x00},
+{0xD0E7, 0x18},
+{0xD0E8, 0xB8},
+{0xD0E9, 0x63},
+{0xD0EA, 0x00},
+{0xD0EB, 0x98},
+{0xD0EC, 0xBC},
+{0xD0ED, 0x03},
+{0xD0EE, 0x00},
+{0xD0EF, 0x00},
+{0xD0F0, 0x10},
+{0xD0F1, 0x00},
+{0xD0F2, 0x00},
+{0xD0F3, 0x16},
+{0xD0F4, 0xB8},
+{0xD0F5, 0x83},
+{0xD0F6, 0x00},
+{0xD0F7, 0x19},
+{0xD0F8, 0x8C},
+{0xD0F9, 0x67},
+{0xD0FA, 0x00},
+{0xD0FB, 0x00},
+{0xD0FC, 0xB8},
+{0xD0FD, 0xA4},
+{0xD0FE, 0x00},
+{0xD0FF, 0x98},
+{0xD100, 0xB8},
+{0xD101, 0x83},
+{0xD102, 0x00},
+{0xD103, 0x08},
+{0xD104, 0x8C},
+{0xD105, 0x68},
+{0xD106, 0x00},
+{0xD107, 0x00},
+{0xD108, 0xE0},
+{0xD109, 0x63},
+{0xD10A, 0x20},
+{0xD10B, 0x04},
+{0xD10C, 0xE0},
+{0xD10D, 0x65},
+{0xD10E, 0x18},
+{0xD10F, 0x00},
+{0xD110, 0xA4},
+{0xD111, 0x83},
+{0xD112, 0xFF},
+{0xD113, 0xFF},
+{0xD114, 0xB8},
+{0xD115, 0x64},
+{0xD116, 0x00},
+{0xD117, 0x48},
+{0xD118, 0xD8},
+{0xD119, 0x07},
+{0xD11A, 0x18},
+{0xD11B, 0x00},
+{0xD11C, 0xD8},
+{0xD11D, 0x08},
+{0xD11E, 0x20},
+{0xD11F, 0x00},
+{0xD120, 0x9C},
+{0xD121, 0x60},
+{0xD122, 0x00},
+{0xD123, 0x00},
+{0xD124, 0xD8},
+{0xD125, 0x06},
+{0xD126, 0x18},
+{0xD127, 0x00},
+{0xD128, 0x00},
+{0xD129, 0x00},
+{0xD12A, 0x00},
+{0xD12B, 0x08},
+{0xD12C, 0x15},
+{0xD12D, 0x00},
+{0xD12E, 0x00},
+{0xD12F, 0x00},
+{0xD130, 0x8C},
+{0xD131, 0x6A},
+{0xD132, 0x00},
+{0xD133, 0x76},
+{0xD134, 0xBC},
+{0xD135, 0x23},
+{0xD136, 0x00},
+{0xD137, 0x00},
+{0xD138, 0x13},
+{0xD139, 0xFF},
+{0xD13A, 0xFF},
+{0xD13B, 0xE6},
+{0xD13C, 0x18},
+{0xD13D, 0x60},
+{0xD13E, 0x80},
+{0xD13F, 0x06},
+{0xD140, 0x03},
+{0xD141, 0xFF},
+{0xD142, 0xFF},
+{0xD143, 0xDD},
+{0xD144, 0xA8},
+{0xD145, 0x83},
+{0xD146, 0x40},
+{0xD147, 0x08},
+{0xD148, 0x85},
+{0xD149, 0x21},
+{0xD14A, 0x00},
+{0xD14B, 0x00},
+{0xD14C, 0x85},
+{0xD14D, 0x41},
+{0xD14E, 0x00},
+{0xD14F, 0x04},
+{0xD150, 0x44},
+{0xD151, 0x00},
+{0xD152, 0x48},
+{0xD153, 0x00},
+{0xD154, 0x9C},
+{0xD155, 0x21},
+{0xD156, 0x00},
+{0xD157, 0x08},
+{0x6F0E, 0x03},
+{0x6F0F, 0x00},
+{0x460E, 0x08},
+{0x460F, 0x01},
+{0x4610, 0x00},
+{0x4611, 0x01},
+{0x4612, 0x00},
+{0x4613, 0x01},
+{0x4605, 0x08}, // 8bit
+//{0x4709, 0x10}, // swap data bits order [9:0] -> [0:9]
+{0x4608, 0x00},
+{0x4609, 0x08},
+{0x6804, 0x00},
+{0x6805, 0x06},
+{0x6806, 0x00},
+{0x5120, 0x00},
+{0x3510, 0x00},
+{0x3504, 0x00},
+{0x6800, 0x00},
+{0x6F0D, 0x01},
+{0x4708, 0x01}, // PCLK rising edge, VSYNC active low
+{0x5000, 0xFF},
+{0x5001, 0xBF},
+{0x5002, 0x7E},
+#ifdef OV10635_DISPLAY_PATTERN
+{0x503d, 0x80},
+#else
+{0x503D, 0x00},
+#endif
+{0xC450, 0x01}, /* AA mode */
+{0xC452, 0x04},
+{0xC453, 0x00},
+{0xC454, 0x00},
+{0xC455, 0x01},
+{0xC456, 0x01},
+{0xC457, 0x00},
+{0xC458, 0x00},
+{0xC459, 0x00},
+{0xC45B, 0x00},
+{0xC45C, 0x01},
+{0xC45D, 0x00},
+{0xC45E, 0x00},
+{0xC45F, 0x00},
+{0xC460, 0x00},
+{0xC461, 0x01},
+{0xC462, 0x01},
+{0xC464, 0x03},
+{0xC465, 0x00},
+{0xC466, 0x8A},
+{0xC467, 0x00},
+{0xC468, 0x86},
+{0xC469, 0x00},
+{0xC46A, 0x30},
+{0xC46B, 0x50},
+{0xC46C, 0x30},
+{0xC46D, 0x28},
+{0xC46E, 0x60},
+{0xC46F, 0x40},
+{0xC47C, 0x01},
+{0xC47D, 0x38},
+{0xC47E, 0x00},
+{0xC47F, 0x00},
+{0xC480, 0x00},
+{0xC481, 0xFF},
+{0xC482, 0x00},
+{0xC483, 0x40},
+{0xC484, 0x00},
+{0xC485, 0x18},
+{0xC486, 0x00},
+{0xC487, 0x18},
+{0xC488, (OV10635_VTS-8)*16 >> 8},
+{0xC489, (OV10635_VTS-8)*16 & 0xff},
+{0xC48A, (OV10635_VTS-8)*16 >> 8},
+{0xC48B, (OV10635_VTS-8)*16 & 0xff},
+{0xC48C, 0x00},
+{0xC48D, 0x04},
+{0xC48E, 0x00},
+{0xC48F, 0x04},
+{0xC490, 0x03},
+{0xC492, 0x20},
+{0xC493, 0x08},
+{0xC498, 0x02},
+{0xC499, 0x00},
+{0xC49A, 0x02},
+{0xC49B, 0x00},
+{0xC49C, 0x02},
+{0xC49D, 0x00},
+{0xC49E, 0x02},
+{0xC49F, 0x60},
+{0xC4A0, 0x03},
+{0xC4A1, 0x00},
+{0xC4A2, 0x04},
+{0xC4A3, 0x00},
+{0xC4A4, 0x00},
+{0xC4A5, 0x10},
+{0xC4A6, 0x00},
+{0xC4A7, 0x40},
+{0xC4A8, 0x00},
+{0xC4A9, 0x80},
+{0xC4AA, 0x0D},
+{0xC4AB, 0x00},
+{0xC4AC, 0x0F},
+{0xC4AD, 0xC0},
+{0xC4B4, 0x01},
+{0xC4B5, 0x01},
+{0xC4B6, 0x00},
+{0xC4B7, 0x01},
+{0xC4B8, 0x00},
+{0xC4B9, 0x01},
+{0xC4BA, 0x01},
+{0xC4BB, 0x00},
+{0xC4BC, 0x01},
+{0xC4BD, 0x60},
+{0xC4BE, 0x02},
+{0xC4BF, 0x33},
+{0xC4C8, 0x03},
+{0xC4C9, 0xD0},
+{0xC4CA, 0x0E},
+{0xC4CB, 0x00},
+{0xC4CC, 0x0E},
+{0xC4CD, 0x51},
+{0xC4CE, 0x0E},
+{0xC4CF, 0x51},
+{0xC4D0, 0x04},
+{0xC4D1, 0x80},
+{0xC4E0, 0x04},
+{0xC4E1, 0x02},
+{0xC4E2, 0x01},
+{0xC4E4, 0x10},
+{0xC4E5, 0x20},
+{0xC4E6, 0x30},
+{0xC4E7, 0x40},
+{0xC4E8, 0x50},
+{0xC4E9, 0x60},
+{0xC4EA, 0x70},
+{0xC4EB, 0x80},
+{0xC4EC, 0x90},
+{0xC4ED, 0xA0},
+{0xC4EE, 0xB0},
+{0xC4EF, 0xC0},
+{0xC4F0, 0xD0},
+{0xC4F1, 0xE0},
+{0xC4F2, 0xF0},
+{0xC4F3, 0x80},
+{0xC4F4, 0x00},
+{0xC4F5, 0x20},
+{0xC4F6, 0x02},
+{0xC4F7, 0x00},
+{0xC4F8, 0x00},
+{0xC4F9, 0x00},
+{0xC4FA, 0x00},
+{0xC4FB, 0x01},
+{0xC4FC, 0x01},
+{0xC4FD, 0x00},
+{0xC4FE, 0x04},
+{0xC4FF, 0x02},
+{0xC500, 0x48},
+{0xC501, 0x74},
+{0xC502, 0x58},
+{0xC503, 0x80},
+{0xC504, 0x05},
+{0xC505, 0x80},
+{0xC506, 0x03},
+{0xC507, 0x80},
+{0xC508, 0x01},
+{0xC509, 0xC0},
+{0xC50A, 0x01},
+{0xC50B, 0xA0},
+{0xC50C, 0x01},
+{0xC50D, 0x2C},
+{0xC50E, 0x01},
+{0xC50F, 0x0A},
+{0xC510, 0x00},
+{0xC511, 0x00},
+{0xC512, 0xE5},
+{0xC513, 0x14},
+{0xC514, 0x04},
+{0xC515, 0x00},
+{0xC518, OV10635_VTS >> 8},
+{0xC519, OV10635_VTS & 0xff},
+{0xC51A, OV10635_HTS >> 8},
+{0xC51B, OV10635_HTS & 0xff},
+{0xC2E0, 0x00},
+{0xC2E1, 0x51},
+{0xC2E2, 0x00},
+{0xC2E3, 0xD6},
+{0xC2E4, 0x01},
+{0xC2E5, 0x5E},
+{0xC2E9, 0x01},
+{0xC2EA, 0x7A},
+{0xC2EB, 0x90},
+{0xC2ED, 0x00},
+{0xC2EE, 0x7A},
+{0xC2EF, 0x64},
+{0xC308, 0x00},
+{0xC309, 0x00},
+{0xC30A, 0x00},
+{0xC30C, 0x00},
+{0xC30D, 0x01},
+{0xC30E, 0x00},
+{0xC30F, 0x00},
+{0xC310, 0x01},
+{0xC311, 0x60},
+{0xC312, 0xFF},
+{0xC313, 0x08},
+{0xC314, 0x01},
+{0xC315, 0x00}, /* min saturation gain */
+{0xC316, 0xFF}, /* max saturation gain */
+{0xC317, 0x0B},
+{0xC318, 0x00},
+{0xC319, 0x0C},
+{0xC31A, 0x00},
+{0xC31B, 0xE0},
+{0xC31C, 0x00},
+{0xC31D, 0x14},
+{0xC31E, 0x00},
+{0xC31F, 0xC5},
+{0xC320, 0xFF},
+{0xC321, 0x4B},
+{0xC322, 0xFF},
+{0xC323, 0xF0},
+{0xC324, 0xFF},
+{0xC325, 0xE8},
+{0xC326, 0x00},
+{0xC327, 0x46},
+{0xC328, 0xFF},
+{0xC329, 0xD2},
+{0xC32A, 0xFF},
+{0xC32B, 0xE4},
+{0xC32C, 0xFF},
+{0xC32D, 0xBB},
+{0xC32E, 0x00},
+{0xC32F, 0x61},
+{0xC330, 0xFF},
+{0xC331, 0xF9},
+{0xC332, 0x00},
+{0xC333, 0xD9},
+{0xC334, 0x00},
+{0xC335, 0x2E},
+{0xC336, 0x00},
+{0xC337, 0xB1},
+{0xC338, 0xFF},
+{0xC339, 0x64},
+{0xC33A, 0xFF},
+{0xC33B, 0xEB},
+{0xC33C, 0xFF},
+{0xC33D, 0xE8},
+{0xC33E, 0x00},
+{0xC33F, 0x48},
+{0xC340, 0xFF},
+{0xC341, 0xD0},
+{0xC342, 0xFF},
+{0xC343, 0xED},
+{0xC344, 0xFF},
+{0xC345, 0xAD},
+{0xC346, 0x00},
+{0xC347, 0x66},
+{0xC348, 0x01},
+{0xC349, 0x00},
+{0x6700, 0x04},
+{0x6701, 0x7B},
+{0x6702, 0xFD},
+{0x6703, 0xF9},
+{0x6704, 0x3D},
+{0x6705, 0x71},
+{0x6706, 0x78},
+{0x6708, 0x05},
+{0x6F06, 0x6F},
+{0x6F07, 0x00},
+{0x6F0A, 0x6F},
+{0x6F0B, 0x00},
+{0x6F00, 0x03},
+{0xC34C, 0x01},
+{0xC34D, 0x00},
+{0xC34E, 0x46},
+{0xC34F, 0x55},
+{0xC350, 0x00},
+{0xC351, 0x40},
+{0xC352, 0x00},
+{0xC353, 0xFF},
+{0xC354, 0x04},
+{0xC355, 0x08},
+{0xC356, 0x01},
+{0xC357, 0xEF},
+{0xC358, 0x30},
+{0xC359, 0x01},
+{0xC35A, 0x64},
+{0xC35B, 0x46},
+{0xC35C, 0x00},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0xC261, 0x01},
+{0x301B, 0xF0},
+{0x301C, 0xF0},
+{0x301A, 0xF0},
+{0x6F00, 0xC3},
+{0xC46A, 0x30},
+{0xC46D, 0x20},
+{0xC464, 0x84},
+{0xC465, 0x00},
+{0x6F00, 0x03},
+{0x6F00, 0x43},
+{0x381C, 0x00},
+{0x381D, 0x40},
+{0xC454, 0x01},
+{0x6F00, 0xC3},
+{0xC454, 0x00},
+{0xC4B1, 0x02},
+{0xC4B2, 0x01},
+{0xC4B3, 0x03},
+{0x6F00, 0x03},
+{0x6F00, 0x43},
+/* enable FSIN (FRAMESYNC input) functionality */
+{0x3832, (0x0d+2*0x20+0x15+38) >> 8},
+{0x3833, (0x0d+2*0x20+0x15+38) & 0xff},
+{0x3834, OV10635_VTS >> 8},
+{0x3835, OV10635_VTS & 0xff},
+{0x302E, 0x01},
+};
+
+static const struct ov10635_reg ov10635_regs_30fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/2*32/2(1+1)=96Mhz, 30fps */
+{0x3003, 0x20},
+{0x3004, 0x21},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_15fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/2*32/2(1+3)=48Mhz, 15fps */
+{0x3003, 0x20},
+{0x3004, 0x23},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_10fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/2*32/2(1+5)=32Mhz, 10fps */
+{0x3003, 0x20},
+{0x3004, 0x25},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_5fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/4*32/2(1+5)=96Mhz, 5fps */
+{0x3003, 0x20},
+{0x3004, 0x45},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_contrast[5][18] = {
+{
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x20},
+	{0xc4e5, 0x40},
+	{0xc4e6, 0x60},
+	{0xc4e7, 0x80},
+	{0xc4e8, 0xa0},
+	{0xc4e9, 0xb4},
+	{0xc4ea, 0xc0},
+	{0xc4eb, 0xcb},
+	{0xc4ec, 0xd5},
+	{0xc4ed, 0xde},
+	{0xc4ee, 0xe6},
+	{0xc4ef, 0xed},
+	{0xc4f0, 0xf3},
+	{0xc4f1, 0xf8},
+	{0xc4f2, 0xfc},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x18},
+	{0xc4e5, 0x30},
+	{0xc4e6, 0x48},
+	{0xc4e7, 0x60},
+	{0xc4e8, 0x78},
+	{0xc4e9, 0x90},
+	{0xc4ea, 0xa4},
+	{0xc4eb, 0xb4},
+	{0xc4ec, 0xc2},
+	{0xc4ed, 0xcf},
+	{0xc4ee, 0xdb},
+	{0xc4ef, 0xe5},
+	{0xc4f0, 0xee},
+	{0xc4f1, 0xf6},
+	{0xc4f2, 0xfc},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x10},
+	{0xc4e5, 0x20},
+	{0xc4e6, 0x30},
+	{0xc4e7, 0x40},
+	{0xc4e8, 0x50},
+	{0xc4e9, 0x60},
+	{0xc4ea, 0x70},
+	{0xc4eb, 0x80},
+	{0xc4ec, 0x90},
+	{0xc4ed, 0xa0},
+	{0xc4ee, 0xb0},
+	{0xc4ef, 0xc0},
+	{0xc4f0, 0xd0},
+	{0xc4f1, 0xe0},
+	{0xc4f2, 0xf0},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x0c},
+	{0xc4e5, 0x18},
+	{0xc4e6, 0x24},
+	{0xc4e7, 0x30},
+	{0xc4e8, 0x3c},
+	{0xc4e9, 0x48},
+	{0xc4ea, 0x54},
+	{0xc4eb, 0x62},
+	{0xc4ec, 0x72},
+	{0xc4ed, 0x84},
+	{0xc4ee, 0x94},
+	{0xc4ef, 0xa6},
+	{0xc4f0, 0xb9},
+	{0xc4f1, 0xcd},
+	{0xc4f2, 0xe2},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x06},
+	{0xc4e5, 0x0d},
+	{0xc4e6, 0x15},
+	{0xc4e7, 0x1e},
+	{0xc4e8, 0x28},
+	{0xc4e9, 0x32},
+	{0xc4ea, 0x3c},
+	{0xc4eb, 0x48},
+	{0xc4ec, 0x56},
+	{0xc4ed, 0x66},
+	{0xc4ee, 0x78},
+	{0xc4ef, 0x8c},
+	{0xc4f0, 0xa2},
+	{0xc4f1, 0xba},
+	{0xc4f2, 0xd4},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}
+};
diff --git a/drivers/media/i2c/imagers/ov10635_debug.h b/drivers/media/i2c/imagers/ov10635_debug.h
new file mode 100644
index 0000000..4c3515a
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov10635_debug.h
@@ -0,0 +1,54 @@
+
+#if 0
+{0x4700, 0x02}, // BT656
+{0x381d, 0x40}, // mirror off
+{0x381c, 0x00}, // flip off
+{0x4300, 0x3a}, // YUV: UYVY
+{0x4708, 0x00}, // PCLK rising edge
+
+// clk = 24Mhz/3*22/2= 88Mhz
+{0x3003, 0x16},
+{0x3004, 0x30},
+#endif
+
+#define WIDTH 1280
+#define HEIGHT 720
+
+// DVP frame size
+{0x3808, WIDTH >> 8},
+{0x3809, WIDTH & 0xff},
+{0x380a, HEIGHT >> 8},
+{0x380b, HEIGHT & 0xff},
+
+{0x3802, ((814 - HEIGHT)/2) >> 8}, // vert crop start
+{0x3803, ((814 - HEIGHT)/2) & 0xff},
+{0x3806, ((814 - HEIGHT)/2 + HEIGHT + 1) >> 8}, // vert crop end
+{0x3807, ((814 - HEIGHT)/2 + HEIGHT + 1) & 0xff},
+
+#if 0
+#define HTS 0x6f6 // got from above table 1782
+#define VTS (0x2ec+80) // got from above table 748 + 80
+
+{0x380c, HTS >> 8}, // hts
+{0x380d, HTS & 0xff},
+{0x380e, VTS >> 8}, // vts
+{0x380f, VTS & 0xff},
+
+// fifo
+{0x4606, (2*HTS) >> 8}, // fifo_line_length = 2*hts
+{0x4607, (2*HTS) & 0xff},
+{0x460a, (2*(HTS-1280)) >> 8}, // fifo_hsync_start = 2*(hts - xres)
+{0x460b, (2*(HTS-1280)) & 0xff },
+
+// exposure
+{0xC488, (VTS-8)*16 >> 8},
+{0xC489, (VTS-8)*16 & 0xff},
+{0xC48A, (VTS-8)*16 >> 8},
+{0xC48B, (VTS-8)*16 & 0xff},
+
+// vts/hts
+{0xC518, VTS >> 8},
+{0xC519, VTS & 0xff},
+{0xC51A, HTS >> 8},
+{0xC51B, HTS & 0xff},
+#endif
diff --git a/drivers/media/i2c/imagers/ov490.c b/drivers/media/i2c/imagers/ov490.c
new file mode 100644
index 0000000..91c0555
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov490.c
@@ -0,0 +1,1075 @@
+/*
+ * OmniVision ov490-ov10640 sensor camera glue
+ *
+ * Copyright (C) 2016-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "ov490.h"
+
+#define OV490_I2C_ADDR		0x24
+
+#define OV490_PID_REGA		0x300a
+#define OV490_PID_REGB		0x300b
+#define OV490_PID		0x0490
+
+#define OV490_ISP_HSIZE_LOW	0x60
+#define OV490_ISP_HSIZE_HIGH	0x61
+#define OV490_ISP_VSIZE_LOW	0x62
+#define OV490_ISP_VSIZE_HIGH	0x63
+
+#define OV490_MEDIA_BUS_FMT		MEDIA_BUS_FMT_UYVY8_2X8
+
+struct ov490_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	int				red;
+	int				green_r;
+	int				green_b;
+	int				blue;
+	int				awb;
+	int				dvp_order;
+	int				group;
+	int				vsync;
+	/* serializers */
+	int				ser_addr;
+	int				des_addr;
+	int				reset_gpio;
+	int				active_low_resetb;
+};
+
+static int conf_link;
+module_param(conf_link, int, 0644);
+MODULE_PARM_DESC(conf_link, " Force configuration link. Used only if robust firmware flashing required (f.e. recovery)");
+
+static int group = 0;
+module_param(group, int, 0644);
+MODULE_PARM_DESC(group, " group number (0 - does not apply)");
+
+static int dvp_order = 0;
+module_param(dvp_order, int, 0644);
+MODULE_PARM_DESC(dvp_order, " DVP bus bits order");
+
+static int reset_gpio = 0;
+module_param(reset_gpio, int, 0644);
+MODULE_PARM_DESC(reset_gpio, " serializer gpio number on imager RESETB");
+
+static int vsync = 0;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 0 - not inverted)");
+
+static inline struct ov490_priv *to_ov490(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov490_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov490_priv, hdl)->sd;
+}
+
+static void ov490_reset(struct i2c_client *client)
+{
+	struct ov490_priv *priv = to_ov490(client);
+
+	switch (get_des_id(client)) {
+	case MAX9286_ID:
+	case MAX9288_ID:
+	case MAX9296A_ID:
+	case MAX96712_ID:
+		reg8_write_addr(client, priv->ser_addr, 0x0f, (0xfe & ~BIT(priv->reset_gpio))); /* set GPIOn value to reset */
+		usleep_range(2000, 2500);
+		reg8_write_addr(client, priv->ser_addr, 0x0f, 0xfe | BIT(priv->reset_gpio)); /* set GPIOn value to un-reset */
+		usleep_range(2000, 2500);
+		break;
+	case UB960_ID:
+		reg8_write_addr(client, get_des_addr(client), 0x6e, 0x8a);	/* set GPIO1 value to reset */
+		usleep_range(2000, 2500);
+		reg8_write_addr(client, get_des_addr(client), 0x6e, 0x9a);	/* set GPIO1 value to un-reset */
+		usleep_range(2000, 2500);
+		break;
+	}
+}
+
+static int ov490_set_regs(struct i2c_client *client,
+			  const struct ov490_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (reg16_write(client, regs[i].reg, regs[i].val)) {
+			usleep_range(100, 150); /* wait 100 us */
+			reg16_write(client, regs[i].reg, regs[i].val);
+		}
+
+		if (regs[i].reg == 0xFFFE)
+			usleep_range(100, 150); /* wait 100 us */
+	}
+
+	return 0;
+}
+
+static u8 ov490_ov10640_read(struct i2c_client *client, u16 addr)
+{
+	u8 reg_val = 0;
+
+	reg16_write(client, 0xFFFD, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0xFFFE, 0x19);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x5000, 0x01); /* read operation */
+	reg16_write(client, 0x5001, addr >> 8);
+	reg16_write(client, 0x5002, addr & 0xff);
+	reg16_write(client, 0xFFFE, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x00C0, 0xc1);
+	reg16_write(client, 0xFFFE, 0x19);
+	usleep_range(1000, 1500); /* wait 1 ms */
+	reg16_read(client, 0x5000, &reg_val);
+
+	return reg_val;
+}
+
+static void ov490_ov10640_write(struct i2c_client *client, u16 addr, u8 val)
+{
+	reg16_write(client, 0xFFFD, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0xFFFE, 0x19);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x5000, 0x00); /* write operation */
+	reg16_write(client, 0x5001, addr >> 8);
+	reg16_write(client, 0x5002, addr & 0xff);
+	reg16_write(client, 0x5003, val);
+	reg16_write(client, 0xFFFE, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x00C0, 0xc1);
+}
+
+static void ov490_otp_id_read(struct i2c_client *client)
+{
+	struct ov490_priv *priv = to_ov490(client);
+	int i;
+	int otp_bank0_allzero = 1;
+#if 0
+	/* read camera id from ov490 OTP memory */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x28);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0xE084, 0x40); /* manual mode, bank#0 */
+	reg16_write(client, 0xE081, 1); /* start OTP read */
+
+	usleep_range(25000, 26000); /* wait 25 ms */
+
+	for (i = 0; i < 6; i++)
+		reg16_read(client, 0xe000 + i + 4, &priv->id[i]);
+#else
+	/* read camera id from ov10640 OTP memory */
+	ov490_ov10640_write(client, 0x349C, 1);
+	usleep_range(25000, 25500); /* wait 25 ms */
+
+	for (i = 0; i < 6; i++) {
+		/* first 6 bytes are equal on all ov10640 */
+		priv->id[i] = ov490_ov10640_read(client, 0x349e + i + 6);
+		if (priv->id[i])
+			otp_bank0_allzero = 0;
+	}
+
+	if (otp_bank0_allzero) {
+		ov490_ov10640_write(client, 0x3495, 0x41); /* bank#1 */
+		ov490_ov10640_write(client, 0x349C, 1);
+		usleep_range(25000, 25500); /* wait 25 ms */
+
+		for (i = 0; i < 6; i++)
+			priv->id[i] = ov490_ov10640_read(client, 0x34ae + i);
+	}
+#endif
+}
+
+static int ov490_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ov490_get_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = OV490_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov490_set_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = OV490_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ov490_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = OV490_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ov490_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = OV490_PID >> 8;
+	edid->edid[9] = OV490_PID & 0xff;
+
+	return 0;
+}
+
+static int ov490_set_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int ov490_get_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ov490_g_mbus_config(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov490_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 val = 0;
+
+	ret = reg16_read(client, (u16)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int ov490_s_register(struct v4l2_subdev *sd,
+			    const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = reg16_write(client, (u16)reg->reg, (u8)reg->val);
+	if ((u8)reg->reg == 0xFFFD)
+		usleep_range(100, 150); /* wait 100 us */
+	if ((u8)reg->reg == 0xFFFE)
+		usleep_range(100, 150); /* wait 100 us */
+	return ret;
+}
+#endif
+
+static struct v4l2_subdev_core_ops ov490_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ov490_g_register,
+	.s_register = ov490_s_register,
+#endif
+};
+
+static int ov490_s_gamma(int a, int ref)
+{
+	if ((a + ref) > 0xff)
+		return 0xff;
+
+	if ((a + ref) < 0)
+		return 0;
+
+	return a + ref;
+}
+
+static int ov490_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+	int ret = -EINVAL;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		/* SDE (rough) brightness */
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00);
+		ret |= reg16_write(client, 0x5001, ctrl->val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xf1);
+		break;
+	case V4L2_CID_CONTRAST:
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xfd);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xf3);
+		break;
+	case V4L2_CID_HUE:
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xf5);
+		break;
+	case V4L2_CID_GAMMA:
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ov490_s_gamma(ctrl->val, 0x12));
+		ret |= reg16_write(client, 0x5001, ov490_s_gamma(ctrl->val, 0x20));
+		ret |= reg16_write(client, 0x5002, ov490_s_gamma(ctrl->val, 0x3b));
+		ret |= reg16_write(client, 0x5003, ov490_s_gamma(ctrl->val, 0x5d));
+		ret |= reg16_write(client, 0x5004, ov490_s_gamma(ctrl->val, 0x6a));
+		ret |= reg16_write(client, 0x5005, ov490_s_gamma(ctrl->val, 0x76));
+		ret |= reg16_write(client, 0x5006, ov490_s_gamma(ctrl->val, 0x81));
+		ret |= reg16_write(client, 0x5007, ov490_s_gamma(ctrl->val, 0x8b));
+		ret |= reg16_write(client, 0x5008, ov490_s_gamma(ctrl->val, 0x96));
+		ret |= reg16_write(client, 0x5009, ov490_s_gamma(ctrl->val, 0x9e));
+		ret |= reg16_write(client, 0x500a, ov490_s_gamma(ctrl->val, 0xae));
+		ret |= reg16_write(client, 0x500b, ov490_s_gamma(ctrl->val, 0xbc));
+		ret |= reg16_write(client, 0x500c, ov490_s_gamma(ctrl->val, 0xcf));
+		ret |= reg16_write(client, 0x500d, ov490_s_gamma(ctrl->val, 0xde));
+		ret |= reg16_write(client, 0x500e, ov490_s_gamma(ctrl->val, 0xec));
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xf9);
+		break;
+	case V4L2_CID_SHARPNESS:
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xfb);
+		break;
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+		if (ctrl->id == V4L2_CID_AUTOGAIN)
+			priv->autogain = ctrl->val;
+		if (ctrl->id == V4L2_CID_GAIN)
+			priv->gain = ctrl->val;
+		if (ctrl->id == V4L2_CID_EXPOSURE)
+			priv->exposure = ctrl->val;
+
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, !priv->autogain);
+		ret |= reg16_write(client, 0x5001, priv->exposure >> 8);
+		ret |= reg16_write(client, 0x5002, priv->exposure & 0xff);
+		ret |= reg16_write(client, 0x5003, priv->exposure >> 8);
+		ret |= reg16_write(client, 0x5004, priv->exposure & 0xff);
+		ret |= reg16_write(client, 0x5005, priv->exposure >> 8);
+		ret |= reg16_write(client, 0x5006, priv->exposure & 0xff);
+		ret |= reg16_write(client, 0x5007, priv->gain >> 8);
+		ret |= reg16_write(client, 0x5008, priv->gain & 0xff);
+		ret |= reg16_write(client, 0x5009, priv->gain >> 8);
+		ret |= reg16_write(client, 0x500a, priv->gain & 0xff);
+		ret |= reg16_write(client, 0x500b, priv->gain >> 8);
+		ret |= reg16_write(client, 0x500c, priv->gain & 0xff);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xea);
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+	case V4L2_CID_RED_BALANCE:
+	case V4L2_CID_BLUE_BALANCE:
+		if (ctrl->id == V4L2_CID_AUTO_WHITE_BALANCE)
+			priv->awb = ctrl->val;
+		if (ctrl->id == V4L2_CID_RED_BALANCE) {
+			priv->red = ctrl->val;
+			priv->red <<= 8;
+			priv->green_r = priv->red / 2;
+		}
+		if (ctrl->id == V4L2_CID_BLUE_BALANCE) {
+			priv->blue = ctrl->val;
+			priv->blue <<= 8;
+			priv->green_b = priv->blue / 2;
+		}
+
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, !priv->awb);
+		ret |= reg16_write(client, 0x5001, priv->red >> 8);
+		ret |= reg16_write(client, 0x5002, priv->red & 0xff);
+		ret |= reg16_write(client, 0x5003, priv->green_r >> 8);
+		ret |= reg16_write(client, 0x5004, priv->green_r & 0xff);
+		ret |= reg16_write(client, 0x5005, priv->green_b >> 8);
+		ret |= reg16_write(client, 0x5006, priv->green_b & 0xff);
+		ret |= reg16_write(client, 0x5007, priv->blue >> 8);
+		ret |= reg16_write(client, 0x5008, priv->blue & 0xff);
+		ret |= reg16_write(client, 0x5009, priv->red >> 8);
+		ret |= reg16_write(client, 0x500a, priv->red & 0xff);
+		ret |= reg16_write(client, 0x500b, priv->green_r >> 8);
+		ret |= reg16_write(client, 0x500c, priv->green_r & 0xff);
+		ret |= reg16_write(client, 0x500d, priv->green_b >> 8);
+		ret |= reg16_write(client, 0x500e, priv->green_b & 0xff);
+		ret |= reg16_write(client, 0x500f, priv->blue >> 8);
+		ret |= reg16_write(client, 0x5010, priv->blue & 0xff);
+		ret |= reg16_write(client, 0x5011, priv->red >> 8);
+		ret |= reg16_write(client, 0x5012, priv->red & 0xff);
+		ret |= reg16_write(client, 0x5013, priv->green_r >> 8);
+		ret |= reg16_write(client, 0x5014, priv->green_r & 0xff);
+		ret |= reg16_write(client, 0x5015, priv->green_b >> 8);
+		ret |= reg16_write(client, 0x5016, priv->green_b & 0xff);
+		ret |= reg16_write(client, 0x5017, priv->blue >> 8);
+		ret |= reg16_write(client, 0x5018, priv->blue & 0xff);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xeb);
+		break;
+	case V4L2_CID_HFLIP:
+#if 1
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0x5001, 0x00);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xdc);
+#else
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3128
+		ret |= reg16_write(client, 0x5001, 0x31);
+		ret |= reg16_write(client, 0x5002, 0x28);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 0);
+		val |= (ctrl->val << 0);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3128
+		ret |= reg16_write(client, 0x5001, 0x31);
+		ret |= reg16_write(client, 0x5002, 0x28);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3291
+		ret |= reg16_write(client, 0x5001, 0x32);
+		ret |= reg16_write(client, 0x5002, 0x91);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 1);
+		val |= (ctrl->val << 1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3291
+		ret |= reg16_write(client, 0x5001, 0x32);
+		ret |= reg16_write(client, 0x5002, 0x91);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3090
+		ret |= reg16_write(client, 0x5001, 0x30);
+		ret |= reg16_write(client, 0x5002, 0x90);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 2);
+		val |= (ctrl->val << 2);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3090
+		ret |= reg16_write(client, 0x5001, 0x30);
+		ret |= reg16_write(client, 0x5002, 0x90);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+#endif
+		break;
+	case V4L2_CID_VFLIP:
+#if 1
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0x5001, 0x01);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xdc);
+#else
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3128
+		ret |= reg16_write(client, 0x5001, 0x31);
+		ret |= reg16_write(client, 0x5002, 0x28);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 1);
+		val |= (ctrl->val << 1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3128
+		ret |= reg16_write(client, 0x5001, 0x31);
+		ret |= reg16_write(client, 0x5002, 0x28);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3291
+		ret |= reg16_write(client, 0x5001, 0x32);
+		ret |= reg16_write(client, 0x5002, 0x91);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 2);
+		val |= (ctrl->val << 2);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3291
+		ret |= reg16_write(client, 0x5001, 0x32);
+		ret |= reg16_write(client, 0x5002, 0x91);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3090
+		ret |= reg16_write(client, 0x5001, 0x30);
+		ret |= reg16_write(client, 0x5002, 0x90);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 3);
+		val |= (ctrl->val << 3);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3090
+		ret |= reg16_write(client, 0x5001, 0x30);
+		ret |= reg16_write(client, 0x5002, 0x90);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+#endif
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov490_ctrl_ops = {
+	.s_ctrl = ov490_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ov490_video_ops = {
+	.s_stream	= ov490_s_stream,
+	.g_mbus_config	= ov490_g_mbus_config,
+};
+
+static const struct v4l2_subdev_pad_ops ov490_subdev_pad_ops = {
+	.get_edid	= ov490_get_edid,
+	.enum_mbus_code	= ov490_enum_mbus_code,
+	.get_selection	= ov490_get_selection,
+	.set_selection	= ov490_set_selection,
+	.get_fmt	= ov490_get_fmt,
+	.set_fmt	= ov490_set_fmt,
+};
+
+static struct v4l2_subdev_ops ov490_subdev_ops = {
+	.core	= &ov490_core_ops,
+	.video	= &ov490_video_ops,
+	.pad	= &ov490_subdev_pad_ops,
+};
+
+static ssize_t ov490_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ov490, S_IRUGO, ov490_otp_id_show, NULL);
+
+static int ov490_initialize(struct i2c_client *client)
+{
+	struct ov490_priv *priv = to_ov490(client);
+	u8 val = 0;
+	u16 pid = 0;
+	int timeout, retry_timeout = 3;
+
+	setup_i2c_translator(client, priv->ser_addr, OV490_I2C_ADDR);
+
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_read(client, OV490_PID_REGA, &val);
+	pid = val;
+	reg16_read(client, OV490_PID_REGB, &val);
+	pid = (pid << 8) | val;
+
+	if (pid != OV490_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	if (unlikely(conf_link))
+		goto out;
+again:
+	/* Check if firmware booted by reading stream-on status */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x29);
+	usleep_range(100, 150); /* wait 100 us */
+	for (timeout = 300; timeout > 0; timeout--) {
+		reg16_read(client, 0xd000, &val);
+		if (val == 0x0c)
+			break;
+		mdelay(1);
+	}
+
+	/* wait firmware apps started by reading OV10640 ID */
+	for (;timeout > 0; timeout--) {
+		reg16_write(client, 0xFFFD, 0x80);
+		reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		reg16_write(client, 0x5000, 0x01);
+		reg16_write(client, 0x5001, 0x30);
+		reg16_write(client, 0x5002, 0x0a);
+		reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		reg16_write(client, 0xC0, 0xc1);
+		reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(1000, 1500); /* wait 1 ms */
+		reg16_read(client, 0x5000, &val);
+		if (val == 0xa6)
+			break;
+		mdelay(1);
+	}
+
+	if (!timeout) {
+		dev_err(&client->dev, "Timeout firmware boot wait, retrying\n");
+		/* reset OV10640 using RESETB pin controlled by OV490 GPIO0 */
+		reg16_write(client, 0xFFFD, 0x80);
+		reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		reg16_write(client, 0x0050, 0x01);
+		reg16_write(client, 0x0054, 0x01);
+		reg16_write(client, 0x0058, 0x00);
+		mdelay(10);
+		reg16_write(client, 0x0058, 0x01);
+		/* reset OV490 using RESETB pin controlled by serializer */
+		ov490_reset(client);
+		if (retry_timeout--)
+			goto again;
+	}
+
+	if (priv->group) {
+		/* switch to group# */
+		reg16_write(client, 0xFFFD, 0x80);
+		reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		reg16_write(client, 0x5000, priv->group);
+		reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		reg16_write(client, 0xc0, 0x3f);
+
+		mdelay(30);
+	}
+
+	/* read resolution used by current firmware */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x82);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_read(client, OV490_ISP_HSIZE_HIGH, &val);
+	priv->max_width = val;
+	reg16_read(client, OV490_ISP_HSIZE_LOW, &val);
+	priv->max_width = (priv->max_width << 8) | val;
+	reg16_read(client, OV490_ISP_VSIZE_HIGH, &val);
+	priv->max_height = val;
+	reg16_read(client, OV490_ISP_VSIZE_LOW, &val);
+	priv->max_height = (priv->max_height << 8) | val;
+	/* Program wizard registers */
+	ov490_set_regs(client, ov490_regs_wizard, ARRAY_SIZE(ov490_regs_wizard));
+	/* Set DVP bit swap */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x28);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x6009, priv->dvp_order << 4);
+	/* Set VSYNC inversion */
+	reg16_write(client, 0x6008, priv->vsync ? 0x2 : 0x0);
+	/* Read OTP IDs */
+	ov490_otp_id_read(client);
+
+out:
+	dev_info(&client->dev, "PID %x, res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, priv->max_width, priv->max_height, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static const struct i2c_device_id ov490_id[] = {
+	{ "ov490", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov490_id);
+
+static const struct of_device_id ov490_of_ids[] = {
+	{ .compatible = "ovti,ov490", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov490_of_ids);
+
+static int ov490_parse_dt(struct device_node *np, struct ov490_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	if (of_property_read_u32(np, "dvp-order", &priv->dvp_order))
+		priv->dvp_order = 0;
+	if (of_property_read_u32(np, "reset-gpio", &priv->reset_gpio))
+		priv->reset_gpio = 1;
+	if (of_property_read_u32(np, "group", &priv->group))
+		priv->group = 0;
+	if (of_property_read_u32(np, "vsync", &priv->group))
+		priv->vsync = 0;
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	/* module params override dts */
+	if (dvp_order)
+		priv->dvp_order = dvp_order;
+	if (group)
+		priv->group = group;
+	if (vsync)
+		priv->vsync = vsync;
+
+	return 0;
+}
+
+static int ov490_probe(struct i2c_client *client,
+		       const struct i2c_device_id *did)
+{
+	struct ov490_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ov490_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	priv->red = 0x400;
+	priv->blue = 0x400;
+	priv->green_r = priv->red / 2;
+	priv->green_b = priv->blue / 2;
+	priv->awb = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_RED_BALANCE, 2, 0xf, 1, priv->red >> 8);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_BLUE_BALANCE, 2, 0xf, 1, priv->blue >> 8);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ov490_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ov490_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ov490) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ov490_remove(struct i2c_client *client)
+{
+	struct ov490_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ov490);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static struct i2c_driver ov490_i2c_driver = {
+	.driver	= {
+		.name		= "ov490",
+		.of_match_table	= ov490_of_ids,
+	},
+	.probe		= ov490_probe,
+	.remove		= ov490_remove,
+	.id_table	= ov490_id,
+};
+
+module_i2c_driver(ov490_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for OV490-10640");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/ov490.h b/drivers/media/i2c/imagers/ov490.h
new file mode 100644
index 0000000..5b8cdf8
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov490.h
@@ -0,0 +1,101 @@
+/*
+ * OmniVision ov490-ov10640 sensor camera wizard 1280x1080@30/UYVY/BT601/8bit
+ *
+ * Copyright (C) 2016-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+//#define OV490_DISPLAY_PATTERN
+
+struct ov490_reg {
+	u16	reg;
+	u8	val;
+};
+
+static const struct ov490_reg ov490_regs_wizard[] = {
+/* The following registers should match firmware */
+{0xfffd, 0x80},
+{0xfffe, 0x82},
+{0x0071, 0x11},
+{0x0075, 0x11},
+{0xfffe, 0x29},
+{0x6010, 0x01},
+/* ov490 EMB line disable in YUV and RAW data, NOTE: EMB line is still used in ISP and sensor */
+{0xe000, 0x14},
+#if 0 /* do not disable EMB line in ISP! */
+{0x4017, 0x00},
+#endif
+{0xfffe, 0x28},
+{0x6000, 0x04},
+{0x6004, 0x00},
+{0x6008, 0x00}, // PCLK polarity - useless due to silicon bug -> use 0x808000bb register
+{0xfffe, 0x80},
+{0x0091, 0x00},
+{0x00bb, 0x1d}, // bit[3]=0 - PCLK polarity workaround
+/* ov10640 EMB line disable */
+#if 0 /* do not disable EMB line in sensor! */
+{0xfffe, 0x19},
+{0x5000, 0x00},
+{0x5001, 0x30},
+{0x5002, 0x91},
+{0x5003, 0x08},
+{0xfffe, 0x80},
+{0x00c0, 0xc1},
+#endif
+/* Ov490 FSIN: app_fsin_from_fsync */
+{0xfffe, 0x85},
+{0x0008, 0x00},
+{0x0009, 0x01},
+{0x000A, 0x05}, // fsin0 src
+{0x000B, 0x00},
+{0x0030, 0x02}, // fsin0_delay
+{0x0031, 0x00},
+{0x0032, 0x00},
+{0x0033, 0x00},
+{0x0038, 0x02}, // fsin1_delay
+{0x0039, 0x00},
+{0x003A, 0x00},
+{0x003B, 0x00},
+{0x0070, 0x2C}, // fsin0_length
+{0x0071, 0x01},
+{0x0072, 0x00},
+{0x0073, 0x00},
+{0x0074, 0x64}, // fsin1_length
+{0x0075, 0x00},
+{0x0076, 0x00},
+{0x0077, 0x00},
+{0x0000, 0x14},
+{0x0001, 0x00},
+{0x0002, 0x00},
+{0x0003, 0x00},
+{0x0004, 0x32}, // load fsin0,load fsin1,load other, it will be cleared automatically.
+{0x0005, 0x00},
+{0x0006, 0x00},
+{0x0007, 0x00},
+{0xfffe, 0x80},
+{0x0081, 0x00}, // 03;SENSOR FSIN
+/* ov10640 FSIN */
+{0xfffe, 0x19},
+{0x5000, 0x00},
+{0x5001, 0x30},
+{0x5002, 0x8c},
+{0x5003, 0xb2},
+{0xfffe, 0x80},
+{0x00c0, 0xc1},
+/* ov10640 HFLIP=1 by default */
+{0xfffe, 0x19},
+{0x5000, 0x01},
+{0x5001, 0x00},
+{0xfffe, 0x80},
+{0x00c0, 0xdc},
+#ifdef OV490_DISPLAY_PATTERN
+{0xfffe, 0x19},
+{0x5000, 0x02},
+{0xfffe, 0x80},
+{0x00c0, 0xd6},
+#endif
+};
-- 
2.7.4

