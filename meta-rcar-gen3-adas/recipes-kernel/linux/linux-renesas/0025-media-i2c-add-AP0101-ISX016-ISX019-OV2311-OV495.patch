From 044e2602614e1a906fa8e3d4ac6f98db47655bd2 Mon Sep 17 00:00:00 2001
From: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
Date: Tue, 22 Sep 2020 13:58:41 +0300
Subject: [PATCH] media: i2c: add AP0101, ISX016, ISX019, OV2311, OV495

This add lvds cameras with following imagers:
- ONSEMI AP0101-AR01xx
- Sony ISX016, ISX019
- OmniVision OV2311, OV495
- dummy cameras (when imager is not accessible to read/write)

Signed-off-by: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
---
 drivers/media/i2c/imagers/Makefile  |   9 +-
 drivers/media/i2c/imagers/ap0101.c  | 639 ++++++++++++++++++++++++++++++++++++
 drivers/media/i2c/imagers/ap0101.h  |  36 ++
 drivers/media/i2c/imagers/dummy.c   | 504 ++++++++++++++++++++++++++++
 drivers/media/i2c/imagers/isx016.c  | 550 +++++++++++++++++++++++++++++++
 drivers/media/i2c/imagers/isx016.h  |  27 ++
 drivers/media/i2c/imagers/isx019.c  | 608 ++++++++++++++++++++++++++++++++++
 drivers/media/i2c/imagers/isx019.h  |  30 ++
 drivers/media/i2c/imagers/ov10635.c |  28 +-
 drivers/media/i2c/imagers/ov10635.h |   4 +-
 drivers/media/i2c/imagers/ov2311.c  | 588 +++++++++++++++++++++++++++++++++
 drivers/media/i2c/imagers/ov2311.h  | 217 ++++++++++++
 drivers/media/i2c/imagers/ov490.c   |  28 +-
 drivers/media/i2c/imagers/ov490.h   |   4 +-
 drivers/media/i2c/imagers/ov495.c   | 622 +++++++++++++++++++++++++++++++++++
 drivers/media/i2c/imagers/ov495.h   |  23 ++
 16 files changed, 3882 insertions(+), 35 deletions(-)
 create mode 100644 drivers/media/i2c/imagers/ap0101.c
 create mode 100644 drivers/media/i2c/imagers/ap0101.h
 create mode 100644 drivers/media/i2c/imagers/dummy.c
 create mode 100644 drivers/media/i2c/imagers/isx016.c
 create mode 100644 drivers/media/i2c/imagers/isx016.h
 create mode 100644 drivers/media/i2c/imagers/isx019.c
 create mode 100644 drivers/media/i2c/imagers/isx019.h
 create mode 100644 drivers/media/i2c/imagers/ov2311.c
 create mode 100644 drivers/media/i2c/imagers/ov2311.h
 create mode 100644 drivers/media/i2c/imagers/ov495.c
 create mode 100644 drivers/media/i2c/imagers/ov495.h

diff --git a/drivers/media/i2c/imagers/Makefile b/drivers/media/i2c/imagers/Makefile
index 3d012a0..d81ed91 100644
--- a/drivers/media/i2c/imagers/Makefile
+++ b/drivers/media/i2c/imagers/Makefile
@@ -1,7 +1,10 @@
 # SPDX-License-Identifier: GPL-2.0
-#obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ap0101_ar014x.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ap0101.o
 #obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ap0201_ar023x.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= isx016.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= isx019.o
 obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov10635.o
-#obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov2311.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov2311.o
 obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov490.o
-#obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= dummy.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov495.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= dummy.o
diff --git a/drivers/media/i2c/imagers/ap0101.c b/drivers/media/i2c/imagers/ap0101.c
new file mode 100644
index 0000000..fdb6f43
--- /dev/null
+++ b/drivers/media/i2c/imagers/ap0101.c
@@ -0,0 +1,639 @@
+/*
+ * ON Semiconductor AP0101-AR014X sensor camera driver
+ *
+ * Copyright (C) 2018-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "ap0101.h"
+
+static const int ap0101_i2c_addr[] = {0x5d, 0x48};
+
+#define AP0101_PID_REG		0x0000
+#define AP0101_REV_REG		0x0058
+#define AP0100_PID		0x0062
+#define AP0101_PID		0x0160
+#define AP0102_PID		0x0064
+
+#define AP0101_MEDIA_BUS_FMT	MEDIA_BUS_FMT_UYVY8_2X8
+
+struct ap0101_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	/* serializers */
+	int				ser_addr;
+	int				hts;
+	int				vts;
+	int				frame_preamble;
+};
+
+static inline struct ap0101_priv *to_ap0101(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ap0101_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ap0101_priv, hdl)->sd;
+}
+
+static int ap0101_set_regs(struct i2c_client *client,
+			   const struct ap0101_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == AP0101_DELAY) {
+			mdelay(regs[i].val);
+			continue;
+		}
+
+		reg16_write16(client, regs[i].reg, regs[i].val);
+	}
+
+	return 0;
+}
+
+static u16 ap0101_ar014x_read(struct i2c_client *client, u16 addr)
+{
+	u16 reg_val = 0;
+
+	reg16_write16(client, 0x0040, 0x8d00);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0xfc00, addr);
+	reg16_write16(client, 0xfc02, 0x0200); /* 2 bytes */
+	reg16_write16(client, 0x0040, 0x8d05);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0x0040, 0x8d08);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_read16(client, 0xfc00, &reg_val);
+	reg16_write16(client, 0x0040, 0x8d02);
+	usleep_range(1000, 1500); /* wait 1000 us */
+
+	return reg_val;
+}
+
+static void ap0101_ar014x_write(struct i2c_client *client, u16 addr, u16 val)
+{
+	reg16_write16(client, 0x0040, 0x8d00);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0xfc00, addr);
+	reg16_write16(client, 0xfc02, 0x0200 | (val >> 8)); /* 2 bytes */
+	reg16_write16(client, 0xfc04, (val & 0xff) << 8);
+	reg16_write16(client, 0x0040, 0x8d06);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0x0040, 0x8d08);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0x0040, 0x8d02);
+	usleep_range(1000, 1500); /* wait 1000 us */
+}
+
+static void ap0101_otp_id_read(struct i2c_client *client)
+{
+	struct ap0101_priv *priv = to_ap0101(client);
+	int i;
+
+	/* read camera id from ar014x OTP memory */
+	ap0101_ar014x_write(client, 0x3054, 0x400);
+	ap0101_ar014x_write(client, 0x304a, 0x110);
+	usleep_range(25000, 25500); /* wait 25 ms */
+
+	for (i = 0; i < 6; i += 2) {
+		/* first 4 bytes are equal on all ar014x */
+		priv->id[i]     = (ap0101_ar014x_read(client, 0x3800 + i + 4) >> 8)   ^ (ap0101_ar014x_read(client, 0x3800 + i + 16) >> 8);
+		priv->id[i + 1] = (ap0101_ar014x_read(client, 0x3800 + i + 4) & 0xff) ^ (ap0101_ar014x_read(client, 0x3800 + i + 16) & 0xff);
+	}
+}
+
+static int ap0101_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ap0101_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = AP0101_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ap0101_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = AP0101_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ap0101_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = AP0101_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ap0101_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+
+	ap0101_otp_id_read(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = AP0101_PID >> 8;
+	edid->edid[9] = AP0101_PID & 0xff;
+
+	return 0;
+}
+
+static int ap0101_set_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int ap0101_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ap0101_g_mbus_config(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ap0101_g_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	__be64 be_val;
+
+	if (!reg->size)
+		reg->size = sizeof(u16);
+	if (reg->size > sizeof(reg->val))
+		reg->size = sizeof(reg->val);
+
+	ret = reg16_read_n(client, (u16)reg->reg, (u8*)&be_val, reg->size);
+	be_val = be_val << ((sizeof(be_val) - reg->size) * 8);
+	reg->val = be64_to_cpu(be_val);
+
+	return ret;
+}
+
+static int ap0101_s_register(struct v4l2_subdev *sd,
+			     const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 size = reg->size;
+	__be64 be_val;
+
+	if (!size)
+		size = sizeof(u16);
+	if (size > sizeof(reg->val))
+		size = sizeof(reg->val);
+
+	be_val = cpu_to_be64(reg->val);
+	be_val = be_val >> ((sizeof(be_val) - size) * 8);
+	return reg16_write_n(client, (u16)reg->reg, (u8*)&be_val, size);
+}
+#endif
+
+static struct v4l2_subdev_core_ops ap0101_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ap0101_g_register,
+	.s_register = ap0101_s_register,
+#endif
+};
+
+static int ap0101_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+	int ret = -EINVAL;
+	u16 val = 0;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+		break;
+	case V4L2_CID_HFLIP:
+		reg16_read16(client, 0xc846, &val);
+		if (ctrl->val)
+			val |= 0x01;
+		else
+			val &= ~0x01;
+		reg16_write16(client, 0xc846, val);
+		reg16_write16(client, 0xfc00, 0x2800);
+		ret = reg16_write16(client, 0x0040, 0x8100);
+		break;
+	case V4L2_CID_VFLIP:
+		reg16_read16(client, 0xc846, &val);
+		if (ctrl->val)
+			val |= 0x02;
+		else
+			val &= ~0x02;
+		reg16_write16(client, 0xc846, val);
+		reg16_write16(client, 0xfc00, 0x2800);
+		ret = reg16_write16(client, 0x0040, 0x8100);
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ap0101_ctrl_ops = {
+	.s_ctrl = ap0101_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ap0101_video_ops = {
+	.s_stream	= ap0101_s_stream,
+	.g_mbus_config	= ap0101_g_mbus_config,
+};
+
+static const struct v4l2_subdev_pad_ops ap0101_subdev_pad_ops = {
+	.get_edid	= ap0101_get_edid,
+	.enum_mbus_code	= ap0101_enum_mbus_code,
+	.get_selection	= ap0101_get_selection,
+	.set_selection	= ap0101_set_selection,
+	.get_fmt	= ap0101_get_fmt,
+	.set_fmt	= ap0101_set_fmt,
+};
+
+static struct v4l2_subdev_ops ap0101_subdev_ops = {
+	.core	= &ap0101_core_ops,
+	.video	= &ap0101_video_ops,
+	.pad	= &ap0101_subdev_pad_ops,
+};
+
+static ssize_t ap0101_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+
+	ap0101_otp_id_read(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ap0101, S_IRUGO, ap0101_otp_id_show, NULL);
+
+static int ap0101_initialize(struct i2c_client *client)
+{
+	struct ap0101_priv *priv = to_ap0101(client);
+	u16 pid = 0, rev = 0, val = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ap0101_i2c_addr); i++) {
+		setup_i2c_translator(client, priv->ser_addr, ap0101_i2c_addr[i]);
+
+		/* check model ID */
+		reg16_read16(client, AP0101_PID_REG, &pid);
+		if (pid == AP0101_PID)
+			break;
+	}
+
+	if (pid != AP0101_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	reg16_read16(client, AP0101_REV_REG, &rev);
+#if 1
+	/* read resolution used by current firmware */
+	reg16_read16(client, 0xca90, &val);
+	priv->max_width = val;
+	reg16_read16(client, 0xca92, &val);
+	priv->max_height = val;
+#else
+	priv->max_width = AP0101_MAX_WIDTH;
+	priv->max_height = AP0101_MAX_HEIGHT;
+#endif
+	/* Program wizard registers */
+	switch (pid) {
+	case AP0100_PID:
+	case AP0101_PID:
+		ap0101_set_regs(client, ap0101_regs, ARRAY_SIZE(ap0101_regs));
+		break;
+	case AP0102_PID:
+		ap0101_set_regs(client, ap0102_regs, ARRAY_SIZE(ap0102_regs));
+		break;
+	}
+	/* Read OTP IDs */
+	ap0101_otp_id_read(client);
+
+	switch (get_des_id(client)) {
+	case MAX9286_ID:
+	case MAX9288_ID:
+	case MAX9296A_ID:
+	case MAX96712_ID:
+		/* setup serializer HS generator */
+		priv->frame_preamble = 5;
+		priv->hts = 1280 * 2 + 548;
+		priv->vts = 960;
+		reg8_write_addr(client, priv->ser_addr, 0x4e, priv->frame_preamble >> 16);	/* HS delay */
+		reg8_write_addr(client, priv->ser_addr, 0x4f, (priv->frame_preamble >> 8) & 0xff);
+		reg8_write_addr(client, priv->ser_addr, 0x50, priv->frame_preamble & 0xff);
+		reg8_write_addr(client, priv->ser_addr, 0x54, (priv->max_width * 2) >> 8);	/* HS high period */
+		reg8_write_addr(client, priv->ser_addr, 0x55, (priv->max_width * 2) & 0xff);
+		reg8_write_addr(client, priv->ser_addr, 0x56, (priv->hts - priv->max_width * 2) >> 8); /* HS low period */
+		reg8_write_addr(client, priv->ser_addr, 0x57, (priv->hts - priv->max_width * 2) & 0xff);
+		reg8_write_addr(client, priv->ser_addr, 0x58, priv->vts >> 8);			/* HS count */
+		reg8_write_addr(client, priv->ser_addr, 0x59, priv->vts & 0xff);
+		break;
+	}
+
+	dev_info(&client->dev, "PID %x (%x), res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, rev, priv->max_width, priv->max_height, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int ap0101_parse_dt(struct device_node *np, struct ap0101_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int ap0101_probe(struct i2c_client *client,
+		        const struct i2c_device_id *did)
+{
+	struct ap0101_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ap0101_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 1);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ap0101_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ap0101_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ap0101) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ap0101_remove(struct i2c_client *client)
+{
+	struct ap0101_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ap0101);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id ap0101_id[] = {
+	{ "ap0101", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ap0101_id);
+
+static const struct of_device_id ap0101_of_ids[] = {
+	{ .compatible = "onnn,ap0101", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ap0101_of_ids);
+
+static struct i2c_driver ap0101_i2c_driver = {
+	.driver	= {
+		.name		= "ap0101",
+		.of_match_table	= ap0101_of_ids,
+	},
+	.probe		= ap0101_probe,
+	.remove		= ap0101_remove,
+	.id_table	= ap0101_id,
+};
+
+module_i2c_driver(ap0101_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for AP0101");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/ap0101.h b/drivers/media/i2c/imagers/ap0101.h
new file mode 100644
index 0000000..2dd0fdf
--- /dev/null
+++ b/drivers/media/i2c/imagers/ap0101.h
@@ -0,0 +1,36 @@
+/*
+ * ON Semiconductor ap0101-ar014x sensor camera setup 1280x720@30/UYVY/BT601/8bit
+ *
+ * Copyright (C) 2018-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define AP0101_MAX_WIDTH	1280
+#define AP0101_MAX_HEIGHT	720
+
+#define AP0101_DELAY		0xffff
+
+struct ap0101_reg {
+	u16	reg;
+	u16	val;
+};
+
+static const struct ap0101_reg ap0101_regs[] = {
+/* enable FSIN */
+{0xc88c, 0x0303},
+{0xfc00, 0x2800},
+{0x0040, 0x8100},
+{AP0101_DELAY, 100},
+};
+
+static const struct ap0101_reg ap0102_regs[] = {
+/* enable FSIN */
+{0xc890, 0x0303},
+{0xfc00, 0x2800},
+{0x0040, 0x8100},
+{AP0101_DELAY, 100},
+};
diff --git a/drivers/media/i2c/imagers/dummy.c b/drivers/media/i2c/imagers/dummy.c
new file mode 100644
index 0000000..e218e17
--- /dev/null
+++ b/drivers/media/i2c/imagers/dummy.c
@@ -0,0 +1,504 @@
+/*
+ * Dummy sensor camera driver
+ *
+ * Copyright (C) 2019 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+struct dummy_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	u8				id[6];
+	int				max_width;
+	int				max_height;
+	const char *			media_bus_format;
+	int				mbus_format;
+};
+
+static int width = 1920;
+module_param(width, int, 0644);
+MODULE_PARM_DESC(width, " width (default: 1920)");
+
+static int height = 1080;
+module_param(height, int, 0644);
+MODULE_PARM_DESC(height, " height (default: 1080)");
+
+static char *mbus = "uyvy";
+module_param(mbus, charp, 0644);
+MODULE_PARM_DESC(mbus, " MEDIA_BUS_FORMAT (default: UYVY)");
+
+static inline struct dummy_priv *to_dummy(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct dummy_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct dummy_priv, hdl)->sd;
+}
+
+static int dummy_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int dummy_get_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = priv->mbus_format;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int dummy_set_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	mf->code = priv->mbus_format;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int dummy_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = priv->mbus_format;
+
+	return 0;
+}
+
+static int dummy_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = 'D' >> 8;
+	edid->edid[9] = 'Y' & 0xff;
+
+	return 0;
+}
+
+static int dummy_set_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int dummy_get_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int dummy_g_mbus_config(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int dummy_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	reg->val = 0;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int dummy_s_register(struct v4l2_subdev *sd,
+			    const struct v4l2_dbg_register *reg)
+{
+	return 0;
+}
+#endif
+
+static struct v4l2_subdev_core_ops dummy_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = dummy_g_register,
+	.s_register = dummy_s_register,
+#endif
+};
+
+static int dummy_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_ANALOGUE_GAIN:
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		break;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops dummy_ctrl_ops = {
+	.s_ctrl = dummy_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops dummy_video_ops = {
+	.s_stream	= dummy_s_stream,
+	.g_mbus_config	= dummy_g_mbus_config,
+};
+
+static const struct v4l2_subdev_pad_ops dummy_subdev_pad_ops = {
+	.get_edid	= dummy_get_edid,
+	.enum_mbus_code	= dummy_enum_mbus_code,
+	.get_selection	= dummy_get_selection,
+	.set_selection	= dummy_set_selection,
+	.get_fmt	= dummy_get_fmt,
+	.set_fmt	= dummy_set_fmt,
+};
+
+static struct v4l2_subdev_ops dummy_subdev_ops = {
+	.core	= &dummy_core_ops,
+	.video	= &dummy_video_ops,
+	.pad	= &dummy_subdev_pad_ops,
+};
+
+static void dummy_otp_id_read(struct i2c_client *client)
+{
+	struct dummy_priv *priv = to_dummy(client);
+
+	/* dummy camera id */
+	priv->id[0] = 'd';
+	priv->id[1] = 'u';
+	priv->id[2] = 'm';
+	priv->id[3] = 'm';
+	priv->id[4] = 'y';
+	priv->id[5] = '.';
+}
+
+static ssize_t dummy_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	dummy_otp_id_read(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_dummy, S_IRUGO, dummy_otp_id_show, NULL);
+
+static int dummy_initialize(struct i2c_client *client)
+{
+	struct dummy_priv *priv = to_dummy(client);
+
+	if (strcmp(priv->media_bus_format, "yuyv") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_YUYV8_2X8;
+	else if (strcmp(priv->media_bus_format, "uyvy") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_UYVY8_2X8;
+	else if (strcmp(priv->media_bus_format, "grey") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_Y8_1X8;
+	else if (strcmp(priv->media_bus_format, "rggb8") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SRGGB8_1X8;
+	else if (strcmp(priv->media_bus_format, "bggr8") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SBGGR8_1X8;
+	else if (strcmp(priv->media_bus_format, "grbg8") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SGRBG8_1X8;
+	else if (strcmp(priv->media_bus_format, "rggb12") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SRGGB12_1X12;
+	else if (strcmp(priv->media_bus_format, "bggr12") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SBGGR12_1X12;
+	else if (strcmp(priv->media_bus_format, "grbg12") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SGRBG12_1X12;
+	else if (strcmp(priv->media_bus_format, "rggb14") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SRGGB14_1X14;
+	else if (strcmp(priv->media_bus_format, "bggr14") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SBGGR14_1X14;
+	else if (strcmp(priv->media_bus_format, "grbg14") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SGRBG14_1X14;
+	else if (strcmp(priv->media_bus_format, "rggb16") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SRGGB16_1X16;
+	else if (strcmp(priv->media_bus_format, "bggr16") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SBGGR16_1X16;
+	else if (strcmp(priv->media_bus_format, "grbg16") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SGRBG16_1X16;
+	else {
+		v4l_err(client, "failed to parse mbus format (%s)\n", priv->media_bus_format);
+		return -EINVAL;
+	}
+
+	/* Read OTP IDs */
+	dummy_otp_id_read(client);
+
+	dev_info(&client->dev, "res %dx%d, mbus %s, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 priv->max_width, priv->max_height, priv->media_bus_format, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+
+	return 0;
+}
+
+static const struct i2c_device_id dummy_id[] = {
+	{ "dummy-camera", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, dummy_id);
+
+static const struct of_device_id dummy_of_ids[] = {
+	{ .compatible = "dummy,camera", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, dummy_of_ids);
+
+static int dummy_parse_dt(struct device_node *np, struct dummy_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+
+	if (of_property_read_u32(np, "dummy,width", &priv->max_width))
+		priv->max_width = width;
+
+	if (of_property_read_u32(np, "dummy,height", &priv->max_height))
+		priv->max_height = height;
+
+	if (of_property_read_string(np, "dummy,mbus", &priv->media_bus_format))
+		priv->media_bus_format = mbus;
+
+	/* module params override dts */
+	if (strcmp(mbus, "uyvy"))
+		priv->media_bus_format = mbus;
+	if (width != 1920)
+		priv->max_width = width;
+	if (height != 1080)
+		priv->max_height = height;
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int dummy_probe(struct i2c_client *client,
+		       const struct i2c_device_id *did)
+{
+	struct dummy_priv *priv;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &dummy_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_GAIN, 1, 0x7ff, 1, 0x200);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_ANALOGUE_GAIN, 1, 0xe, 1, 0xa);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 1, 0x600, 1, 0x144);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = dummy_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = dummy_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_dummy) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	v4l_err(client, "failed to probe @ 0x%02x (%s)\n",
+		client->addr, client->adapter->name);
+	return ret;
+}
+
+static int dummy_remove(struct i2c_client *client)
+{
+	struct dummy_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_dummy);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static struct i2c_driver dummy_i2c_driver = {
+	.driver	= {
+		.name		= "dummy-camera",
+		.of_match_table	= dummy_of_ids,
+	},
+	.probe		= dummy_probe,
+	.remove		= dummy_remove,
+	.id_table	= dummy_id,
+};
+module_i2c_driver(dummy_i2c_driver);
+
+MODULE_DESCRIPTION("Dummy camera glue driver");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/isx016.c b/drivers/media/i2c/imagers/isx016.c
new file mode 100644
index 0000000..e781a9ae
--- /dev/null
+++ b/drivers/media/i2c/imagers/isx016.c
@@ -0,0 +1,550 @@
+/*
+ * Sony ISX016 (isp) camera driver
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "isx016.h"
+
+static const int isx016_i2c_addr[] = {0x1a};
+
+#define ISX016_PID_REG		0x0000
+#define ISX016_PID		0x0D20
+
+#define ISX016_MEDIA_BUS_FMT	MEDIA_BUS_FMT_UYVY8_2X8
+
+static void isx016_otp_id_read(struct i2c_client *client);
+
+struct isx016_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	/* serializers */
+	int				ser_addr;
+	int				des_addr;
+};
+
+static inline struct isx016_priv *to_isx016(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct isx016_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct isx016_priv, hdl)->sd;
+}
+
+static int isx016_read16(struct i2c_client *client, u8 category, u16 reg, u16 *val)
+{
+	reg16_write(client, 0xFFFF, category);
+	reg16_read16(client, reg, val);
+
+	return 0;
+}
+
+static int isx016_write16(struct i2c_client *client, u8 category, u16 reg, u16 val)
+{
+	reg16_write(client, 0xFFFF, category);
+	reg16_write16(client, reg, val);
+
+	return 0;
+}
+
+static int isx016_set_regs(struct i2c_client *client,
+			  const struct isx016_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == ISX016_DELAY) {
+			mdelay(regs[i].val);
+			continue;
+		}
+
+		isx016_write16(client, regs[i].reg >> 8, regs[i].reg & 0xff, regs[i].val);
+	}
+
+	return 0;
+}
+
+static void isx016_otp_id_read(struct i2c_client *client)
+{
+	struct isx016_priv *priv = to_isx016(client);
+	int i;
+	u16 val = 0;
+
+	/* read camera id from isx016 FUSEs */
+	for (i = 0; i < 6; i+=2) {
+		isx016_read16(client, 92, 0x0a + i, &val);
+		priv->id[i] = val >> 8;
+		priv->id[i+1] = val & 0xff;
+	}
+}
+
+static int isx016_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int isx016_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = ISX016_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int isx016_set_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = ISX016_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int isx016_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = ISX016_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int isx016_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+
+	isx016_otp_id_read(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = ISX016_PID >> 8;
+	edid->edid[9] = ISX016_PID & 0xff;
+
+	return 0;
+}
+
+static int isx016_set_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int isx016_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int isx016_g_mbus_config(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int isx016_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val = 0;
+
+	ret = isx016_read16(client, (u16)reg->reg >> 8, (u16)reg->reg & 0xff, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int isx016_s_register(struct v4l2_subdev *sd,
+			    const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return isx016_write16(client, (u16)reg->reg >> 8, (u16)reg->reg & 0xff, (u16)reg->val);
+}
+#endif
+
+static struct v4l2_subdev_core_ops isx016_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = isx016_g_register,
+	.s_register = isx016_s_register,
+#endif
+};
+
+static int isx016_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+	int ret = -EINVAL;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops isx016_ctrl_ops = {
+	.s_ctrl = isx016_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops isx016_video_ops = {
+	.s_stream	= isx016_s_stream,
+	.g_mbus_config	= isx016_g_mbus_config,
+};
+
+static const struct v4l2_subdev_pad_ops isx016_subdev_pad_ops = {
+	.get_edid	= isx016_get_edid,
+	.enum_mbus_code	= isx016_enum_mbus_code,
+	.get_selection	= isx016_get_selection,
+	.set_selection	= isx016_set_selection,
+	.get_fmt	= isx016_get_fmt,
+	.set_fmt	= isx016_set_fmt,
+};
+
+static struct v4l2_subdev_ops isx016_subdev_ops = {
+	.core	= &isx016_core_ops,
+	.video	= &isx016_video_ops,
+	.pad	= &isx016_subdev_pad_ops,
+};
+
+static ssize_t isx016_otp_id_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+
+	isx016_otp_id_read(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_isx016, S_IRUGO, isx016_otp_id_show, NULL);
+
+static int isx016_initialize(struct i2c_client *client)
+{
+	struct isx016_priv *priv = to_isx016(client);
+	u16 pid = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(isx016_i2c_addr); i++) {
+		setup_i2c_translator(client, priv->ser_addr, isx016_i2c_addr[i]);
+
+		/* check model ID */
+		isx016_read16(client, 0, ISX016_PID_REG, &pid);
+
+		if (pid == ISX016_PID)
+			break;
+	}
+
+	if (pid != ISX016_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	priv->max_width = ISX016_MAX_WIDTH;
+	priv->max_height = ISX016_MAX_HEIGHT;
+
+	/* Read OTP IDs */
+	isx016_otp_id_read(client);
+	/* Program wizard registers */
+	isx016_set_regs(client, isx016_regs, ARRAY_SIZE(isx016_regs));
+
+	dev_info(&client->dev, "PID %x, res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, priv->max_width, priv->max_height, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int isx016_parse_dt(struct device_node *np, struct isx016_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int isx016_probe(struct i2c_client *client,
+			const struct i2c_device_id *did)
+{
+	struct isx016_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &isx016_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->sd.entity.flags |= MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = isx016_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = isx016_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_isx016) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int isx016_remove(struct i2c_client *client)
+{
+	struct isx016_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_isx016);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id isx016_id[] = {
+	{ "isx016", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, isx016_id);
+
+static const struct of_device_id isx016_of_ids[] = {
+	{ .compatible = "sony,isx016", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, isx016_of_ids);
+
+static struct i2c_driver isx016_i2c_driver = {
+	.driver = {
+		.name = "isx016",
+		.of_match_table = isx016_of_ids,
+	},
+	.probe = isx016_probe,
+	.remove = isx016_remove,
+	.id_table = isx016_id,
+};
+
+module_i2c_driver(isx016_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for ISX016");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/isx016.h b/drivers/media/i2c/imagers/isx016.h
new file mode 100644
index 0000000..caf427f
--- /dev/null
+++ b/drivers/media/i2c/imagers/isx016.h
@@ -0,0 +1,27 @@
+/*
+ * Sony isx016 (isp) camera setup 1280x960@30/UYVY/BT601/8bit
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define ISX016_MAX_WIDTH	1280
+#define ISX016_MAX_HEIGHT	960
+
+#define ISX016_DELAY		0xffff
+
+struct isx016_reg {
+	u16	reg;
+	u16	val;
+};
+
+static const struct isx016_reg isx016_regs[] = {
+#if 0
+/* enable FSIN */
+#endif
+{ISX016_DELAY, 100},
+};
diff --git a/drivers/media/i2c/imagers/isx019.c b/drivers/media/i2c/imagers/isx019.c
new file mode 100644
index 0000000..034b6e8
--- /dev/null
+++ b/drivers/media/i2c/imagers/isx019.c
@@ -0,0 +1,608 @@
+/*
+ * Sony ISX019 (isp) camera driver
+ *
+ * Copyright (C) 2018-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "isx019.h"
+
+static const int isx019_i2c_addr[] = {0x1a};
+
+#define ISX019_PID_REG		0x0000
+#define ISX019_PID		0x4000
+
+#define ISX019_MEDIA_BUS_FMT	MEDIA_BUS_FMT_UYVY8_2X8
+
+static void isx019_otp_id_read(struct i2c_client *client);
+
+struct isx019_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	/* serializers */
+	int				ser_addr;
+	int				des_addr;
+};
+
+static char *intf = "command";
+module_param(intf, charp, 0644);
+MODULE_PARM_DESC(intf, " Registers access interface command,address (default: command)");
+
+static inline struct isx019_priv *to_isx019(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct isx019_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct isx019_priv, hdl)->sd;
+}
+
+static int isx019_read16(struct i2c_client *client, u8 category, u16 reg, u16 *val)
+{
+	int ret = -1;
+
+	if (strcmp(intf, "command") == 0) {
+ #define R_NUM_BYTES		9
+ #define R_NUM_CMDS		1
+ #define R_NUM_CMD_BYTES	6
+ #define R_CMD			1
+ #define R_BYTES		2
+		u8 buf[R_NUM_BYTES] = {R_NUM_BYTES, R_NUM_CMDS,
+				       R_NUM_CMD_BYTES, R_CMD,
+				       category, reg >> 8, reg & 0xff,
+				       R_BYTES, 0x00};
+
+		/* calculate checksum */
+		buf[8] = R_NUM_BYTES + R_NUM_CMDS + R_NUM_CMD_BYTES + R_CMD +
+			 category + (reg >> 8) + (reg & 0xff) + R_BYTES;
+
+		ret = i2c_master_send(client, buf, R_NUM_BYTES);
+		if (ret == R_NUM_BYTES)
+			ret = i2c_master_recv(client, buf, R_NUM_BYTES - 2);
+
+		if (ret < 0) {
+			dev_err(&client->dev,
+				"read fail: chip 0x%x register 0x%x: %d\n",
+				client->addr, reg, ret);
+		} else {
+			*val = buf[4] | ((u16)buf[5] << 8);
+		}
+	} else if (strcmp(intf, "address") == 0) {
+		reg16_write(client, 0xFFFF, category);
+		ret = reg16_read16(client, reg, val);
+		*val = swab16p(val);
+	} else {
+		dev_err(&client->dev, "invalid register access interface %s\n", intf);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static int isx019_write16(struct i2c_client *client, u8 category, u16 reg, u16 val)
+{
+	int ret = -1;
+
+	if (strcmp(intf, "command") == 0) {
+ #define W_NUM_BYTES		10
+ #define W_NUM_CMDS		1
+ #define W_NUM_CMD_BYTES	7
+ #define W_CMD			2
+		u8 buf[W_NUM_BYTES] = {W_NUM_BYTES, W_NUM_CMDS,
+				       W_NUM_CMD_BYTES, W_CMD,
+				       category, reg >> 8, reg & 0xff,
+				       val & 0xff, val >> 8};
+
+		/* calculate checksum */
+		buf[9] = W_NUM_BYTES + W_NUM_CMDS + W_NUM_CMD_BYTES + W_CMD +
+			 category + (reg >> 8) + (reg & 0xff) + (val >> 8) + (val & 0xff);
+
+		ret = i2c_master_send(client, buf, W_NUM_BYTES);
+
+		if (ret < 0) {
+			dev_err(&client->dev,
+				"write fail: chip 0x%x register 0x%x: %d\n",
+				client->addr, reg, ret);
+		}
+	} else if (strcmp(intf, "address") == 0) {
+		val = swab16(val);
+		reg16_write(client, 0xFFFF, category);
+		ret = reg16_write16(client, reg, val);
+	} else {
+		dev_err(&client->dev, "invalid register acces interface %s\n", intf);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static int isx019_set_regs(struct i2c_client *client,
+			   const struct isx019_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == ISX019_DELAY) {
+			mdelay(regs[i].val);
+			continue;
+		}
+
+		isx019_write16(client, regs[i].reg >> 8, regs[i].reg & 0xff, regs[i].val);
+	}
+
+	return 0;
+}
+
+static void isx019_otp_id_read(struct i2c_client *client)
+{
+	struct isx019_priv *priv = to_isx019(client);
+	int i;
+	u16 val = 0;
+
+	/* read camera id from isx019 OTP memory */
+	for (i = 0; i < 6; i+=2) {
+		isx019_read16(client, 8, 0x60 + i, &val);
+		priv->id[i] = val >> 8;
+		priv->id[i+1] = val & 0xff;
+	}
+}
+
+static int isx019_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int isx019_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = ISX019_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int isx019_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = ISX019_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int isx019_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = ISX019_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int isx019_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+
+	isx019_otp_id_read(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = ISX019_PID >> 8;
+	edid->edid[9] = ISX019_PID & 0xff;
+
+	return 0;
+}
+
+static int isx019_set_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int isx019_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int isx019_g_mbus_config(struct v4l2_subdev *sd,
+				struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int isx019_g_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val = 0;
+
+	ret = isx019_read16(client, (u16)reg->reg >> 8, (u16)reg->reg & 0xff, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int isx019_s_register(struct v4l2_subdev *sd,
+			     const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return isx019_write16(client, (u16)reg->reg >> 8, (u16)reg->reg & 0xff, (u16)reg->val);
+}
+#endif
+
+static struct v4l2_subdev_core_ops isx019_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = isx019_g_register,
+	.s_register = isx019_s_register,
+#endif
+};
+
+static int isx019_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+	int ret = -EINVAL;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops isx019_ctrl_ops = {
+	.s_ctrl = isx019_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops isx019_video_ops = {
+	.s_stream	= isx019_s_stream,
+	.g_mbus_config	= isx019_g_mbus_config,
+};
+
+static const struct v4l2_subdev_pad_ops isx019_subdev_pad_ops = {
+	.get_edid	= isx019_get_edid,
+	.enum_mbus_code	= isx019_enum_mbus_code,
+	.get_selection	= isx019_get_selection,
+	.set_selection	= isx019_set_selection,
+	.get_fmt	= isx019_get_fmt,
+	.set_fmt	= isx019_set_fmt,
+};
+
+static struct v4l2_subdev_ops isx019_subdev_ops = {
+	.core	= &isx019_core_ops,
+	.video	= &isx019_video_ops,
+	.pad	= &isx019_subdev_pad_ops,
+};
+
+static ssize_t isx019_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+
+	isx019_otp_id_read(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_isx019, S_IRUGO, isx019_otp_id_show, NULL);
+
+static int isx019_initialize(struct i2c_client *client)
+{
+	struct isx019_priv *priv = to_isx019(client);
+	u16 pid = 0, val = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(isx019_i2c_addr); i++) {
+		setup_i2c_translator(client, priv->ser_addr, isx019_i2c_addr[i]);
+
+		/* check model ID */
+		isx019_read16(client, 0, ISX019_PID_REG, &pid);
+
+		if ((pid & 0xff00) == ISX019_PID)
+			break;
+	}
+
+	if ((pid & 0xff00) != ISX019_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	/* Read OTP IDs */
+	isx019_otp_id_read(client);
+	/* Program wizard registers */
+	isx019_set_regs(client, isx019_regs, ARRAY_SIZE(isx019_regs));
+	/* read resolution used by current firmware */
+	isx019_read16(client, 86, 0x8, &val);
+	priv->max_width = val;
+	isx019_read16(client, 86, 0xa, &val);
+	priv->max_height = val;
+
+	dev_info(&client->dev, "PID %x (rev %x), res %dx%d, if=%s, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid & 0xff00, pid & 0xff, priv->max_width, priv->max_height, intf, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int isx019_parse_dt(struct device_node *np, struct isx019_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int isx019_probe(struct i2c_client *client,
+			const struct i2c_device_id *did)
+{
+	struct isx019_priv *priv;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &isx019_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = isx019_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = isx019_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_isx019) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int isx019_remove(struct i2c_client *client)
+{
+	struct isx019_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_isx019);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id isx019_id[] = {
+	{ "isx019", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, isx019_id);
+
+static const struct of_device_id isx019_of_ids[] = {
+	{ .compatible = "sony,isx019", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, isx019_of_ids);
+
+static struct i2c_driver isx019_i2c_driver = {
+	.driver	= {
+		.name		= "isx019",
+		.of_match_table	= isx019_of_ids,
+	},
+	.probe		= isx019_probe,
+	.remove		= isx019_remove,
+	.id_table	= isx019_id,
+};
+
+module_i2c_driver(isx019_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for ISX019");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/isx019.h b/drivers/media/i2c/imagers/isx019.h
new file mode 100644
index 0000000..6d936ab
--- /dev/null
+++ b/drivers/media/i2c/imagers/isx019.h
@@ -0,0 +1,30 @@
+/*
+ * Sony isx019 (isp) camera setup 1280x800@30/UYVY/BT601/8bit
+ *
+ * Copyright (C) 2018-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+//#define ISX019_MAX_WIDTH	1280
+//#define ISX019_MAX_HEIGHT	960
+
+#define ISX019_DELAY		0xffff
+
+struct isx019_reg {
+	u16	reg;
+	u16	val;
+};
+
+static const struct isx019_reg isx019_regs[] = {
+#if 0
+/* enable FSIN */
+{ISX019_DELAY, 100},
+#endif
+/* disable embedded data */
+{0x504c, 0x0},
+{0x504e, 0x0},
+};
diff --git a/drivers/media/i2c/imagers/ov10635.c b/drivers/media/i2c/imagers/ov10635.c
index 00507ba..ffd8a32 100644
--- a/drivers/media/i2c/imagers/ov10635.c
+++ b/drivers/media/i2c/imagers/ov10635.c
@@ -521,7 +521,7 @@ static int ov10635_initialize(struct i2c_client *client)
 	reg16_write(client, 0x103, 0x1);
 	udelay(100);
 	/* Program wizard registers */
-	ov10635_set_regs(client, ov10635_regs_wizard, ARRAY_SIZE(ov10635_regs_wizard));
+	ov10635_set_regs(client, ov10635_regs, ARRAY_SIZE(ov10635_regs));
 	/* Set DVP bit swap */
 	reg16_write(client, 0x4709, priv->dvp_order << 4);
 	/* Set VSYNC inversion */
@@ -534,23 +534,11 @@ static int ov10635_initialize(struct i2c_client *client)
 	return 0;
 }
 
-static const struct i2c_device_id ov10635_id[] = {
-	{ "ov10635", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, ov10635_id);
-
-static const struct of_device_id ov10635_of_ids[] = {
-	{ .compatible = "ovti,ov10635", },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, ov10635_of_ids);
-
 static int ov10635_parse_dt(struct device_node *np, struct ov10635_priv *priv)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
-	u32 addrs[2], naddrs;
 	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
 
 	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
 	if (naddrs != 2) {
@@ -685,6 +673,18 @@ static int ov10635_remove(struct i2c_client *client)
 	return 0;
 }
 
+static const struct i2c_device_id ov10635_id[] = {
+	{ "ov10635", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov10635_id);
+
+static const struct of_device_id ov10635_of_ids[] = {
+	{ .compatible = "ovti,ov10635", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov10635_of_ids);
+
 static struct i2c_driver ov10635_i2c_driver = {
 	.driver	= {
 		.name		= "ov10635",
diff --git a/drivers/media/i2c/imagers/ov10635.h b/drivers/media/i2c/imagers/ov10635.h
index cf2ce07..03346b8 100644
--- a/drivers/media/i2c/imagers/ov10635.h
+++ b/drivers/media/i2c/imagers/ov10635.h
@@ -1,5 +1,5 @@
 /*
- * OmniVision ov10635 sensor camera wizard 1280x800@30/UYVY/BT601/8bit
+ * OmniVision ov10635 sensor camera setup 1280x800@30/UYVY/BT601/8bit
  *
  * Copyright (C) 2015-2020 Cogent Embedded, Inc.
  *
@@ -37,7 +37,7 @@ struct ov10635_reg {
 	u8	val;
 };
 
-static const struct ov10635_reg ov10635_regs_wizard[] = {
+static const struct ov10635_reg ov10635_regs[] = {
 //{0x0103, 0x01},
 {0x300C, 0x61},
 {0x300C, 0x61},
diff --git a/drivers/media/i2c/imagers/ov2311.c b/drivers/media/i2c/imagers/ov2311.c
new file mode 100644
index 0000000..db68b62
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov2311.c
@@ -0,0 +1,588 @@
+/*
+ * OmniVision ov2311 sensor camera driver
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "ov2311.h"
+
+#define OV2311_I2C_ADDR			0x60
+
+#define OV2311_PIDA_REG			0x300a
+#define OV2311_PIDB_REG			0x300b
+#define OV2311_REV_REG			0x300c
+#define OV2311_PID			0x2311
+
+#define OV2311_MEDIA_BUS_FMT		MEDIA_BUS_FMT_Y8_1X8
+
+struct ov2311_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				subsampling;
+	int				fps_denominator;
+	int				init_complete;
+	u8				id[6];
+	int				dvp_order;
+	/* serializers */
+	int				ser_addr;
+};
+
+static inline struct ov2311_priv *to_ov2311(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov2311_priv, sd);
+}
+
+static inline struct v4l2_subdev *ov2311_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov2311_priv, hdl)->sd;
+}
+
+static int ov2311_set_regs(struct i2c_client *client,
+			   const struct ov2311_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == OV2311_DELAY) {
+			mdelay(regs[i].val);
+			continue;
+		}
+
+		if (reg16_write(client, regs[i].reg, regs[i].val)) {
+			usleep_range(100, 150); /* wait 100ns */
+			reg16_write(client, regs[i].reg, regs[i].val);
+		}
+	}
+
+	return 0;
+}
+
+static void ov2311_otp_id_read(struct i2c_client *client)
+{
+	struct ov2311_priv *priv = to_ov2311(client);
+	int i;
+
+	reg16_write(client, 0x3d81, 1);
+	usleep_range(25000, 25500); /* wait 25 ms */
+
+	for (i = 0; i < 6; i++) {
+		/* first 6 bytes are equal on all ov2311 */
+		reg16_read(client, 0x7000 + i + 6, &priv->id[i]);
+	}
+}
+
+static int ov2311_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ov2311_set_window(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	dev_dbg(&client->dev, "L=%d T=%d %dx%d\n", priv->rect.left, priv->rect.top, priv->rect.width, priv->rect.height);
+#if 0
+	/* setup resolution */
+	reg16_write(client, 0x3808, priv->rect.width >> 8);
+	reg16_write(client, 0x3809, priv->rect.width & 0xff);
+	reg16_write(client, 0x380a, priv->rect.height >> 8);
+	reg16_write(client, 0x380b, priv->rect.height & 0xff);
+
+	/* horiz isp windowstart */
+	reg16_write(client, 0x3810, priv->rect.left >> 8);
+	reg16_write(client, 0x3811, priv->rect.left & 0xff);
+	reg16_write(client, 0x3812, priv->rect.top >> 8);
+	reg16_write(client, 0x3813, priv->rect.top & 0xff);
+#endif
+	return 0;
+};
+
+static int ov2311_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = OV2311_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov2311_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = OV2311_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ov2311_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = OV2311_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ov2311_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = OV2311_PID >> 8;
+	edid->edid[9] = OV2311_PID & 0xff;
+
+	return 0;
+}
+
+static int ov2311_set_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > OV2311_MAX_WIDTH) ||
+	    (rect->top + rect->height > OV2311_MAX_HEIGHT))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	ov2311_set_window(sd);
+
+	return 0;
+}
+
+static int ov2311_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = OV2311_MAX_WIDTH;
+		sel->r.height = OV2311_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = OV2311_MAX_WIDTH;
+		sel->r.height = OV2311_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ov2311_g_mbus_config(struct v4l2_subdev *sd,
+				struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov2311_g_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	__be64 be_val;
+
+	if (!reg->size)
+		reg->size = sizeof(u8);
+	if (reg->size > sizeof(reg->val))
+		reg->size = sizeof(reg->val);
+
+	ret = reg16_read_n(client, (u16)reg->reg, (u8*)&be_val, reg->size);
+	be_val = be_val << ((sizeof(be_val) - reg->size) * 8);
+	reg->val = be64_to_cpu(be_val);
+
+	return ret;
+}
+
+static int ov2311_s_register(struct v4l2_subdev *sd,
+			      const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 size = reg->size;
+	int ret;
+	__be64 be_val;
+
+	if (!size)
+		size = sizeof(u8);
+	if (size > sizeof(reg->val))
+		size = sizeof(reg->val);
+
+	be_val = cpu_to_be64(reg->val);
+	be_val = be_val >> ((sizeof(be_val) - size) * 8);
+	ret = reg16_write_n(client, (u16)reg->reg, (u8*)&be_val, size);
+
+	return ret;
+}
+#endif
+
+static struct v4l2_subdev_core_ops ov2311_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ov2311_g_register,
+	.s_register = ov2311_s_register,
+#endif
+};
+
+static int ov2311_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ov2311_to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+	int ret = 0;
+	u8 val = 0;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+		break;
+	case V4L2_CID_GAIN:
+		reg16_write(client, 0x350A, ctrl->val / 0x3ff); // COARSE: 4.10 format
+		reg16_write(client, 0x350B, (ctrl->val % 0x3ff) >> 2); // FINE: 4.10 format
+		reg16_write(client, 0x350C, (ctrl->val % 0x3ff) << 6); // FINE: 4.10 format
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		reg16_write(client, 0x3508, ctrl->val / 0xf); // COARSE: 5.4 format
+		reg16_write(client, 0x3509, (ctrl->val % 0xf) << 4); // FINE: 5.4 format
+		break;
+	case V4L2_CID_EXPOSURE:
+		reg16_write(client, 0x3501, ctrl->val >> 8);
+		reg16_write(client, 0x3502, ctrl->val & 0xff);
+		break;
+	case V4L2_CID_HFLIP:
+		reg16_read(client, 0x3821, &val);
+		val &= ~0x04;
+		val |= (ctrl->val ? 0x04 : 0);
+		reg16_write(client, 0x3821, val);
+		break;
+	case V4L2_CID_VFLIP:
+		reg16_read(client, 0x3820, &val);
+		val &= ~0x44;
+		val |= (ctrl->val ? 0x44 : 0);
+		reg16_write(client, 0x3820, val);
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov2311_ctrl_ops = {
+	.s_ctrl = ov2311_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ov2311_video_ops = {
+	.s_stream	= ov2311_s_stream,
+	.g_mbus_config	= ov2311_g_mbus_config,
+};
+
+static const struct v4l2_subdev_pad_ops ov2311_subdev_pad_ops = {
+	.get_edid	= ov2311_get_edid,
+	.enum_mbus_code	= ov2311_enum_mbus_code,
+	.get_selection	= ov2311_get_selection,
+	.set_selection	= ov2311_set_selection,
+	.get_fmt	= ov2311_get_fmt,
+	.set_fmt	= ov2311_set_fmt,
+};
+
+static struct v4l2_subdev_ops ov2311_subdev_ops = {
+	.core	= &ov2311_core_ops,
+	.video	= &ov2311_video_ops,
+	.pad	= &ov2311_subdev_pad_ops,
+};
+
+static ssize_t ov2311_otp_id_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ov2311, S_IRUGO, ov2311_otp_id_show, NULL);
+
+static int ov2311_initialize(struct i2c_client *client)
+{
+	struct ov2311_priv *priv = to_ov2311(client);
+	u16 pid;
+	u8 val = 0, rev = 0;
+
+	setup_i2c_translator(client, priv->ser_addr, OV2311_I2C_ADDR);
+
+	reg16_read(client, OV2311_PIDA_REG, &val);
+	pid = val;
+	reg16_read(client, OV2311_PIDB_REG, &val);
+	pid = (pid << 8) | val;
+
+	if (pid != OV2311_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	switch (get_des_id(client)) {
+	case UB960_ID:
+		reg8_write_addr(client, priv->ser_addr, 0x02, 0x13); /* MIPI 2-lanes */
+		break;
+	case MAX9296A_ID:
+	case MAX96712_ID:
+		reg16_write_addr(client, priv->ser_addr, MAX9295_MIPI_RX1, 0x11); /* MIPI 2-lanes */
+		break;
+	}
+
+	/* check revision */
+	reg16_read(client, OV2311_REV_REG, &rev);
+	/* Program wizard registers */
+	ov2311_set_regs(client, ov2311_regs_r1c, ARRAY_SIZE(ov2311_regs_r1c));
+	/* Read OTP IDs */
+	ov2311_otp_id_read(client);
+
+	dev_info(&client->dev, "PID %x (rev %x), res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, rev, OV2311_MAX_WIDTH, OV2311_MAX_HEIGHT, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int ov2311_parse_dt(struct device_node *np, struct ov2311_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	u32 addrs[2], naddrs;
+	struct fwnode_handle *ep;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int ov2311_probe(struct i2c_client *client,
+			const struct i2c_device_id *did)
+{
+	struct ov2311_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ov2311_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = OV2311_MAX_WIDTH;
+	priv->rect.height = OV2311_MAX_HEIGHT;
+	priv->fps_denominator = 30;
+
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 0xff, 1, 0x30);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 4, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 0xff, 1, 0xff);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_HUE, 0, 255, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_GAMMA, 0, 0xffff, 1, 0x233);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0x3ff*4, 1, 0x3ff);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_ANALOGUE_GAIN, 0, 0xf*5, 1, 0xf);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0x580, 1, 0x57c);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ov2311_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ov2311_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ov2311) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ov2311_remove(struct i2c_client *client)
+{
+	struct ov2311_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ov2311);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov2311_id[] = {
+	{ "ov2311", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov2311_id);
+
+static const struct of_device_id ov2311_of_ids[] = {
+	{ .compatible = "ovti,ov2311", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov2311_of_ids);
+
+static struct i2c_driver ov2311_i2c_driver = {
+	.driver	= {
+		.name		= "ov2311",
+		.of_match_table	= ov2311_of_ids,
+	},
+	.probe		= ov2311_probe,
+	.remove		= ov2311_remove,
+	.id_table	= ov2311_id,
+};
+
+module_i2c_driver(ov2311_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for OV2311");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/ov2311.h b/drivers/media/i2c/imagers/ov2311.h
new file mode 100644
index 0000000..a525b9f
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov2311.h
@@ -0,0 +1,217 @@
+/*
+ * OmniVision ov2311 sensor camera setup 1600x130@30/GREY8/MIPI
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+//#define OV2311_DISPLAY_PATTERN
+//#define OV2311_FSIN_ENABLE
+
+#define OV2311_MAX_WIDTH	1600
+#define OV2311_MAX_HEIGHT	1300
+
+#define OV2311_DELAY		0xffff
+
+#define OV2311_SENSOR_WIDTH	1616
+#define OV2311_SENSOR_HEIGHT	1316
+
+#define OV2311_X_START		((OV2311_SENSOR_WIDTH - OV2311_MAX_WIDTH) / 2)
+#define OV2311_Y_START		((OV2311_SENSOR_HEIGHT - OV2311_MAX_HEIGHT) / 2)
+#define OV2311_X_END		(OV2311_X_START + OV2311_MAX_WIDTH - 1)
+#define OV2311_Y_END		(OV2311_Y_START + OV2311_MAX_HEIGHT - 1)
+
+struct ov2311_reg {
+	u16	reg;
+	u8	val;
+};
+
+/* R1600x1300 RAW8 MIPI 60fps */
+static const struct ov2311_reg ov2311_regs_r1c[] = {
+{0x0103, 0x01},
+{0x0100, 0x00},
+{0x010c, 0x02},
+{0x010b, 0x01},
+{0x0300, 0x01},
+{0x0302, 0x32},
+{0x0303, 0x00},
+{0x0304, 0x03},
+{0x0305, 0x02},
+{0x0306, 0x01},
+{0x030d, 0x5a},
+{0x030e, 0x04},
+{0x3001, 0x02},
+{0x3004, 0x00},
+{0x3005, 0x00},
+{0x3006, 0x0a},
+{0x3011, 0x0d},
+{0x3014, 0x04},
+{0x301c, 0xf0},
+{0x3020, 0x20},
+{0x302c, 0x00},
+{0x302d, 0x00},
+{0x302e, 0x00},
+{0x302f, 0x03},
+{0x3030, 0x10},
+{0x303f, 0x03},
+{0x3103, 0x00},
+{0x3106, 0x08},
+{0x31ff, 0x01},
+{0x3501, 0x05},
+{0x3502, 0x7c},
+{0x3506, 0x00},
+{0x3507, 0x00},
+{0x3620, 0x67},
+{0x3633, 0x78},
+{0x3662, 0x65},
+{0x3664, 0xb0},
+{0x3666, 0x70},
+{0x3670, 0x68},
+{0x3674, 0x10},
+{0x3675, 0x00},
+{0x367e, 0x90},
+{0x3680, 0x84},
+{0x36a2, 0x04},
+{0x36a3, 0x80},
+{0x36b0, 0x00},
+{0x3700, 0x35},
+{0x3704, 0x39},
+{0x370a, 0x50},
+{0x3712, 0x00},
+{0x3713, 0x02},
+{0x3778, 0x00},
+{0x379b, 0x01},
+{0x379c, 0x10},
+{0x3800, 0x00},
+{0x3801, 0x00},
+{0x3802, 0x00},
+{0x3803, 0x00},
+{0x3804, 0x06},
+{0x3805, 0x4f},
+{0x3806, 0x05},
+{0x3807, 0x23},
+{0x3808, OV2311_MAX_WIDTH >> 8},
+{0x3809, OV2311_MAX_WIDTH & 0xff},
+{0x380a, OV2311_MAX_HEIGHT >> 8},
+{0x380b, OV2311_MAX_HEIGHT & 0xff},
+{0x380c, 0x03},
+{0x380d, 0xa8},
+{0x380e, 0x05},
+{0x380f, 0x88},
+{0x3810, OV2311_X_START >> 8},
+{0x3811, OV2311_X_START & 0xff},
+{0x3812, OV2311_Y_START >> 8},
+{0x3813, OV2311_X_START & 0xff},
+{0x3814, 0x11},
+{0x3815, 0x11},
+{0x3816, 0x00},
+{0x3817, 0x01},
+{0x3818, 0x00},
+{0x3819, 0x05},
+{0x3820, 0x00},
+{0x3821, 0x00},
+{0x382b, 0x5a},
+{0x382c, 0x0a},
+{0x382d, 0xf8},
+{0x3881, 0x44},
+{0x3882, 0x02},
+{0x3883, 0x8c},
+{0x3885, 0x07},
+{0x389d, 0x03},
+{0x38a6, 0x00},
+{0x38a7, 0x01},
+{0x38b3, 0x07},
+{0x38b1, 0x00},
+{0x38e5, 0x02},
+{0x38e7, 0x00},
+{0x38e8, 0x00},
+{0x3910, 0xff},
+{0x3911, 0xff},
+{0x3912, 0x08},
+{0x3913, 0x00},
+{0x3914, 0x00},
+{0x3915, 0x00},
+{0x391c, 0x00},
+{0x3920, 0xff},
+{0x3921, 0x80},
+{0x3922, 0x00},
+{0x3923, 0x00},
+{0x3924, 0x05},
+{0x3925, 0x00},
+{0x3926, 0x00},
+{0x3927, 0x00},
+{0x3928, 0x1a},
+{0x392d, 0x03},
+{0x392e, 0xa8},
+{0x392f, 0x08},
+{0x4001, 0x00},
+{0x4003, 0x40},
+{0x4008, 0x04},
+{0x4009, 0x1b},
+{0x400c, 0x04},
+{0x400d, 0x1b},
+{0x4010, 0xf4},
+{0x4011, 0x00},
+{0x4016, 0x00},
+{0x4017, 0x04},
+{0x4042, 0x11},
+{0x4043, 0x70},
+{0x4045, 0x00},
+{0x4409, 0x5f},
+{0x4509, 0x00},
+{0x450b, 0x00},
+{0x4600, 0x00},
+{0x4601, 0xa0},
+{0x4708, 0x09},
+{0x470c, 0x81},
+{0x4710, 0x06},
+{0x4711, 0x00},
+{0x4800, 0x00},
+{0x481f, 0x30},
+{0x4837, 0x14},
+{0x4f00, 0x00},
+{0x4f07, 0x00},
+{0x4f08, 0x03},
+{0x4f09, 0x08},
+{0x4f0c, 0x05},
+{0x4f0d, 0xb4},
+{0x4f10, 0x00},
+{0x4f11, 0x00},
+{0x4f12, 0x07},
+{0x4f13, 0xe2},
+{0x5000, 0x9f},
+{0x5001, 0x20},
+{0x5026, 0x00},
+{0x5c00, 0x00},
+{0x5c01, 0x2c},
+{0x5c02, 0x00},
+{0x5c03, 0x7f},
+{0x5e00, 0x00},
+{0x5e01, 0x41},
+{0x38b1, 0x02},
+{0x3880, 0x00},
+
+#if 1  /* Y8 mode */
+{0x3016, 0xF1},
+{0x0100, 0x01},
+{0x4814, 0x6A}, //; dt_man en, both embed/image data type are 0x2A
+{0x3218, 0x32},
+{0x3216, 0x01},
+{0x3208, 0x04},
+{0x3D81, 0x01},
+{0x4605, 0x02},
+{0x4816, 0x0A},
+{0x3208, 0x14},
+{0x3662, 0x67}, //; [1] raw8
+{0x366F, 0x1A}, //; [6] MSB
+//{0x3674, 0x11}, //; [0] embed_en, add embed data before normal image
+{0x3674, 0x10}, //; [0] embed_dis, add embed data before normal image
+{0x3016, 0xF0},
+#endif
+
+{0x0100, 0x01},
+};
diff --git a/drivers/media/i2c/imagers/ov490.c b/drivers/media/i2c/imagers/ov490.c
index 91c0555..7e66851 100644
--- a/drivers/media/i2c/imagers/ov490.c
+++ b/drivers/media/i2c/imagers/ov490.c
@@ -1,5 +1,5 @@
 /*
- * OmniVision ov490-ov10640 sensor camera glue
+ * OmniVision ov490-ov10640 sensor camera driver
  *
  * Copyright (C) 2016-2020 Cogent Embedded, Inc.
  *
@@ -867,7 +867,7 @@ static int ov490_initialize(struct i2c_client *client)
 	reg16_read(client, OV490_ISP_VSIZE_LOW, &val);
 	priv->max_height = (priv->max_height << 8) | val;
 	/* Program wizard registers */
-	ov490_set_regs(client, ov490_regs_wizard, ARRAY_SIZE(ov490_regs_wizard));
+	ov490_set_regs(client, ov490_regs, ARRAY_SIZE(ov490_regs));
 	/* Set DVP bit swap */
 	reg16_write(client, 0xFFFD, 0x80);
 	reg16_write(client, 0xFFFE, 0x28);
@@ -884,18 +884,6 @@ static int ov490_initialize(struct i2c_client *client)
 	return 0;
 }
 
-static const struct i2c_device_id ov490_id[] = {
-	{ "ov490", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, ov490_id);
-
-static const struct of_device_id ov490_of_ids[] = {
-	{ .compatible = "ovti,ov490", },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, ov490_of_ids);
-
 static int ov490_parse_dt(struct device_node *np, struct ov490_priv *priv)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
@@ -1058,6 +1046,18 @@ static int ov490_remove(struct i2c_client *client)
 	return 0;
 }
 
+static const struct i2c_device_id ov490_id[] = {
+	{ "ov490", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov490_id);
+
+static const struct of_device_id ov490_of_ids[] = {
+	{ .compatible = "ovti,ov490", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov490_of_ids);
+
 static struct i2c_driver ov490_i2c_driver = {
 	.driver	= {
 		.name		= "ov490",
diff --git a/drivers/media/i2c/imagers/ov490.h b/drivers/media/i2c/imagers/ov490.h
index 5b8cdf8..dae9372 100644
--- a/drivers/media/i2c/imagers/ov490.h
+++ b/drivers/media/i2c/imagers/ov490.h
@@ -1,5 +1,5 @@
 /*
- * OmniVision ov490-ov10640 sensor camera wizard 1280x1080@30/UYVY/BT601/8bit
+ * OmniVision ov490-ov10640 sensor camera setup 1280x1080@30/UYVY/BT601/8bit
  *
  * Copyright (C) 2016-2020 Cogent Embedded, Inc.
  *
@@ -16,7 +16,7 @@ struct ov490_reg {
 	u8	val;
 };
 
-static const struct ov490_reg ov490_regs_wizard[] = {
+static const struct ov490_reg ov490_regs[] = {
 /* The following registers should match firmware */
 {0xfffd, 0x80},
 {0xfffe, 0x82},
diff --git a/drivers/media/i2c/imagers/ov495.c b/drivers/media/i2c/imagers/ov495.c
new file mode 100644
index 0000000..7618697
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov495.c
@@ -0,0 +1,622 @@
+/*
+ * OmniVision ov495-2775 sensor camera glue
+ *
+ * Copyright (C) 2017-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "ov495.h"
+
+#define OV495_I2C_ADDR		0x24
+
+#define OV495_PID_REGA		0x300a
+#define OV495_PID_REGB		0x300b
+#define OV495_PID		0x0495
+
+#define OV495_ISP_HSIZE_LOW	0x60
+#define OV495_ISP_HSIZE_HIGH	0x61
+#define OV495_ISP_VSIZE_LOW	0x62
+#define OV495_ISP_VSIZE_HIGH	0x63
+
+#define OV495_MEDIA_BUS_FMT	MEDIA_BUS_FMT_UYVY8_2X8
+
+struct ov495_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	/* serializers */
+	int				ser_addr;
+	int				des_addr;
+};
+
+static int conf_link;
+module_param(conf_link, int, 0644);
+MODULE_PARM_DESC(conf_link, " Force configuration link. Used only if robust firmware flashing required (f.e. recovery)");
+
+static inline struct ov495_priv *to_ov495(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov495_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov495_priv, hdl)->sd;
+}
+
+static int ov495_set_regs(struct i2c_client *client,
+			  const struct ov495_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (reg16_write(client, regs[i].reg, regs[i].val)) {
+			usleep_range(100, 150); /* wait 100 us */
+			reg16_write(client, regs[i].reg, regs[i].val);
+		}
+	}
+
+	return 0;
+}
+
+static void ov495_otp_id_read(struct i2c_client *client)
+{
+	struct ov495_priv *priv = to_ov495(client);
+	int i;
+
+#if 0
+	/* read camera id from ov495 OTP memory */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x20);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x7384, 0x40); /* manual mode, bank#0 */
+	reg16_write(client, 0x7381, 1); /* start OTP read */
+
+	usleep_range(25000, 26000); /* wait 25 ms */
+
+	for (i = 0; i < 6; i++)
+		reg16_read(client, 0x7300 + i + 4, &priv->id[i]);
+#else
+	/* read camera id from ov2775 OTP memory */
+	reg16_write(client, 0x3516, 0x00); /* unlock write */
+	reg16_write(client, 0x0FFC, 0);
+	reg16_write(client, 0x0500, 0x00); /* write 0x34a1 -> 1 */
+	reg16_write(client, 0x0501, 0x34);
+	reg16_write(client, 0x0502, 0xa1);
+	reg16_write(client, 0x0503, 1);
+	reg16_write(client, 0x30C0, 0xc1);
+
+	usleep_range(25000, 25500); /* wait 25 ms */
+
+	for (i = 0; i < 6; i++) {
+		reg16_write(client, 0x3516, 0x00); /* unlock write */
+		reg16_write(client, 0x0500, 0x01); /* read (0x7a00 + i) */
+		reg16_write(client, 0x0501, 0x7a);
+		reg16_write(client, 0x0502, 0x00 + i + (i < 3 ? 11 : 3)); /* take bytes 11,12,13,6,7,8 */
+		reg16_write(client, 0x30C0, 0xc1);
+		usleep_range(1000, 1500); /* wait 1 ms */
+		reg16_read(client, 0x0500, &priv->id[i]);
+	}
+#endif
+}
+
+static int ov495_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ov495_get_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = OV495_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov495_set_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = OV495_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ov495_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = OV495_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ov495_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = OV495_PID >> 8;
+	edid->edid[9] = OV495_PID & 0xff;
+
+	return 0;
+}
+
+static int ov495_set_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int ov495_get_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ov495_g_mbus_config(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov495_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 val = 0;
+
+	ret = reg16_read(client, (u16)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int ov495_s_register(struct v4l2_subdev *sd,
+			    const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = reg16_write(client, (u16)reg->reg, (u8)reg->val);
+	if ((u8)reg->reg == 0xFFFD)
+		usleep_range(100, 150); /* wait 100 us */
+	if ((u8)reg->reg == 0xFFFE)
+		usleep_range(100, 150); /* wait 100 us */
+	return ret;
+}
+#endif
+
+static struct v4l2_subdev_core_ops ov495_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ov495_g_register,
+	.s_register = ov495_s_register,
+#endif
+};
+
+static int ov495_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+	int ret = -EINVAL;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		break;
+	case V4L2_CID_CONTRAST:
+		break;
+	case V4L2_CID_SATURATION:
+		break;
+	case V4L2_CID_HUE:
+		break;
+	case V4L2_CID_GAMMA:
+		break;
+	case V4L2_CID_SHARPNESS:
+		break;
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+		break;
+	case V4L2_CID_HFLIP:
+		ret = reg16_write(client, 0x3516, 0x00);
+		ret |= reg16_write(client, 0x0ffc, 0x00);
+		ret |= reg16_write(client, 0x0500, ctrl->val);
+		ret |= reg16_write(client, 0x0501, 0x00);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x30C0, 0xdc);
+		ret |= reg16_write(client, 0x3516, 0x01);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = reg16_write(client, 0x3516, 0x00);
+		ret |= reg16_write(client, 0x0ffc, 0x00);
+		ret |= reg16_write(client, 0x0500, ctrl->val);
+		ret |= reg16_write(client, 0x0501, 0x01);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x30C0, 0xdc);
+		ret |= reg16_write(client, 0x3516, 0x01);
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov495_ctrl_ops = {
+	.s_ctrl = ov495_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ov495_video_ops = {
+	.s_stream	= ov495_s_stream,
+	.g_mbus_config	= ov495_g_mbus_config,
+};
+
+static const struct v4l2_subdev_pad_ops ov495_subdev_pad_ops = {
+	.get_edid	= ov495_get_edid,
+	.enum_mbus_code	= ov495_enum_mbus_code,
+	.get_selection	= ov495_get_selection,
+	.set_selection	= ov495_set_selection,
+	.get_fmt	= ov495_get_fmt,
+	.set_fmt	= ov495_set_fmt,
+};
+
+static struct v4l2_subdev_ops ov495_subdev_ops = {
+	.core	= &ov495_core_ops,
+	.video	= &ov495_video_ops,
+	.pad	= &ov495_subdev_pad_ops,
+};
+
+static ssize_t ov495_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ov495, S_IRUGO, ov495_otp_id_show, NULL);
+
+static int ov495_initialize(struct i2c_client *client)
+{
+	struct ov495_priv *priv = to_ov495(client);
+	u8 val = 0;
+	u16 pid = 0;
+
+	setup_i2c_translator(client, priv->ser_addr, OV495_I2C_ADDR);
+
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_read(client, OV495_PID_REGA, &val);
+	pid = val;
+	reg16_read(client, OV495_PID_REGB, &val);
+	pid = (pid << 8) | val;
+
+	if (pid != OV495_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+#if 0
+	/* setup XCLK */
+	tmp_addr = client->addr;
+	if (priv->ti9x4_addr) {
+		/* CLK_OUT=22.5792*160*M/N/CLKDIV -> CLK_OUT=25MHz: CLKDIV=4, M=7, N=253: 22.5792*160/4*7/253=24.989MHz=CLK_OUT */
+		client->addr = priv->ti9x3_addr;			/* Serializer I2C address */
+		reg8_write(client, 0x06, 0x47);				/* Set CLKDIV and M */
+		reg8_write(client, 0x07, 0xfd);				/* Set N */
+	}
+	client->addr = tmp_addr;
+#endif
+
+	if (unlikely(conf_link))
+		goto out;
+
+#if 0
+	/* read resolution used by current firmware */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x82);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_read(client, OV495_ISP_HSIZE_HIGH, &val);
+	priv->max_width = val;
+	reg16_read(client, OV495_ISP_HSIZE_LOW, &val);
+	priv->max_width = (priv->max_width << 8) | val;
+	reg16_read(client, OV495_ISP_VSIZE_HIGH, &val);
+	priv->max_height = val;
+	reg16_read(client, OV495_ISP_VSIZE_LOW, &val);
+	priv->max_height = (priv->max_height << 8) | val;
+#else
+	priv->max_width = 1920;
+	priv->max_height = 1080;
+#endif
+	/* set virtual channel */
+//	ov495_regs[3].val = 0x1e | (priv->port << 6);
+	/* Program wizard registers */
+	ov495_set_regs(client, ov495_regs, ARRAY_SIZE(ov495_regs));
+	/* Read OTP IDs */
+	ov495_otp_id_read(client);
+
+out:
+	dev_info(&client->dev, "PID %x, res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, priv->max_width, priv->max_height, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int ov495_parse_dt(struct device_node *np, struct ov495_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int ov495_probe(struct i2c_client *client,
+		       const struct i2c_device_id *did)
+{
+	struct ov495_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ov495_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ov495_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ov495_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ov495) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ov495_remove(struct i2c_client *client)
+{
+	struct ov495_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ov495);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov495_id[] = {
+	{ "ov495", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov495_id);
+
+static const struct of_device_id ov495_of_ids[] = {
+	{ .compatible = "ovti,ov495", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov495_of_ids);
+
+static struct i2c_driver ov495_i2c_driver = {
+	.driver	= {
+		.name		= "ov495",
+		.of_match_table	= ov495_of_ids,
+	},
+	.probe		= ov495_probe,
+	.remove		= ov495_remove,
+	.id_table	= ov495_id,
+};
+
+module_i2c_driver(ov495_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for OV495-2775");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/ov495.h b/drivers/media/i2c/imagers/ov495.h
new file mode 100644
index 0000000..18ec0e4
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov495.h
@@ -0,0 +1,23 @@
+/*
+ * OmniVision ov495-ov2775 sensor camera setup 1920x1080@30/UYVY/MIPI
+ *
+ * Copyright (C) 2017-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+struct ov495_reg {
+	u16	reg;
+	u8	val;
+};
+
+static struct ov495_reg ov495_regs[] = {
+{0x3516, 0x00}, /* unlock write */
+{0xFFFD, 0x80},
+{0xFFFE, 0x20},
+{0x8017, 0x1e | (0 << 6)},
+{0x7c10, 0x01}, /* UYVY */
+};
-- 
2.7.4

