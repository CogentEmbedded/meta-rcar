From c51797139db82b81d4fc8e8b8332e4b86e384214 Mon Sep 17 00:00:00 2001
From: Valentine Barshak <valentine.barshak@cogentembedded.com>
Date: Fri, 25 Sep 2020 18:54:32 +0300
Subject: [PATCH 01/11] generic uio stuff for BSP7

This is generic uio related changed for BSP7 (Yocto4.1.0)
This is based on the "original uio stuff for BSP7" patch
by Vladimir Barinov <vladimir.barinov@cogentembedded.com>.

Signed-off-by: Valentine Barshak <valentine.barshak@cogentembedded.com>
---
 drivers/uio/uio.c                              |  15 ++
 drivers/uio/uio_pdrv_genirq.c                  | 206 ++++++++++++++++++++++++-
 fs/compat_ioctl.c                              |   8 +
 include/dt-bindings/ipmmu/rcar-ipmmu-domains.h |   1 +
 include/dt-bindings/ipmmu/rcar-ipmmu.h         |   6 +
 include/linux/uio_driver.h                     |   2 +
 include/uapi/linux/rcar-ipmmu-domains.h        |  33 ++++
 include/uapi/linux/renesas_uioctl.h            |  23 +++
 8 files changed, 292 insertions(+), 2 deletions(-)
 create mode 120000 include/dt-bindings/ipmmu/rcar-ipmmu-domains.h
 create mode 100644 include/dt-bindings/ipmmu/rcar-ipmmu.h
 create mode 100644 include/uapi/linux/rcar-ipmmu-domains.h
 create mode 100644 include/uapi/linux/renesas_uioctl.h

diff --git a/drivers/uio/uio.c b/drivers/uio/uio.c
index a576989..258cc55 100644
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@ -652,6 +652,20 @@ static ssize_t uio_write(struct file *filep, const char __user *buf,
 	return retval ? retval : sizeof(s32);
 }
 
+static long uio_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
+{
+	struct uio_listener *listener = filep->private_data;
+	struct uio_device *idev = listener->dev;
+
+	if (!idev->info)
+		return -EIO;
+
+	if (!idev->info->ioctl)
+		return -ENOTTY;
+
+	return idev->info->ioctl(idev->info, cmd, arg);
+}
+
 static int uio_find_mem_index(struct vm_area_struct *vma)
 {
 	struct uio_device *idev = vma->vm_private_data;
@@ -821,6 +835,7 @@ static const struct file_operations uio_fops = {
 	.write		= uio_write,
 	.mmap		= uio_mmap,
 	.poll		= uio_poll,
+	.unlocked_ioctl	= uio_ioctl,
 	.fasync		= uio_fasync,
 	.llseek		= noop_llseek,
 };
diff --git a/drivers/uio/uio_pdrv_genirq.c b/drivers/uio/uio_pdrv_genirq.c
index 1303b165..9130adf 100644
--- a/drivers/uio/uio_pdrv_genirq.c
+++ b/drivers/uio/uio_pdrv_genirq.c
@@ -19,11 +19,15 @@
 #include <linux/interrupt.h>
 #include <linux/stringify.h>
 #include <linux/pm_runtime.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
 #include <linux/slab.h>
 
 #include <linux/of.h>
 #include <linux/of_platform.h>
 #include <linux/of_address.h>
+#include <linux/uaccess.h>
+#include <uapi/linux/renesas_uioctl.h>
 
 #define DRIVER_NAME "uio_pdrv_genirq"
 
@@ -32,6 +36,10 @@ struct uio_pdrv_genirq_platdata {
 	spinlock_t lock;
 	unsigned long flags;
 	struct platform_device *pdev;
+	struct clk *clk;
+	struct reset_control *rst;
+	int pwr_cnt;
+	int clk_cnt;
 };
 
 /* Bits in uio_pdrv_genirq_platdata.flags */
@@ -39,12 +47,57 @@ enum {
 	UIO_IRQ_DISABLED = 0,
 };
 
+int local_pm_runtime_get_sync(struct uio_pdrv_genirq_platdata *priv)
+{
+	if (priv->pwr_cnt == 0) {
+		priv->pwr_cnt++;
+		priv->clk_cnt++;
+		return pm_runtime_get_sync(&priv->pdev->dev);
+	}
+
+	return 0;
+}
+
+int local_pm_runtime_put_sync(struct uio_pdrv_genirq_platdata *priv)
+{
+	if (priv->pwr_cnt > 0) {
+		priv->pwr_cnt--;
+		priv->clk_cnt--;
+		if ((priv->clk != NULL) && (priv->clk_cnt < 0)) { // call to pwr manager will decrease further!!!
+			clk_enable(priv->clk);
+			priv->clk_cnt = 0;
+		}
+
+		return pm_runtime_put_sync(&priv->pdev->dev);
+	}
+
+	return 0;
+}
+
+int local_clk_enable(struct uio_pdrv_genirq_platdata *priv)
+{
+	if (priv->clk_cnt == 0) {
+		clk_enable(priv->clk);
+		priv->clk_cnt++;
+	}
+
+	return 0;
+}
+
+void local_clk_disable(struct uio_pdrv_genirq_platdata *priv)
+{
+	if (priv->clk_cnt > 0) {
+		clk_disable(priv->clk);
+		priv->clk_cnt--;
+	}
+}
+
 static int uio_pdrv_genirq_open(struct uio_info *info, struct inode *inode)
 {
 	struct uio_pdrv_genirq_platdata *priv = info->priv;
 
 	/* Wait until the Runtime PM code has woken up the device */
-	pm_runtime_get_sync(&priv->pdev->dev);
+	local_pm_runtime_get_sync(priv);
 	return 0;
 }
 
@@ -53,7 +106,7 @@ static int uio_pdrv_genirq_release(struct uio_info *info, struct inode *inode)
 	struct uio_pdrv_genirq_platdata *priv = info->priv;
 
 	/* Tell the Runtime PM code that the device has become idle */
-	pm_runtime_put_sync(&priv->pdev->dev);
+	local_pm_runtime_put_sync(priv);
 	return 0;
 }
 
@@ -73,6 +126,147 @@ static irqreturn_t uio_pdrv_genirq_handler(int irq, struct uio_info *dev_info)
 	return IRQ_HANDLED;
 }
 
+/**
+ * Changes the drivers power state
+ * if value == 0, calls pm_runtime_get_sync
+ * if value == 1, calls pm_runtime_put_sync
+ */
+static void priv_set_pwr(struct uio_info *info, int value)
+{
+	struct uio_pdrv_genirq_platdata *priv = info->priv;
+
+	if (((value == 0) && priv->pwr_cnt > 0) || ((value != 0) && priv->pwr_cnt == 0)) { // change pwr state
+		if (value == 0)
+			local_pm_runtime_put_sync(priv);
+		else
+			local_pm_runtime_get_sync(priv);
+	}
+
+	dev_dbg(&priv->pdev->dev, "Set power state - value = 0x%x pwr_cnt=%d, clk_cnt=%d\n",
+			 value, priv->pwr_cnt, priv->clk_cnt);
+}
+
+/**
+ * Gets the power status of the driver, priv->pwr_cnt is returned
+ */
+static int priv_get_pwr(struct uio_info *info)
+{
+	struct uio_pdrv_genirq_platdata *priv = info->priv;
+
+	dev_dbg(&priv->pdev->dev, "Get power state  pwr_cnt=%d, clk_cnt=%d\n",
+			 priv->pwr_cnt, priv->clk_cnt);
+
+	return priv->pwr_cnt;
+}
+
+/**
+ * Changes the drivers clock state
+ * if value == 0, calls local_clk_disable
+ * if value == 1, calls local_clk_enable
+ */
+static void priv_set_clk(struct uio_info *info, int value)
+{
+	struct uio_pdrv_genirq_platdata *priv = info->priv;
+
+	if (value == 0)
+		local_clk_disable(priv);
+	else
+		local_clk_enable(priv);
+
+	dev_dbg(&priv->pdev->dev, "Set clock state - value = 0x%x clk_cnt=%d\n",
+			 value, priv->clk_cnt);
+}
+
+/**
+ * Gets the clock status of the driver
+ * Returns priv->clk_cnt
+ */
+static int priv_get_clk(struct uio_info *info)
+{
+	struct uio_pdrv_genirq_platdata *priv = info->priv;
+
+	dev_dbg(&priv->pdev->dev, "Get clock state - clk_cnt=%d\n", priv->clk_cnt);
+
+	return priv->clk_cnt;
+}
+
+static void priv_set_rst(struct uio_info *info, int value)
+{
+	struct uio_pdrv_genirq_platdata *priv = info->priv;
+	int status;
+
+	status = reset_control_status(priv->rst);
+
+	switch (value) {
+	case 0 :
+		if (status > 0)
+			reset_control_deassert(priv->rst);
+		break;
+	case 1 :
+		reset_control_reset(priv->rst);
+		break;
+	default :
+		if (status == 0)
+			reset_control_assert(priv->rst);
+		break;
+	}
+
+	dev_dbg(&priv->pdev->dev, "Set reset state - value = 0x%x\n", value);
+}
+
+static int priv_get_rst(struct uio_info *info)
+{
+	struct uio_pdrv_genirq_platdata *priv = info->priv;
+	int status;
+
+	status = reset_control_status(priv->rst);
+	dev_dbg(&priv->pdev->dev, "Get reset state 0x%x\n", status);
+
+	return status;
+}
+
+static int uio_pdrv_genirq_ioctl(struct uio_info *info, unsigned int cmd, unsigned long arg)
+{
+	int value;
+
+	switch(cmd) {
+	case UIO_PDRV_SET_PWR:
+		if (copy_from_user(&value ,(int*) arg, sizeof(value)))
+			return -EFAULT;
+		priv_set_pwr(info, value);
+		break;
+	case UIO_PDRV_GET_PWR:
+		value = priv_get_pwr(info);
+		if (copy_to_user((int*) arg, &value, sizeof(value)))
+			return -EFAULT;
+		arg = value;
+		break;
+	case UIO_PDRV_SET_CLK:
+		if (copy_from_user(&value ,(int*) arg, sizeof(value)))
+			return -EFAULT;
+		priv_set_clk(info, value);
+		break;
+	case UIO_PDRV_GET_CLK:
+		value = priv_get_clk(info);
+		if (copy_to_user((int*) arg, &value, sizeof(value)))
+			return -EFAULT;
+		arg = value;
+		break;
+	case UIO_PDRV_SET_RESET:
+		if (copy_from_user(&value ,(int*) arg, sizeof(value)))
+			return -EFAULT;
+		priv_set_rst(info, value);
+		break;
+	case UIO_PDRV_GET_RESET:
+		value = priv_get_rst(info);
+		if (copy_to_user((int*) arg, &value, sizeof(value)))
+			return -EFAULT;
+		break;
+	}
+
+	return 0;
+}
+
 static int uio_pdrv_genirq_irqcontrol(struct uio_info *dev_info, s32 irq_on)
 {
 	struct uio_pdrv_genirq_platdata *priv = dev_info->priv;
@@ -150,6 +344,13 @@ static int uio_pdrv_genirq_probe(struct platform_device *pdev)
 	spin_lock_init(&priv->lock);
 	priv->flags = 0; /* interrupt is enabled to begin with */
 	priv->pdev = pdev;
+	
+	priv->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(priv->clk))
+		priv->clk = NULL;
+
+	priv->clk_cnt = 0;
+	priv->pwr_cnt = 0;
 
 	if (!uioinfo->irq) {
 		ret = platform_get_irq(pdev, 0);
@@ -202,6 +403,7 @@ static int uio_pdrv_genirq_probe(struct platform_device *pdev)
 	uioinfo->irqcontrol = uio_pdrv_genirq_irqcontrol;
 	uioinfo->open = uio_pdrv_genirq_open;
 	uioinfo->release = uio_pdrv_genirq_release;
+	uioinfo->ioctl = uio_pdrv_genirq_ioctl;
 	uioinfo->priv = priv;
 
 	/* Enable Runtime PM for this device:
diff --git a/fs/compat_ioctl.c b/fs/compat_ioctl.c
index a7ec2d3..fa67e22 100644
--- a/fs/compat_ioctl.c
+++ b/fs/compat_ioctl.c
@@ -72,6 +72,8 @@
 #include <asm/fbio.h>
 #endif
 
+#include <linux/renesas_uioctl.h>
+
 #define convert_in_user(srcptr, dstptr)			\
 ({							\
 	typeof(*srcptr) val;				\
@@ -915,6 +917,12 @@ IGNORE_IOCTL(FBIOGETCMAP32)
 IGNORE_IOCTL(FBIOSCURSOR32)
 IGNORE_IOCTL(FBIOGCURSOR32)
 #endif
+COMPATIBLE_IOCTL(UIO_PDRV_SET_PWR)
+COMPATIBLE_IOCTL(UIO_PDRV_GET_PWR)
+COMPATIBLE_IOCTL(UIO_PDRV_SET_CLK)
+COMPATIBLE_IOCTL(UIO_PDRV_GET_CLK)
+COMPATIBLE_IOCTL(UIO_PDRV_SET_RESET)
+COMPATIBLE_IOCTL(UIO_PDRV_GET_RESET)
 };
 
 /*
diff --git a/include/dt-bindings/ipmmu/rcar-ipmmu-domains.h b/include/dt-bindings/ipmmu/rcar-ipmmu-domains.h
new file mode 120000
index 0000000..9bce1eb
--- /dev/null
+++ b/include/dt-bindings/ipmmu/rcar-ipmmu-domains.h
@@ -0,0 +1 @@
+../../uapi/linux/rcar-ipmmu-domains.h
\ No newline at end of file
diff --git a/include/dt-bindings/ipmmu/rcar-ipmmu.h b/include/dt-bindings/ipmmu/rcar-ipmmu.h
new file mode 100644
index 0000000..ff99996
--- /dev/null
+++ b/include/dt-bindings/ipmmu/rcar-ipmmu.h
@@ -0,0 +1,6 @@
+#ifndef _DT_BINDINGS_RCAR_IPMMU_H
+#define _DT_BINDINGS_RCAR_IPMMU_H
+
+#include "rcar-ipmmu-domains.h"
+
+#endif /* _DT_BINDINGS_RCAR_IPMMU_H */
diff --git a/include/linux/uio_driver.h b/include/linux/uio_driver.h
index 01081c4..bcdd000 100644
--- a/include/linux/uio_driver.h
+++ b/include/linux/uio_driver.h
@@ -93,6 +93,7 @@ struct uio_device {
  * @mmap:		mmap operation for this uio device
  * @open:		open operation for this uio device
  * @release:		release operation for this uio device
+ * @ioctl:		ioctl handler
  * @irqcontrol:		disable/enable irqs when 0/1 is written to /dev/uioX
  */
 struct uio_info {
@@ -109,6 +110,7 @@ struct uio_info {
 	int (*open)(struct uio_info *info, struct inode *inode);
 	int (*release)(struct uio_info *info, struct inode *inode);
 	int (*irqcontrol)(struct uio_info *info, s32 irq_on);
+	int (*ioctl)(struct uio_info *info, unsigned int cmd, unsigned long arg);
 };
 
 extern int __must_check
diff --git a/include/uapi/linux/rcar-ipmmu-domains.h b/include/uapi/linux/rcar-ipmmu-domains.h
new file mode 100644
index 0000000..8e297d5
--- /dev/null
+++ b/include/uapi/linux/rcar-ipmmu-domains.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2020 Cogent Embedded Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __LINUX_RCAR_IPMMU_DOMAINS_H__
+#define __LINUX_RCAR_IPMMU_DOMAINS_H__
+
+#define RCAR_IPMMU_INVALID	0
+#define RCAR_IPMMU_MM		1
+#define RCAR_IPMMU_VI0		2
+#define RCAR_IPMMU_VI1		3
+#define RCAR_IPMMU_VP0		4
+#define RCAR_IPMMU_VP1		5
+#define RCAR_IPMMU_VC0		6
+#define RCAR_IPMMU_VC1		7
+#define RCAR_IPMMU_PV0		8
+#define RCAR_IPMMU_PV1		9
+#define RCAR_IPMMU_PV2		10
+#define RCAR_IPMMU_PV3		11
+#define RCAR_IPMMU_IR		12
+#define RCAR_IPMMU_HC		13
+#define RCAR_IPMMU_RT		14
+#define RCAR_IPMMU_MP		15
+#define RCAR_IPMMU_DS0		16
+#define RCAR_IPMMU_DS1		17
+#define RCAR_IPMMU_VIP0		18
+#define RCAR_IPMMU_VIP1		19
+
+#endif /* __LINUX_RCAR_IPMMU_DOMAINS_H__ */
+
diff --git a/include/uapi/linux/renesas_uioctl.h b/include/uapi/linux/renesas_uioctl.h
new file mode 100644
index 0000000..38728f3
--- /dev/null
+++ b/include/uapi/linux/renesas_uioctl.h
@@ -0,0 +1,23 @@
+/*
+ * Renesas IOCTL defines for user io drivers;
+ * used to control power, clock and reset
+ *
+ * $Id: $
+ *
+ * Copyright (C) 2020 by Renesas Electronics
+ *
+ * Redistribution of this file is permitted under
+ * the terms of the GNU Public License (GPL)
+ */
+#ifndef _RENESAS_UIOCTL_H_
+#define _RENESAS_UIOCTL_H_
+
+#define UIO_PDRV_IOCCTL_BASE	'I'
+#define UIO_PDRV_SET_PWR	_IOW(UIO_PDRV_IOCCTL_BASE, 0, int)
+#define UIO_PDRV_GET_PWR	_IOR(UIO_PDRV_IOCCTL_BASE, 1, int)
+#define UIO_PDRV_SET_CLK	_IOW(UIO_PDRV_IOCCTL_BASE, 2, int)
+#define UIO_PDRV_GET_CLK	_IOR(UIO_PDRV_IOCCTL_BASE, 3, int)
+#define UIO_PDRV_SET_RESET	_IOW(UIO_PDRV_IOCCTL_BASE, 4, int)
+#define UIO_PDRV_GET_RESET	_IOR(UIO_PDRV_IOCCTL_BASE, 5, int)
+
+#endif /* _RENESAS_UIOCTL_H_ */
-- 
2.7.4

